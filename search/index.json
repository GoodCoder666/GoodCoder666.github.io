[{"content":"前言\rWolfram Mathematica（简称 MMA），是由 Wolfram Research 开发的科学计算软件。本文我们将介绍 Mathematica 的界面、语法和基本应用。类似的软件还有 MATLAB 和 Maple 等。\nMMA 官网：https://www.wolfram.com/mathematica/\nMMA 的安装及激活：Mathematica安装激活极简教程 - 科研小飞 (知乎)\n本文适合有一定编程基础的读者。当然，如果你不了解编程也没关系，直接跳过相关部分即可。屏幕截图全部来自 Windows 11，Mathematica 13.3。（最新版本 14.0 已经在 2023 年 12 月发布，语法向下兼容）\n界面\r安装并正确激活 MMA 后，新建笔记本，应该能看到如下的界面：\n一张图带你快速熟悉 MMA 的界面：\n几个需要注意的点：\nEnter 默认换行，执行代码需要用 Shift+Enter。 指令面板左侧的红三角形也可执行代码，灰色的正方形用于终止正在进行的运算。 MMA 带有 Notebook（笔记本）功能，由于其主要用于计算而不是笔记，本文不详细介绍，若需要使用可自行查阅相关资料。 对于任意输入或输出，按下Ctrl+Shift+I即可显示输入（代码）形式，按下Ctrl+Shift+N即可显示数学形式。后面会对两种显示形式进行详细讲解。\n语法\rMathematica 实质是一个 Wolfram Language 的解释器，所以使用它之前必须学习 WL 的语法。\n这里介绍基本语法和常用的指令。\n帮助文档\r首先来了解帮助文档的使用。输入 ? Solve 来获取 Solve 函数的说明：\n? 后面可以跟任何函数名，MMA 会直接在笔记本中输出简化版的帮助文档。可以选择输出右上角的 i 来获取更详细的文档（优先打开离线文档，不存在则默认打开在线文档）。菜单栏中的 “帮助 -\u0026gt; Wolfram 参考资料” 可以打开完整版文档。\n注释\r1 (* 注释 *) 如上，MMA 的注释使用 (* 和 *) 来标注，用法类似于 C/C++ 中的 /* 和 */。注释可以添加在代码的任何位置，它们会被自动忽略。例如：\n1 2 1 + 1 (*Hello*) 1 + (*World*)1 这两行代码在实际执行中与 1 + 1 无区别：\n括号\r在学习 MMA 的函数之前，一定要先学会括号的使用！！\n官方参考文档：正确使用括号和大括号\nMMA 中共有四种括号，分别为 ()、[]、{} 和 [[]]，具体作用如下：\n圆括号 ()\r用作对表达式编组和确定运算的优先次序：\n方括号 []\r表示函数的调用和传参：\n大括号 {}\r表示列表：\n列表的具体使用后续会介绍。\n双方括号 [[]]\r表示对列表元素的访问，实质是函数 Part 的简写形式：\n同样会在后面具体介绍。\n运算与表达式\rMMA 支持基本的数学运算，见下表：\n名称 符号形式 函数形式 数学形式 加法 a + b Plus[a, b] $a+b$ 减法 a - b Subtract[a, b] $a-b$ 乘法 a * b1 Times[a, b] $a\\times b$ 除法 a / b Divide[a, b] $\\frac ab$ 幂 a ^ b Power[a, b] $a^b$ 模余 - Mod[a, b] $a\\bmod b$ 数字和符号都可以参与运算：\n表达式是一个或多个运算/函数调用的组合，使用()指定优先级。上图中 4*5、a+a、3 x y/y 都是合法的表达式。\n需要注意的是，MMA 只会对输入的表达式进行约分、合并同类项，而不会自动执行需要展开的化简。必要时可以使用 Simplify 或 FullSimplify 函数：\n关于函数的使用，后面会详解。\n布尔表达式\r表达式也可以是等式或不等式：\n注意等式用两个等号 == 连接，单个等号表示变量赋值。\n不等式可以用 !=（不等于）、\u0026gt;（大于）、\u0026gt;=（大于等于）、\u0026lt;（小于）、\u0026lt;=（小于等于）连接。!=、\u0026gt;= 和 \u0026lt;= 在输入时会自动转换为相应的数学符号。\n这类返回值为 True（真）或 False（假）的表达式，我们统称为布尔表达式。可以用 \u0026amp;\u0026amp; 和 || 运算符来连接两个布尔表达式，分别表示“与”“或”，所得结果仍为布尔表达式。\n绝大部分布尔表达式都不能自动化简，但可以通过 Simplify、FullSimplify 或 Solve、Reduce 来化简或求解：\n变量与常数\rMMA 中，使用 变量名 = 值 的形式来声明或赋值变量：\n由上方 10a + 3 的计算结果可知，表达式中所有已声明的变量都会被替换成变量值。变量的声明也可以包含其他变量和符号，此时仍符合变量替换法则：\n用于解方程的 Solve 函数没有返回 $a$ 的解，而是返回 $x$ 的解，说明表达式在解析时 $a$ 被自动替换为了 $x$。\n除此之外，还可以用类似于 Python 的语法，同时赋值多个变量：\n1 {a, b, c} = {1, 2, 3} 这行代码可以把变量 $a,b,c$ 分别赋值为 $1,2,3$。\n若要取消声明一个变量，可以使用 Clear[变量名]：\n在使用 MMA 的过程中，我们会发现某些特定符号不能声明为变量，且有一个固定不变的值。这些是内置常量：\n常量 名称 近似值 数学形式 Pi 圆周率 $3.141592654$ $\\pi$ E 自然常数 $2.718281828$ $\\mathrm e$ I 虚数单位 - $i$ Infinity 无穷大 - $\\infty$ Degree 度 - $\\degree$ 函数\r在前面的讲解中，我们多次提到函数。现在，让我们详细解读函数的使用。\n调用\r要调用一个函数，只需输入 函数名[参数1, 参数2, ...] 即可：\n对于只有一个参数的函数，可以用 参数 // 函数名 的形式调用。这种形式常用于 Simplify（化简）、FullSimplify（完全简化）和 N（数值运算）的调用：\n这种写法的最大优点在于可以链式调用：\n定义\r说完了函数的调用，再来说说新函数的定义。\nMMA 中，定义新函数的语法为 函数名[参数1_, 参数2_, ...] := 返回值。注意每个参数名后面都要加一个下划线（_）。\n定义新函数推荐用 :=，但使用 = 也可行。\n拓展 - 定义递归函数\n参考下面定义斐波那契数列的格式：\n内置函数\rMMA 中有将近 $6000$ 个内置函数2，它们都以大写字母开头。下面介绍几种常用的内置函数：\n数值运算 N\r数值运算函数 N：\nN[expr] 给出 $\\mathrm{expr}$ 的数值值 N[expr, n] 尝试给出具有 $n$ 位精度的结果 使用示例：\n三角函数\rMMA 内置了各类三角函数，它们全部使用习惯名称且首字母大写（Sin、Sinh、ArcSin），这里不一一阐释。\n只说一个注意点，MMA 中三角函数的参数默认是弧度，若要使用角度必须加上 Degree 单位：\n解方程和不等式 Solve/Reduce\r解方程 Solve：\n解不等式用 Reduce：\nReduce 还有更高级的使用，可以约化各种表达式：\n这句话说的是：求解 $a,b$ 的范围，使得存在 $x$ 满足等式 $ax=b$。实际上就是在求解使一元一次方程有解的参数值。注意 Solve 和 Reduce 不一定总返回最简形式的表达式，很多情况下需要手动调用 Simplify 或 FullSimplify 进行化简。感兴趣的读者可以自行测试上面的例子中不使用 Simplify 的返回结果。\n解方程的其他方法 NSolve/FindInstance\rNSolve 用法同 Solve，但会返回数值解而不是精确解。相当于 Solve[...] // N。\nFindInstance 用法同 Solve，但添加了一个参数表示至多返回解的个数（默认为 $1$）：\n极点值 Maximize/Minimize\rMinimize 返回函数（在限制条件下）的最小值以及取到最小值的（一种）变量值：\n如上图中的示例，Minimize 支持多个变量，可以指定条件，也可指定求解域。\nMaximize 用法完全相同，返回最大值，此处略过。\n偏导 D\r偏导 D 的两种最常用用法：\nD[f, x] 给出 $f$ 关于 $x$ 的偏导。 D[f, {x, n}] 给出 $f$ 关于 $x$ 的 $n$ 阶偏导。 示例略。注意 f'[x] 可以直接求出 f[x] 的导数：\n积分 Integrate\r积分 Integrate：\nIntegrate[f, x] 给出不定积分 $\\int f~\\mathrm{d}x$。 Integrate[f, {x, x_min, x_max}] 给出定积分 $\\int_{x_{min}}^{x_{max}} f~\\mathrm{d}x$。 Integrate[f, {x, x_min, x_max}, {y, y_min, y_max}, ...] 给出多重积分 $\\int_{x_{min}}^{x_{max}} \\mathrm{d}x \\int_{y_{min}}^{y_{max}} \\mathrm{d}y\\dots f$。 一个简单的定积分示例：\n展开 Expand/ExpandAll\rExpand 很好理解，Expand[expr] 会展开表达式 $\\mathrm{expr}$ 中的乘积和正整数幂。限于篇幅，这里不提供使用范例，可参考官方文档。\nExpandAll 在 Expand 的基础上，会展开表达式中任意位置的乘积和整数幂。如表达式 Sin[(1 + x)^3]，Expand 不会展开其中的 (1+x)^3，而 ExpandAll 会。\n因式分解 Factor\rFactor[poly]：在整数上对一个多项式分解因式。使用示例参考官方文档。\n绘图 Plot/Plot3D\rPlot 和 Plot3D 的用法较为复杂，这里只介绍最基本的函数绘图：\n两个语句分别绘制：\n$\\sin(x)$ 的图像，其中 $-2\\pi\\le x\\le 2\\pi$； $\\sin(x+y^2)$ 的图像，其中 $-3\\le x\\le 3$，$-2\\le y\\le 2$。 总结\r我自己当初学习 MMA 时，被网上杂乱的教程搞得混乱不堪。因此就想写一篇教程，涵盖所有常用语法知识点，并让初学者避开我自己踩的一些坑。\n初衷是写个简明的教程，结果一写就是八千多字…… 也感谢认真读到这里的读者们！\n后续可能还会更一些用 Mathematica 解决数学和实际问题的文章，敬请期待！\n乘法也可简写为 a b（中间必须有空格）。MMA 中，大部分空格可省略，但是乘法的空格不能省略（若写作没有空格的 ab 会被认为是一个变量）。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.wolfram.com/language/fast-introduction-for-programmers/en/built-in-functions/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-01-26T17:12:00+08:00","permalink":"https://goodcoder666.github.io/p/mathematica-intro/","title":"Mathematica 入门"},{"content":"A - Christmas Present\r题目大意\r给定两个正整数 $B,G$（$1\\le B,G\\le 1000$ 且 $B\\ne G$），判断哪个更大。\n分析\r模拟即可。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int b, g; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;b, \u0026amp;g); puts(b \u0026gt; g? \u0026#34;Bat\u0026#34;: \u0026#34;Glove\u0026#34;); return 0; } B - Christmas Trees\r题目大意\r给定 $A,M,L,R$。\n对于任意整数 $k$，Snuke 都会在数轴上的 $A+kM$ 处放置一棵圣诞树。\n试问区间 $[L,R]$ 中共有多少棵圣诞树？\n$-10^{18}\\le A\\le 10^{18}$\n$1\\le M\\le 10^9$\n$-10^{18}\\le L\\le R\\le 10^{18}$\n分析\r不难发现，对于任意整数 $x$，数轴上 $x$ 处有圣诞树当且仅当 $x \\equiv A \\ (\\bmod \\ M)$。变形可得 $x-A \\equiv 0 \\ (\\bmod \\ M)$，即 $(x-A) \\mid M$。故只需考虑相对于 $A$ 的坐标，所以统计 $[L-A,R-A]$ 中 $M$ 的倍数数量即可。\n代码\r使用 C++ 语言时，注意正确处理负数的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;cstdio\u0026gt; using namespace std; using LL = long long; int main() { LL a, l, r; int m; scanf(\u0026#34;%lld%d%lld%lld\u0026#34;, \u0026amp;a, \u0026amp;m, \u0026amp;l, \u0026amp;r); l -= a, r -= a; if(l \u0026lt; 0) l = -((-l) / m * m); else l = (l + m - 1) / m * m; if(r \u0026lt; 0) r = -((-r + m - 1) / m * m); else r = r / m * m; printf(\u0026#34;%lld\\n\u0026#34;, (r - l) / m + 1); return 0; } C - Socks 2\r题目大意\r有长为 $2N$ 的序列 $S=(1,1,2,2,\\dots,N,N)$。\n给定 $A=(A_1,\\dots,A_K)$，将 $S$ 中数字 $A_1,\\dots,A_K$ 各拿掉一个，剩余 $2N-K$ 个。\n对这 $2N-K$ 个数进行两两组合（可能剩余 $1$ 个），使得每对数之差的绝对值之和最小。输出这个最小和。\n$1\\le K\\le N\\le 2\\times 10^5$\n$1\\le A_1 \u003c A_2 \u003c \\dots \u003c A_K\\le N$\n分析\r首先，可以证明我们一定会将 $N-K$ 个成双的数字进行自我组合。\n简要证明\n采用 反证法。假设有两个 $a$，我们将它们分别与 $b,c$ 组合。显然：\n$$|a-b|+|a-c| \\ge |a-a|+|b-c|$$于是，将 $a,a$ 组合、$b,c$ 组合的方案一定不比原方案差。因此直接组合 $a,a$，一定能得到最优解。\n由于 $|a-a|=0$，所以这部分可以直接忽略，将单个的数字，即 $A_1,\\dots,A_K$ 进行组合即可。\n分两种情况讨论。\n$K$ 为偶数：此时组合没有剩余。不难发现，相邻两两组合即为最优解，所以答案为：\n$$\\mathrm{ans}=\\sum_{i=1}^{k/2} A_{2i}-A_{2i-1}$$直接计算即可。注意 $A$ 已排序，故无需取绝对值。\n$K$ 为奇数：此时组合剩余一个。枚举此剩余的数，从 $A$ 中删去就转换成了偶数的情况。但是暴力计算的时间复杂度为 $\\mathcal O(K^2)$，维护前缀后缀和即可优化到 $\\mathcal O(K)$。\n综上，我们在 $\\mathcal O(K)$ 的时间内解决了此问题。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; inline void setmin(int\u0026amp; x, int y) { if(y \u0026lt; x) x = y; } int a[maxn], pre[maxn], suf[maxn]; int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=1; i\u0026lt;=k; i++) scanf(\u0026#34;%d\u0026#34;, a + i); if(!(k \u0026amp; 1)) { int ans = 0; for(int i=1; i\u0026lt;=k; i+=2) ans += a[i + 1] - a[i]; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } for(int i=1; i\u0026lt;k; i+=2) pre[i] = pre[i + 1] = pre[i - 1] + a[i + 1] - a[i]; for(int i=k-1; i\u0026gt;0; i-=2) suf[i] = suf[i + 1] = suf[i + 2] + a[i + 1] - a[i]; int ans = 1e9; for(int i=1; i\u0026lt;=k; i++) { int cur = i \u0026amp; 1? pre[i - 1] + suf[i + 1] : a[i + 1] - a[i - 1] + pre[i - 2] + suf[i + 2]; setmin(ans, cur); } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Reindeer and Sleigh\r题目大意\r有 $N$ 个雪橇，编号为 $1,2,\\dots,N$。拉动第 $i$ 个雪橇需要 $R_i$ 只驯鹿。\n给定 $Q$ 次询问，每次给定正整数 $X$：\n$X$ 只驯鹿最多能拉动多少个雪橇？ 注意：雪橇可以任选，每只驯鹿最多只能拉一个雪橇。\n$1\\le N,Q\\le 2\\times 10^5$\n$1\\le R_i\\le 10^9$\n$1\\le X\\le 2\\times 10^{14}$\n分析\r首先，为了拉到最多的雪橇，我们考虑贪心的策略：从 $R_i$ 最小的雪橇开始拉，从小到大直到驯鹿不够用为止。\n因此我们先对 $R_i$ 进行排序，很明显这不影响结果。此时令前缀和 $S_i=\\sum_{j=1}^i R_j$，则当 $S_i \\le X$ 时，可以拉动前 $i$ 个雪橇。故只需找到最大的 $i$ 使得 $S_i\\le X$ 即为所求。此时注意到前缀和已经有序，所以直接在 $S$ 上使用二分查找即可。\n总时间复杂度为 $\\mathcal O(N\\log N)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 200005 using namespace std; using LL = long long; LL s[maxn]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%lld\u0026#34;, s + i); sort(s, s + n); for(int i=1; i\u0026lt;n; i++) s[i] += s[i - 1]; while(q--) { LL x; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); printf(\u0026#34;%d\\n\u0026#34;, int(upper_bound(s, s + n, x) - s)); } return 0; } E - Christmas Color Grid 1\r题目大意\r有一个 $H\\times W$ 的网格，其中.代表红色，#代表绿色。\n随机选一个红色方块，将其涂成绿色。将网格抽象成一张简单无向图，边连接相邻（上下左右）的绿色节点。\n图中连通分量个数的期望值是多少？对 $998244353$ 取模。\n$1\\le H,W\\le 1000$\n分析\r暴力算法的时间复杂度是 $\\mathcal O(H^2W^2)$，显然不满足要求。\n考虑将一个红色方块涂成绿色对绿色连通分量数的贡献。令它周围属于不同连通分量的绿色方块个数为 $n$，则此次操作会将答案减去 $n-1$。这样，我们先预处理出连通分量，就可以 $\\mathcal O(1)$ 的计算答案。\n此问题可以用 DFS、BFS 或并查集解决。示例代码使用并查集，时间复杂度约为 $\\mathcal O(HW)$（忽略小函数）。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;atcoder/modint\u0026gt; #define maxn 1005 using namespace std; using modint = atcoder::modint998244353; int n, m, fa[maxn * maxn]; char s[maxn][maxn]; int find(int x) { return fa[x] == x? fa[x]: fa[x] = find(fa[x]); } inline int calc(int x, int y) { return x * m + y; } inline int fc(int x, int y) { return find(calc(x, y)); } inline void merge(int x, int y) { fa[find(x)] = find(y); } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%s\u0026#34;, s[i]); int k = n * m; for(int i=0; i\u0026lt;k; i++) fa[i] = i; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;m; j++) { if(s[i][j] != \u0026#39;#\u0026#39;) continue; if(i \u0026amp;\u0026amp; s[i - 1][j] == \u0026#39;#\u0026#39;) merge(calc(i, j), calc(i - 1, j)); if(j \u0026amp;\u0026amp; s[i][j - 1] == \u0026#39;#\u0026#39;) merge(calc(i, j), calc(i, j - 1)); } int cnt = 0, tot = 0; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;m; j++) if(s[i][j] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; fc(i, j) == calc(i, j)) cnt ++; modint ans = 0; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;m; j++) if(s[i][j] == \u0026#39;.\u0026#39;) { set\u0026lt;int\u0026gt; S; if(i \u0026amp;\u0026amp; s[i - 1][j] == \u0026#39;#\u0026#39;) S.insert(fc(i - 1, j)); if(s[i + 1][j] == \u0026#39;#\u0026#39;) S.insert(fc(i + 1, j)); if(j \u0026amp;\u0026amp; s[i][j - 1] == \u0026#39;#\u0026#39;) S.insert(fc(i, j - 1)); if(s[i][j + 1] == \u0026#39;#\u0026#39;) S.insert(fc(i, j + 1)); int cur = cnt - (int)S.size() + 1; ans += cur, tot ++; } printf(\u0026#34;%d\\n\u0026#34;, (ans / tot).val()); return 0; } F - Christmas Present 2\r题目大意\r圣诞老人 Santa 要在平面直角坐标系中给孩子们送礼物啦！\n他的家在 $(S_X,S_Y)$ 处。他要按照数字顺序给 $N$ 个孩子送出礼物。第 $i$ 个孩子的家在 $(X_i,Y_i)$ 处。\nSanta 手上最多只能一次性拿 $K$ 个礼物。他想用最短的路程送完所有礼物，再回到自己家，求最短的总路程是多少？\n$1\\le K\\le N\\le 2\\times 10^5$\n$-10^9\\le S_X,S_Y,X_i,Y_i \\le 10^9$\n$(S_X,S_Y)\\ne (X_i,Y_i)$\n$(X_i,Y_i)\\ne (X_j,Y_j)\\ (i\\ne j)$\n分析\r这里介绍我自己的独具特（chōu）色（xiàng）的解法，常规解法请参考官方题解。\n$$\rf_{i,j}=\\begin{cases}\rd(i-1,i)+f_{i-1,j+1} \u0026 (j \u003c k-1)\\\\\r\\min f_{i-1}+d(i-1,0)+d(0,i) \u0026 (j=k-1)\r\\end{cases}\r$$\n其中 $d(a,b)$ 表示房子 $a$ 到 $b$ 的路程。特别规定 $0$ 号房子为 $(S_X,S_Y)$，即圣诞老人的住处。这样，答案即为 $\\min f_n+d(n,0)$。\n直接计算的复杂度为 $\\mathcal O(NK)$，时间和空间上都不能接受。\n然而，仔细观察递推式可以发现，$f_i$ 这一行实际上就是由前一行 $f_{i-1}$ 删去第一个元素，再整体加 $d(i-1,i)$，并在最后添上 $f_{i,k-1}$ 得到的。\n因此，我们可以用一个deque（双端队列）动态维护状态。对于整体加的操作，用一个变量维护整体的变化值即可。这样空间的问题就得到了解决。再进一步考虑，用一个multiset（可重集合，基于红黑树）或者二叉堆维护队列内元素，求 $\\min$ 的操作时间就减小到了 $\\mathcal O(\\log K)$，可以接受。\n于是，我们就成功地在 $\\mathcal O(N\\log K)$ 的时间和 $\\mathcal O(N+K)$ 的空间内解决了此问题。另外，我们还可以把deque同时充当单调队列，这样时间也优化到了 $\\mathcal O(N+K)$。两种实现的示例代码都会给出。\n代码\r实现 1：deque + multiset\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 200005 using namespace std; using ld = long double; const ld INF = 2e18l; int x[maxn], y[maxn]; inline ld dis(int i, int j) { return __builtin_hypotl(x[i] - x[j], y[i] - y[j]); } int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;=n; i++) scanf(\u0026#34;%d%d\u0026#34;, x + i, y + i); deque\u0026lt;ld\u0026gt; f; multiset\u0026lt;ld\u0026gt; s; k --; for(int i=0; i\u0026lt;k; i++) f.push_back(INF), s.insert(INF); f.push_back(dis(0, 1)), s.insert(dis(0, 1)); ld dt = 0; for(int i=2; i\u0026lt;=n; i++) { ld lt = *s.begin() + dis(i - 1, 0) + dis(0, i) + dt; s.erase(s.find(f.front())), f.pop_front(); dt += dis(i - 1, i), lt -= dt; f.push_back(lt), s.insert(lt); } printf(\u0026#34;%.15Lf\\n\u0026#34;, dt + *s.begin() + dis(n, 0)); return 0; } 实现 2：单调队列\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;deque\u0026gt; #define maxn 200005 using namespace std; int x[maxn], y[maxn]; inline double dis(int i, int j) { return __builtin_hypotl(x[i] - x[j], y[i] - y[j]); } int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;=n; i++) scanf(\u0026#34;%d%d\u0026#34;, x + i, y + i); deque\u0026lt;pair\u0026lt;double, int\u0026gt;\u0026gt; f; f.emplace_back(dis(0, 1), 1); double dt = 0; for(int i=2; i\u0026lt;=n; i++) { double lt = f.front().first + dis(i - 1, 0) + dis(0, i) + dt; if(f.front().second == i - k) f.pop_front(); dt += dis(i - 1, i), lt -= dt; while(!f.empty() \u0026amp;\u0026amp; f.back().first \u0026gt;= lt) f.pop_back(); f.emplace_back(lt, i); } printf(\u0026#34;%.15lf\\n\u0026#34;, dt + f.front().first + dis(n, 0)); return 0; } G - Christmas Color Grid 2\r题目大意\r有一个 $H\\times W$ 的网格，其中.代表红色，#代表绿色。\n随机选一个绿色方块，将其涂成红色。将网格抽象成一张简单无向图，边连接相邻（上下左右）的绿色节点。\n图中连通分量个数的期望值是多少？对 $998244353$ 取模。\n$1\\le H,W\\le 1000$\nE 与 G 的区别\nE：将红色涂成绿色。求绿色连通块个数。 G：将绿色涂成红色。求绿色连通块个数。 分析\r注意到本题中红色方块没有任何实质意义，于是先将绿色方块建成一张图。此时题目变为：\n从简单无向图中随机选取一个结点，将此结点和与其相连的边全部删除。求连通分量个数的期望值，对 $998244353$ 取模。 根据“删去无向图中一个点导致连通分量个数改变”，很容易联想到割点。对求割点的 Tarjan 算法稍加改编，就可以计算删去一个点能把图分割成的连通块个数。详见代码。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;atcoder/modint\u0026gt; #define maxn 1000005 using namespace std; using modint = atcoder::modint998244353; inline void setmin(int\u0026amp; x, int y) { if(y \u0026lt; x) x = y; } vector\u0026lt;int\u0026gt; G[maxn]; inline void add(int x, int y) { G[x].push_back(y); G[y].push_back(x); } int root, low[maxn], cnt, dfn[maxn], ncut[maxn]; void tarjan(int v) { low[v] = dfn[v] = ++cnt; ncut[v] = v != root; for(int u: G[v]) if(!dfn[u]) { tarjan(u); if(low[u] \u0026gt;= dfn[v]) ncut[v] ++; setmin(low[v], low[u]); } else setmin(low[v], dfn[u]); } char s[1005][1005]; int id[1005][1005]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%s\u0026#34;, s[i] + 1); int num = 0; for(int i=1; i\u0026lt;=n; i++) for(int j=1; j\u0026lt;=m; j++) if(s[i][j] == \u0026#39;#\u0026#39;) { id[i][j] = ++num; if(s[i - 1][j] == \u0026#39;#\u0026#39;) add(num, id[i - 1][j]); if(s[i][j - 1] == \u0026#39;#\u0026#39;) add(num, id[i][j - 1]); } int cc = -1; for(int i=1; i\u0026lt;=num; i++) if(!dfn[i]) tarjan(root = i), cc ++; modint ans = 0; for(int i=1; i\u0026lt;=num; i++) ans += cc + ncut[i]; printf(\u0026#34;%d\\n\u0026#34;, (ans / num).val()); return 0; } 后记\r首先预祝大家圣诞节快乐 \u0026#x1f389;！这场比赛从标题到题目设定，无不与圣诞节有关，AtCoder 官方算是精心准备了这场圣诞庆祝赛 \u0026#x1f49d;。\n遗憾的是我在比赛中先做了 A~E 和 G，F 题比赛结束后 51s 提交，AC。挺可惜的，难得 G 能做出来一次，差点 AK，结果差的就是不到一分钟 \u0026#x1f602;。希望下次能比得更好，也希望大家能再接再厉。加油！\u0026#x1f61a;\n","date":"2023-12-24T12:05:00+08:00","permalink":"https://goodcoder666.github.io/p/abc334/","title":"UNIQUE VISION Programming Contest 2023 Christmas (AtCoder Beginner Contest 334) A~G 题解"},{"content":"题目传送门\n洛谷博客 博客园\n基本思路\r本题主要考查编码能力，所以直接给出基本思路：\n由于可以递归式的创建元素，最多可以同时存在 $100^{100}$ 个不同的基础类型的元素。即使算上最大地址的限制，元素的数量也能达到 $10^{18}$。显然，依次构造每个元素，在空间和时间上都是无法接受的。 然而，由于询问数量有限，真正能在查询时用到的元素数量相对很少。因此，我们只需维护一个顶层元素（不隶属于任何其他元素的元素）列表，再根据查询的地址或名称逐层向下找到需要的元素即可。以下是四种操作的具体做法： 对于 $op=1$：储存当前类型信息，计算大小和对齐要求并输出。 对于 $op=2$：用一个变量记录当前第一个可分配内存的地址，操作时先对齐后计算、输出。 对于 $op=3$：从顶层开始，逐层向下寻找，计算地址并输出。 对于 $op=4$：从顶层开始，维护当前考查的元素地址，并与给定地址比对，最终输出底层元素名称。 由以上思路，很容易想到下面三种类型的存储方式：\n用类型名称作为类型的唯一的标识符。这是最直观的做法，但是效率低下且使用起来较为繁琐，pass。 用 map 将类型名称映射到序号，来代表一种数据类型。相比第一种做法，效率高了很多，但是写起来仍然很麻烦，pass。 用结构体存储类型信息，并使用指针来处理类型之间的关联。这种做法不仅高效，而且编码时也很直观，所以我们将采用这种存储方式。 分步详解\r准备\r用 LL 表示 long long，setmax(x, y) 等同于 x = max(x, y)：\n1 2 3 4 5 6 inline void setmax(int\u0026amp; x, int y) { if(x \u0026lt; y) x = y; } using LL = long long; 数据类型的存储\r定义 struct DataType，表示一种数据类型：\n1 2 3 4 5 6 7 struct DataType { const string name; // 类型名 LL size, actual_size; // 对齐后的大小和实际大小（有数据的部分的长度） int indent; // 对齐要求 vector\u0026lt;pair\u0026lt;DataType*, string\u0026gt;\u0026gt; members; // 类型成员，\u0026lt;成员类型指针，成员名称\u0026gt; 方式存储 }; $$\r{对齐后的地址} = \\lceil \\frac {对齐前的地址} {对齐要求} \\rceil \\times {对齐要求}\r$$ 1 2 3 4 inline LL shift(LL addr) { return addr % indent? (addr / indent + 1) * indent: addr; } 维护操作，用于操作 $1$ 后计算大小：\n1 2 3 4 5 6 7 8 9 10 11 inline void maintain() { size = indent = 0; for(const auto\u0026amp; m: members) { setmax(indent, m.first-\u0026gt;indent); size = m.first-\u0026gt;shift(size) + m.first-\u0026gt;size; } actual_size = size; size = shift(size); } 注意 shift 和 maintain 都是 DataType 的成员函数。\n主函数中，用一个 unordered_map 记录类型名到数据类型的映射关系：\n1 unordered_map\u0026lt;string, DataType*\u0026gt; types; 添加基本类型：\n1 2 3 4 5 6 7 8 9 auto add_base_type = [\u0026amp;](string name, int size) -\u0026gt; void { DataType* t = new DataType(name); t-\u0026gt;size = t-\u0026gt;indent = t-\u0026gt;actual_size = size; types[name] = t; }; add_base_type(\u0026#34;byte\u0026#34;, 1); add_base_type(\u0026#34;short\u0026#34;, 2); add_base_type(\u0026#34;int\u0026#34;, 4); add_base_type(\u0026#34;long\u0026#34;, 8); 操作 1：定义类型\r由于 DataType 中已经实现维护操作，简单处理一下输入即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 string s; int k; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; DataType* type = new DataType(s); types[s] = type; type-\u0026gt;members.resize(k); for(auto\u0026amp; m: type-\u0026gt;members) { string t; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; m.second; m.first = types[t]; } type-\u0026gt;maintain(); cout \u0026lt;\u0026lt; type-\u0026gt;size \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; type-\u0026gt;indent \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 操作 2：定义元素\r根据「基本思路」中给出的做法，维护当前第一个可分配的地址和顶层元素列表：\n1 2 LL cur_addr = 0LL; vector\u0026lt;Object\u0026gt; toplevel_objects; Object 的定义：\n1 2 3 4 5 6 struct Object { DataType* type; // 类型 string name; // 名称 LL addr; // 地址 }; 计算地址并保存元素：\n1 2 3 4 5 6 7 Object obj; string t; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; obj.name; // 输入 obj.type = types[t]; // 找到类型指针 obj.addr = obj.type-\u0026gt;shift(cur_addr); // 对齐 cur_addr = obj.addr + obj.type-\u0026gt;size; // 更新可分配的地址 toplevel_objects.push_back(obj); // 保存元素 输出元素地址：\n1 cout \u0026lt;\u0026lt; obj.addr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 操作 3：访问元素\r定义一个辅助函数，类似于 Python 中的 split()，将一个字符串根据指定分隔符分成若干段：\n1 2 3 4 5 6 7 8 9 inline void split(const string\u0026amp; s, char sep, vector\u0026lt;string\u0026gt;\u0026amp; res) { string t; for(char c: s) if(c == sep) res.push_back(t), t.clear(); else t += c; res.push_back(t); } 先处理字符串并找到顶层元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 读入 string s; cin \u0026gt;\u0026gt; s; // 分割 vector\u0026lt;string\u0026gt; ord; split(s, \u0026#39;.\u0026#39;, ord); // 根据名称匹配顶层元素 LL addr; DataType* type; for(auto\u0026amp; obj: toplevel_objects) if(obj.name == ord[0]) { addr = obj.addr; type = obj.type; break; } 逐层向下，计算地址：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ord[0] 对应顶层元素名称，删掉 ord.erase(ord.begin()); // 逐层向下遍历 for(string\u0026amp; s: ord) for(auto\u0026amp; m: type-\u0026gt;members) { addr = m.first-\u0026gt;shift(addr); // 地址对齐 if(m.second == s) // 名称匹配 { type = m.first; // 找到下一层，向下遍历 break; } addr += m.first-\u0026gt;size; // 地址移到下一个元素 } 输出最终地址：\n1 cout \u0026lt;\u0026lt; addr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 操作 4：访问地址\r同操作 3，先找到顶层元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 LL addr; cin \u0026gt;\u0026gt; addr; if(addr \u0026gt;= cur_addr) // 大于最高有效地址，直接挂掉 { cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; } DataType* type = nullptr; LL f_addr = 0LL; // 当前考察的地址 string res; // 结果字符串 for(auto\u0026amp; obj: toplevel_objects) { if(addr \u0026lt; obj.addr) goto bad; // 特判由于对齐导致的地址无效 if(addr \u0026lt; obj.addr + obj.type-\u0026gt;size) // 地址在当前范围内，记录结果 { type = obj.type; res = obj.name; f_addr = obj.addr; break; } } 向下寻找并输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 循环条件：(1) 地址有效 (2) 不是基本类型（类型有成员） while(addr \u0026lt; f_addr + type-\u0026gt;actual_size \u0026amp;\u0026amp; !type-\u0026gt;members.empty()) for(auto\u0026amp; m: type-\u0026gt;members) { f_addr = m.first-\u0026gt;shift(f_addr); // 对齐 if(addr \u0026lt; f_addr) goto bad; // 特判，同上 if(addr \u0026lt; f_addr + m.first-\u0026gt;size) { type = m.first; res.push_back(\u0026#39;.\u0026#39;); res += m.second; break; } f_addr += m.first-\u0026gt;size; } if(addr \u0026lt; f_addr + type-\u0026gt;actual_size) cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 地址有效则输出结果 else cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; // 地址无效 continue; bad: cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; // 前面使用的 bad 标签 完整代码\r下面是赛时代码，也是前面讲解中使用的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; inline void setmax(int\u0026amp; x, int y) { if(x \u0026lt; y) x = y; } using LL = long long; struct DataType { const string name; LL size, actual_size; int indent; vector\u0026lt;pair\u0026lt;DataType*, string\u0026gt;\u0026gt; members; inline DataType(const string\u0026amp; n): name(n) {} inline LL shift(LL addr) { return addr % indent? (addr / indent + 1) * indent: addr; } inline void maintain() { size = indent = 0; for(const auto\u0026amp; m: members) { setmax(indent, m.first-\u0026gt;indent); size = m.first-\u0026gt;shift(size) + m.first-\u0026gt;size; } actual_size = size; size = shift(size); } }; struct Object { DataType* type; string name; LL addr; }; inline void split(const string\u0026amp; s, char sep, vector\u0026lt;string\u0026gt;\u0026amp; res) { string t; for(char c: s) if(c == sep) res.push_back(t), t.clear(); else t += c; res.push_back(t); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); unordered_map\u0026lt;string, DataType*\u0026gt; types; auto add_base_type = [\u0026amp;](string name, int size) -\u0026gt; void { DataType* t = new DataType(name); t-\u0026gt;size = t-\u0026gt;indent = t-\u0026gt;actual_size = size; types[name] = t; }; add_base_type(\u0026#34;byte\u0026#34;, 1); add_base_type(\u0026#34;short\u0026#34;, 2); add_base_type(\u0026#34;int\u0026#34;, 4); add_base_type(\u0026#34;long\u0026#34;, 8); int q; cin \u0026gt;\u0026gt; q; vector\u0026lt;Object\u0026gt; toplevel_objects; LL cur_addr = 0LL; while(q--) { int op; cin \u0026gt;\u0026gt; op; if(op == 1) { string s; int k; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; DataType* type = new DataType(s); types[s] = type; type-\u0026gt;members.resize(k); for(auto\u0026amp; m: type-\u0026gt;members) { string t; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; m.second; m.first = types[t]; } type-\u0026gt;maintain(); cout \u0026lt;\u0026lt; type-\u0026gt;size \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; type-\u0026gt;indent \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else if(op == 2) { Object obj; string t; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; obj.name; obj.type = types[t]; obj.addr = obj.type-\u0026gt;shift(cur_addr); cur_addr = obj.addr + obj.type-\u0026gt;size; toplevel_objects.push_back(obj); cout \u0026lt;\u0026lt; obj.addr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else if(op == 3) { string s; cin \u0026gt;\u0026gt; s; vector\u0026lt;string\u0026gt; ord; split(s, \u0026#39;.\u0026#39;, ord); LL addr; DataType* type; for(auto\u0026amp; obj: toplevel_objects) if(obj.name == ord[0]) { addr = obj.addr; type = obj.type; break; } ord.erase(ord.begin()); for(string\u0026amp; s: ord) for(auto\u0026amp; m: type-\u0026gt;members) { addr = m.first-\u0026gt;shift(addr); if(m.second == s) { type = m.first; break; } addr += m.first-\u0026gt;size; } cout \u0026lt;\u0026lt; addr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else // op == 4 { LL addr; cin \u0026gt;\u0026gt; addr; if(addr \u0026gt;= cur_addr) { cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; } DataType* type = nullptr; LL f_addr = 0LL; string res; for(auto\u0026amp; obj: toplevel_objects) { if(addr \u0026lt; obj.addr) goto bad; if(addr \u0026lt; obj.addr + obj.type-\u0026gt;size) { type = obj.type; res = obj.name; f_addr = obj.addr; break; } } while(addr \u0026lt; f_addr + type-\u0026gt;actual_size \u0026amp;\u0026amp; !type-\u0026gt;members.empty()) for(auto\u0026amp; m: type-\u0026gt;members) { f_addr = m.first-\u0026gt;shift(f_addr); if(addr \u0026lt; f_addr) goto bad; if(addr \u0026lt; f_addr + m.first-\u0026gt;size) { type = m.first; res.push_back(\u0026#39;.\u0026#39;); res += m.second; break; } f_addr += m.first-\u0026gt;size; } if(addr \u0026lt; f_addr + type-\u0026gt;actual_size) cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; bad: cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; } } for(auto it=types.begin(); it!=types.end(); it++) delete it-\u0026gt;second; return 0; } 程序共计 $180$ 行，长度 $4.64\\mathrm{KB}$，运行用时 $73\\mathrm{ms}$。\n实际上 Object 的定义没有必要，也不需要存储每个顶层元素的地址，同时还可以稍加压行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using LL = long long; struct DataType { const string name; LL size, actual_size; int indent; vector\u0026lt;pair\u0026lt;DataType*, string\u0026gt;\u0026gt; members; inline DataType(const string\u0026amp; n): name(n) {} inline LL shift(LL addr) { return addr % indent? (addr / indent + 1) * indent: addr; } inline void maintain() { size = indent = 0; for(const auto\u0026amp; m: members) { indent = max(indent, m.first-\u0026gt;indent); size = m.first-\u0026gt;shift(size) + m.first-\u0026gt;size; } actual_size = size; size = shift(size); } }; inline void split(const string\u0026amp; s, char sep, vector\u0026lt;string\u0026gt;\u0026amp; res) { string t; for(char c: s) if(c == sep) res.push_back(t), t.clear(); else t += c; res.push_back(t); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); unordered_map\u0026lt;string, DataType*\u0026gt; types; auto add_base_type = [\u0026amp;](string name, int size) -\u0026gt; void { DataType* t = new DataType(name); t-\u0026gt;size = t-\u0026gt;indent = t-\u0026gt;actual_size = size; types[name] = t; }; add_base_type(\u0026#34;byte\u0026#34;, 1); add_base_type(\u0026#34;short\u0026#34;, 2); add_base_type(\u0026#34;int\u0026#34;, 4); add_base_type(\u0026#34;long\u0026#34;, 8); int q; cin \u0026gt;\u0026gt; q; vector\u0026lt;pair\u0026lt;DataType*, string\u0026gt;\u0026gt; toplevel_objects; LL cur_addr = 0LL; while(q--) { int op; cin \u0026gt;\u0026gt; op; if(op == 1) { string s; int k; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; DataType* type = new DataType(s); types[s] = type; type-\u0026gt;members.resize(k); for(auto\u0026amp; m: type-\u0026gt;members) { string t; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; m.second; m.first = types[t]; } type-\u0026gt;maintain(); cout \u0026lt;\u0026lt; type-\u0026gt;size \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; type-\u0026gt;indent \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else if(op == 2) { string t, name; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; name; DataType* type = types[t]; cur_addr = type-\u0026gt;shift(cur_addr); cout \u0026lt;\u0026lt; cur_addr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cur_addr += type-\u0026gt;size; toplevel_objects.emplace_back(type, name); } else if(op == 3) { string s; cin \u0026gt;\u0026gt; s; vector\u0026lt;string\u0026gt; ord; split(s, \u0026#39;.\u0026#39;, ord); LL addr = 0LL; DataType* type; for(auto\u0026amp; obj: toplevel_objects) { addr = obj.first-\u0026gt;shift(addr); if(obj.second == ord[0]) { type = obj.first; break; } addr += obj.first-\u0026gt;size; } ord.erase(ord.begin()); for(string\u0026amp; s: ord) for(auto\u0026amp; m: type-\u0026gt;members) { addr = m.first-\u0026gt;shift(addr); if(m.second == s) { type = m.first; break; } addr += m.first-\u0026gt;size; } cout \u0026lt;\u0026lt; addr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { LL addr; cin \u0026gt;\u0026gt; addr; if(addr \u0026gt;= cur_addr) { cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; } DataType* type = nullptr; LL f_addr = 0LL; string res; for(auto\u0026amp; obj: toplevel_objects) { f_addr = obj.first-\u0026gt;shift(f_addr); if(addr \u0026lt; f_addr) goto bad; if(addr \u0026lt; f_addr + obj.first-\u0026gt;size) { type = obj.first; res = obj.second; break; } f_addr += obj.first-\u0026gt;size; } while(addr \u0026lt; f_addr + type-\u0026gt;actual_size \u0026amp;\u0026amp; !type-\u0026gt;members.empty()) for(auto\u0026amp; m: type-\u0026gt;members) { f_addr = m.first-\u0026gt;shift(f_addr); if(addr \u0026lt; f_addr) goto bad; if(addr \u0026lt; f_addr + m.first-\u0026gt;size) { type = m.first; res.push_back(\u0026#39;.\u0026#39;); res += m.second; break; } f_addr += m.first-\u0026gt;size; } if(addr \u0026lt; f_addr + type-\u0026gt;actual_size) cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; bad: cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; } } for(auto it=types.begin(); it!=types.end(); it++) delete it-\u0026gt;second; return 0; } 这样只有 $146$ 行，$4.51\\mathrm{KB}$。\n不过个人觉得写个 Object 更清楚，所以讲解的时候就没改啦~\n后记\r算法固然重要，但是编码能力也很重要！强烈建议各位 OIer 重视大模拟，不在这种题上挂分~\n写大模拟需要注意的几个点：\n变量名写清楚，全写 a、b、c、d 到后面自己都不知道是啥，没法调试 该用指针就用指针，不要害怕，用多了会发现真的很好用 适当使用类和结构体，尽量不要全部使用 int 数组 时间复杂度允许的情况下，可读性比性能重要！！（比如本题没有使用二分查找） 祝大家在 NOIP 2023 取得好成绩！求赞qwq\n","date":"2023-12-02T22:21:00+08:00","permalink":"https://goodcoder666.github.io/p/csps2023-t3/","title":"洛谷 P9754 [CSP-S 2023] 结构体 题解"},{"content":"G - Typical Path Problem\r题目大意\r给定一张 $N$ 个点、$M$ 条边的简单无向图 $G$ 和三个整数 $A,B,C$。\n是否存在一条从顶点 $A$ 到 $C$，且经过 $B$ 的简单路径？\n数据范围：\n$3\\le N\\le 2\\times 10^5$ $N-1\\le M\\le \\min(\\frac{N(N-1)}2,2\\times 10^5)$ $1\\le A,B,C\\le N$（$A,B,C$ 互不相同） 什么是 简单路径 ？\n简单路径 是不重复经过同一个点的路径。例如，$1\\to 2\\to 3$ 是简单路径，但 $1\\to 2\\to 1$ 不是简单路径。\n解法1：最大流\r不难发现，存在一条 $A\\to B\\to C$ 的简单路径，当且仅当存在一条 $B\\to A$ 和一条 $B\\to C$ 的路径，使得这两条路径不经过同一个点（$B$ 除外）。因此，我们可以构建网络流模型来解决此问题。\n考虑由 $(2N+2)$ 个点组成的有向图 $G'$：\n源点：$s$ 汇点：$t$ $G$ 中每个点对应的入点：$x_1,\\dots,x_N$ $G$ 中每个点对应的出点：$y_1,\\dots,y_N$ 然后进行连边：\n对于每个 $1\\le i\\le N$，从入点 $x_i$ 向出点 $y_i$ 连接一条流量为 $1$ 的边； 从源点 $s$ 到中转点的入点 $x_B$ 连接一条流量为 $2$ 的边； 从 $A$ 和 $C$ 的出点 $y_A,y_C$ 向汇点 $t$ 分别连接一条流量为 $1$ 的边； 最后，$\\forall (u,v)\\in E_G$，连接 $y_u \\to x_v$ 和 $y_v \\to x_u$，流量为 $1$。 计算 $s$ 到 $t$ 的最大流，如果最大流为 $2$ 则必定有存在不经过同一个顶点的 $B\\to A,B\\to C$ 的路径。\n证明\n显然，如果最大流为 $2$，必然通过了 $y_A$ 和 $y_C$ 向汇点连接的边，则一定分别有 $B\\to A$ 和 $B\\to C$ 的路径。\n假设选择的这两条路径经过了同一顶点 $v$，则两流都必须经过 $x_v\\to y_v$ 这一条流量为 $1$ 的边，此时最大流不可能超过 $1$。而最大流为 $2$，说明假设不成立，故没有经过同一顶点。\n若使用 $\\text{Dinic}$ 算法，由于最大流不超过 $2$，网络流的时间复杂度为 $\\mathcal O(N+M)$。\n代码实现\r在以下的两种实现中，我们规定\n源点：$s=0$ 汇点：$t=2n+1$ $i$ 的入点：$x_i=i$ $i$ 的出点：$y_i=n+i$ AC Library 实现\nAtCoder Library 内置最大流的 $\\text{Dinic}$ 实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;atcoder/maxflow\u0026gt; using namespace std; int main() { int n, m, a, b, c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;a, \u0026amp;b, \u0026amp;c); int s = 0, t = (n \u0026lt;\u0026lt; 1) + 1; atcoder::mf_graph\u0026lt;int\u0026gt; G(t + 1); G.add_edge(s, b + n, 2); G.add_edge(a + n, t, 1); G.add_edge(c + n, t, 1); for(int i=1; i\u0026lt;=n; i++) G.add_edge(i, i + n, 1); while(m--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G.add_edge(x + n, y, 1); G.add_edge(y + n, x, 1); } puts(G.flow(s, t, 2) == 2? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } Dinic 手写实现\n$\\text{Dinic}$ 算法对于此图的时间复杂度为 $\\mathcal O(N+M)$。如果不清楚算法原理可以参考 OI Wiki。\n关于空间分配问题\n由于新图 $G'$ 包含 $(N+2M+3)$ 条边，若使用静态链式前向星存图，数组大小需要开到 $2(N+2M+3)$，其理论最大值为 $1.2\\times 10^6+6$。此处建议使用 $1.25\\times 10^6$ 大小的数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 400005 #define maxm 1250005 using namespace std; int n, s, t, head[maxn], cur[maxn], dis[maxn], cnt, w[maxm], to[maxm], nxt[maxm]; inline void add(int u, int v, int flow) { nxt[cnt] = head[u]; head[u] = cnt; to[cnt] = v; w[cnt++] = flow; } inline void add_flow(int u, int v, int f) { add(u, v, f); add(v, u, 0); } inline bool bfs() { memset(dis, -1, sizeof(int) * n); dis[s] = 0, cur[s] = head[s]; queue\u0026lt;int\u0026gt; q; q.push(s); while(!q.empty()) { int v = q.front(); q.pop(); for(int i=head[v]; ~i; i=nxt[i]) if(w[i]) { int u = to[i]; if(dis[u] == -1) { dis[u] = dis[v] + 1, cur[u] = head[u]; if(u == t) return true; q.push(u); } } } return false; } int dfs(int v, int flow) { if(v == t) return flow; int res = 0; for(int i=cur[v]; ~i \u0026amp;\u0026amp; flow; i=nxt[i]) { cur[v] = i; int u = to[i]; if(w[i] \u0026amp;\u0026amp; dis[u] == dis[v] + 1) { int k = dfs(u, min(flow, w[i])); w[i] -= k; w[i ^ 1] += k; flow -= k; res += k; } } return res; } int main() { int n, m, a, b, c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;a, \u0026amp;b, \u0026amp;c); s = 0, t = (n \u0026lt;\u0026lt; 1) + 1, ::n = t + 1; memset(head, -1, sizeof(int) * ::n); add_flow(s, b + n, 2); add_flow(a + n, t, 1); add_flow(c + n, t, 1); for(int i=1; i\u0026lt;=n; i++) add_flow(i, i + n, 1); while(m--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add_flow(x + n, y, 1); add_flow(y + n, x, 1); } int mf = 0; while(bfs()) mf += dfs(s, 2); puts(mf == 2? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } 解法2：圆方树\r注意到以下算法的正确性：\n找到 $A\\to C$ 的任意简单路径。对于经过的每一个点双连通分量，如果 $B$ 在此点双内，则必然存在 $A\\to B\\to C$ 的简单路径；如果 $B$ 不属于任一经过的点双，则不可能存在 $A\\to B\\to C$ 的简单路径。 因此，可以使用 $\\text{Tarjan}$ 算法构造原图的圆方树 $T$ 来解决此问题。将上述算法转换到圆方树上如下：\n在 $T$ 上找到 $A\\to C$ 的唯一简单路径。对于经过的每一个方点，如果 $B$ 是与其相邻的圆点，则必然存在 $A\\to B\\to C$ 的简单路径；如果 $B$ 不与任一经过的方点相邻，则不可能存在 $A\\to B\\to C$ 的简单路径。 总时间复杂度为 $\\mathcal O(N+M)$，实际运行时间优于网络流解法。\n代码实现\r小贴士：圆方树相关的数组要开到两倍大小，不然会 RE 哦~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 200005 using namespace std; inline void setmin(int\u0026amp; x, int y) { if(y \u0026lt; x) x = y; } vector\u0026lt;int\u0026gt; G[maxn], T[maxn \u0026lt;\u0026lt; 1]; inline void add_edge(vector\u0026lt;int\u0026gt;* G, int x, int y) { G[x].push_back(y); G[y].push_back(x); } int dfc, dfn[maxn], low[maxn], top, st[maxn], cnt; void tarjan(int v) { low[v] = dfn[v] = ++dfc; st[++top] = v; for(int u: G[v]) if(!dfn[u]) { tarjan(u); setmin(low[v], low[u]); if(low[u] == dfn[v]) { add_edge(T, v, ++cnt); do add_edge(T, st[top], cnt); while(st[top--] != u); } } else setmin(low[v], dfn[u]); } int n, m, a, b, c, ct[maxn \u0026lt;\u0026lt; 1]; void dfs(int v, int par) { if(v \u0026gt; n) for(int u: T[v]) ct[u] ++; if(v == c) { puts(ct[b]? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); exit(0); } for(int u: T[v]) if(u != par) dfs(u, v); if(v \u0026gt; n) for(int u: T[v]) ct[u] --; } int main() { scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;a, \u0026amp;b, \u0026amp;c); while(m--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add_edge(G, x, y); } cnt = n; tarjan(1); dfs(a, -1); return 0; } 总结\r三种解法的对比参见下表：\n解法 代码长度 运行时间 内存占用 最大流（AC Library）1 $523~\\mathrm{B}$ $337~\\mathrm{ms}$ $106480~\\mathrm{KB}$ 最大流（Dinic）2 $1650~\\mathrm{B}$ $334~\\mathrm{ms}$ $46980~\\mathrm{KB}$ 圆方树3 $1142~\\mathrm{B}$ $162~\\mathrm{ms}$ $57824~\\mathrm{KB}$ 可见，圆方树算法的运行速度最快，最大流（AC Library）的代码最短，最大流（Dinic）的内存占用最小。\n个人评价\n这道题出得很好，题意简单而内涵丰富。\n我赛时甚至没想到还可以网络流\nhttps://atcoder.jp/contests/abc318/submissions/45209577\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://atcoder.jp/contests/abc318/submissions/45212257\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://atcoder.jp/contests/abc318/submissions/45210151\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-03T13:28:00+08:00","permalink":"https://goodcoder666.github.io/p/abc318/","title":"AtCoder Beginner Contest 318 G - Typical Path Problem 题解"},{"content":"好久没写题解了，这就来水一篇。\nA - Job Interview\r题目大意\r给定一个长为 $N$ 的字符串 $S$，由 o、-、x 组成。\n判断 $S$ 是否符合下列条件：\n$S$ 中至少有一个 o。 $S$ 中没有 x。 $1\\le N\\le 100$\n分析\r签到题。直接按题意模拟即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { while(getchar() != \u0026#39;\\n\u0026#39;); char c; bool ok = false; while((c = getchar()) != \u0026#39;\\n\u0026#39;) { if(c == \u0026#39;x\u0026#39;) { puts(\u0026#34;No\u0026#34;); return 0; } if(c == \u0026#39;o\u0026#39;) ok = true; } puts(ok? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } Python 水题大法 速通大法\n1 2 3 input() s = input() print(\u0026#39;Yes\u0026#39; if \u0026#39;o\u0026#39; in s and \u0026#39;x\u0026#39; not in s else \u0026#39;No\u0026#39;) 成功省掉$208$个字符（逃\nB - Coloring Matrix\r题目大意\r给定两个 $N\\times N$ 的矩阵 $A$ 和 $B$，都由 $0$ 和 $1$ 组成。\n你可以将 $A$ 顺时针旋转 $0\\degree,90\\degree,180\\degree$ 或 $270\\degree$（任选其一）。\n判断旋转后的 $A$ 能否满足：\n对于每个 $A_{i,j}=1$ 的 $(i,j)$，$B_{i,j}=1$。 $1\\le N\\le 100$\n分析\r原题中还贴心的给出了如何将一个矩阵旋转$90\\degree$，照题意模拟，旋转$4$次并逐个判断即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; #define maxn 105 using namespace std; int a[maxn][maxn], b[maxn][maxn], c[maxn][maxn]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;n; j++) scanf(\u0026#34;%d\u0026#34;, a[i] + j); for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;n; j++) scanf(\u0026#34;%d\u0026#34;, b[i] + j); for(int x=0; x\u0026lt;4; x++) { for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;n; j++) c[i][j] = a[i][j]; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;n; j++) a[i][j] = c[n - 1 - j][i]; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;n; j++) if(a[i][j] \u0026amp;\u0026amp; !b[i][j]) goto bad; // goto 不是好习惯（改不掉了），千万不要学 puts(\u0026#34;Yes\u0026#34;); return 0; bad:; } puts(\u0026#34;No\u0026#34;); return 0; } C - Cards Query Problem\r题目大意\r有 $N$ 个盒子，编号 $1\\sim N$，初始均为空。依次处理 $Q$ 次询问：\n1 i j：将数字 $i$ 写在一张空卡牌上，放入盒子 $j$。 2 i：按升序输出盒子 $i$ 中的所有卡牌（允许重复）。 3 i：按升序输出包含卡牌 $i$ 的所有盒子的编号。若一个盒子里有多张卡牌 $i$，则这个盒子的编号仅输出一次。 $1\\le N,Q\\le 2\\times 10^5$\n对于查询中所有卡牌上的数字 $x$，均有 $1\\le x\\le 2\\times 10^5$。\n对于查询中所有的盒子编号 $y$，均有 $1\\le y\\le N$。\n题目保证输出不超过 $2\\times 10^5$ 个整数。\n分析\r我们分别考虑两种输出操作的做法。\n2 i：很容易想到，既然要按升序输出，并且允许重复，我们可以使用 $N$ 个 multiset 来依次存储每个盒子中的卡牌，处理操作 $1$ 时更新。 3 i：首先不能从 $N$ 个盒子中依次查找，这样明显会 TLE。正确的做法是，使用 $2\\times 10^5$ 个 set（注意不能重复，所以不用 multiset）分别存储每张卡牌所在的箱子编号，处理操作 $1$ 时更新。 此外，本题也可以使用 priority_queue、map，甚至直接输出时排序并去重，不过使用 set 的方式是最简单、代码量最少的。几种方法的总时间复杂度都是 $\\mathcal O(Q\\log N)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 200005 using namespace std; multiset\u0026lt;int\u0026gt; box[maxn]; set\u0026lt;int\u0026gt; has[maxn]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); while(q--) { int op, i; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;op, \u0026amp;i); if(op == 1) { int j; scanf(\u0026#34;%d\u0026#34;, \u0026amp;j); box[j].insert(i); has[i].insert(j); } else if(op == 2) { for(int x: box[i]) printf(\u0026#34;%d \u0026#34;, x); putchar(\u0026#39;\\n\u0026#39;); } else if(op == 3) { for(int x: has[i]) printf(\u0026#34;%d \u0026#34;, x); putchar(\u0026#39;\\n\u0026#39;); } } return 0; } D - Writing a Numeral\r题目大意\r我们有一个字符串 $S$。初始时，$S=$ 1。\n处理如下 $Q$ 次询问：\n1 x：将数字 $x$ 追加至 $S$ 的最后面。保证 $x \\in \\{1,2,3,4,5,6,7,8,9\\}$。 2：删除 $S$ 的第一个字符。保证此时 $|S| \u003e 1$。 3：输出 $S$ 在十进制中对应的数字，对 $998244353$ 取模。 $1\\le Q\\le 6\\times 10^5$\n分析\r首先，我们必须使用一个 queue 或 deque 来存储字符串 $S$。然后，为了在 $\\mathcal O(1)$ 的时间内处理第三种操作，我们必须维护 $S \\bmod (P=998244353)$ 的值，记为 $A$。下面考虑前两种操作对 $A$ 的影响：\n1 x：只需在十进制中腾出一位 $0$ 再加上 $x$ 即可，可表示为 $A \\leftarrow (10A+x)\\bmod P$。 2：先从队列中取出 $S$ 的第一位，记为 $x$。我们需要从 $A$ 中减掉最高位乘上其在十进制中的权值，即 $A \\leftarrow (A-10^{|S|}x)\\bmod P$（此时 $|S|$ 表示队列取出前一位后的长度，等同于取出前的 $|S|-1$） 对于 $10^n$ 的计算，我们可以用一个变量实时维护 $10^{|S|}\\bmod P$ 的值，也可以预处理出所有 $10^n \\bmod P$，或者直接使用快速幂。\n总时间复杂度为 $\\mathcal O(Q\\log Q)$（快速幂）或 $\\mathcal O(Q)$（预处理）。\n代码\r实现 $1$：使用 AtCoder Library + 快速幂，队列使用 deque\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;atcoder/modint\u0026gt; using namespace std; using modint = atcoder::modint998244353; int main() { deque\u0026lt;int\u0026gt; s; s.push_back(1); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); modint ans = 1; while(q--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if(op == 1) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); s.push_back(x); ans = ans * 10 + x; } else if(op == 2) { int x = s.front(); s.pop_front(); ans -= x * modint(10).pow((int)s.size()); } else printf(\u0026#34;%d\\n\u0026#34;, ans.val()); } return 0; } 实现 $2$：用变量维护 $10^{|S|} \\bmod P$ 的值，队列使用 queue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define MOD 998244353 using namespace std; int main() { int Q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;Q); queue\u0026lt;int\u0026gt; q; q.push(1); int ans = 1, p = 1; while(Q--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if(op == 1) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); q.push(x); ans = (ans * 10LL + x) % MOD; p = p * 10LL % MOD; } else if(op == 2) { ans -= (long long) q.front() * p % MOD; q.pop(); p = p * 299473306LL % MOD; // 299473306 是 10 对于 MOD 的逆元，这句话相当于把 p 除以 10 if(ans \u0026lt; 0) ans += MOD; } else printf(\u0026#34;%d\\n\u0026#34;, ans); } return 0; } E - Unfair Sugoroku\r题目大意\rTakahashi 和 Aoki 将玩一个游戏。游戏规则如下：\n游戏棋盘有 $N$ 个点（编号 $1\\sim N$），两玩家轮流投骰子并前进。 Takahashi 初始在点 $A$，Aoki 初始在点 $B$。 Takahashi 的骰子等概率出现 $1,2,\\dots,P$，Aoki 的骰子等概率出现 $1,2,\\dots,Q$。 当一个玩家当前在点 $x$ 且骰子出现 $i$ 时，他移动到点 $\\min(x+i,N)$。 先到达点 $N$ 的玩家胜利。 假定 Takahashi 先行，求他赢的概率，对 $998244353$ 取模。\n$2\\le N\\le 100$\n$1\\le A,B\\le N$\n$1\\le P,Q\\le 10$\n分析\r自己的赛时解法太复杂了，这里介绍官方题解的做法。\n考虑概率 DP（下面用 Ta 表示 Takahashi，Ao 表示 Aoki）：\n令 $f_{i,j}$ 表示 Ta 在点 $i$，Ao 在点 $j$，下一轮 Ta 移动时 Ta 获胜的概率。 令 $g_{i,j}$ 表示 Ta 在点 $i$，Ao 在点 $j$，下一轮 Ao 移动时 Ta 获胜的概率。 首先考虑初始状态。根据游戏规则，对于任意 $1\\le i \u003c n$，$f_{n,i}=g_{n,i}=1,f_{i,n}=g_{i,n}=0$。\n转移也很显然：\n对于 Ta 当前走的每种可能的步数 $k=1,2,\\dots,P$，有 $f_{i,j}:=f_{i,j}+\\frac1Pg_{\\min(i+k,N),j}$。 对于 Ao 当前走的每种可能的步数 $k=1,2,\\dots,Q$，有 $g_{i,j}:=g_{i,j}+\\frac1Qf_{i,\\min(j+k,N)}$。 $$\rf_{i,j}=\\begin{cases}\r0 \u0026 (j=N)\\\\\r1 \u0026 (i=N)\\\\\r\\frac1P\\sum\\limits_{k=1}^Pg_{\\min(i+k,N),j} \u0026 (i,j\\ne N)\r\\end{cases}\\\\\r~\\\\\rg_{i,j}=\\begin{cases}\r0 \u0026 (j=N)\\\\\r1 \u0026 (i=N)\\\\\r\\frac1Q\\sum\\limits_{k=1}^Qf_{i,\\min(j+k,N)} \u0026 (i,j\\ne N)\r\\end{cases}\\\\\r$$\n这里注意，由于 $i=j=N$ 的情况无意义（不可能达到），所以无需特殊考虑。\n最终输出结果即为 $f_{p,q}$。总时间复杂度为 $\\mathcal O(N^2(P+Q))$。使用前缀和可以优化到 $\\mathcal O(N^2)$，有兴趣的可以自己尝试，这里不详细解释了。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define MOD 998244353 #define maxn 105 using namespace std; using LL = long long; inline LL inv(LL x) // x ^ (MOD - 2) % MOD { int y = MOD - 2; LL res = 1LL; while(y) { if(y \u0026amp; 1) (res *= x) %= MOD; (x *= x) %= MOD, y \u0026gt;\u0026gt;= 1; } return res; } inline void add(int\u0026amp; x, int y) { if((x += y) \u0026gt;= MOD) x -= MOD; } int f[maxn][maxn], g[maxn][maxn]; int main() { int n, a, b, p, q; scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;a, \u0026amp;b, \u0026amp;p, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) f[n][i] = g[n][i] = 1, f[i][n] = g[i][n] = 0; LL prob_p = inv(p), prob_q = inv(q); for(int i=n-1; i\u0026gt;=a; i--) for(int j=n-1; j\u0026gt;=b; j--) { for(int k=1; k\u0026lt;=p; k++) add(f[i][j], g[min(i + k, n)][j]); f[i][j] = f[i][j] * prob_p % MOD; for(int k=1; k\u0026lt;=q; k++) add(g[i][j], f[i][min(j + k, n)]); g[i][j] = g[i][j] * prob_q % MOD; } printf(\u0026#34;%d\\n\u0026#34;, f[a][b]); return 0; } F - Rook Score\r题目大意\r有一个 $10^9\\times 10^9$ 的网格。令 $(i,j)$ 表示第 $i$ 行 $j$ 列的格子（$1\\le i,j\\le 10^9$）。\n对于 $i=1,2,\\dots,N$，整数 $x_i$ 被写在 $(r_i,c_i)$ 上。在剩余的 $10^{18}-N$ 个格子里只有数字 $0$。\n你可以选择一个格子 $(R,C)$ 并计算与其同行或同列的 $2\\times 10^9-1$ 个整数之和 $S$。\n求最大可能的 $S$。\n$1\\le N\\le 2\\times 10^5$\n$1\\le r_i,c_i,x_i\\le 10^9$\n$(r_i,c_i)\\ne (r_j,c_j)~~~~~~(i\\ne j)$\n分析\r我们令 $f(R,C)$ 表示对于 $(R,C)$ 的 $S$，令 $\\mathrm{rs}_R$ 表示第 $R$ 行的整数之和，$\\mathrm{cs}_C$表示第 $C$ 列的整数之和，$A_{R,C}$ 表示 $(R,C)$ 上的整数。\n容易发现，$f(R,C)=\\mathrm{rs}_R+\\mathrm{cs}_C-A_{R,C}$。\n然后证明当 $f(R,C)$ 最大时，$\\mathrm{rs}_R,\\mathrm{cs}_C\\ne0$：\n若 $\\mathrm{rs}_R=\\mathrm{cs}_C=0$，则 $f(r_0,c_0)=x_0 \u003e 0=f(R,C)$，所以 $(R,C)$ 不是最优解； 若 $\\mathrm{rs}_R\\ne0,\\mathrm{cs}_C=0$，则 $f(R,c_0)=\\mathrm{rs}_R+\\mathrm{cs}_{c_0}-A_{R,c_0}\\ge f(R,C)=\\mathrm{rs}_R$，所以 $(R,C)$ 不是最优解（或有多个最优解，但其中至少有一个解 $(x,y)$ 使得 $\\mathrm{rs}_x,\\mathrm{cs}_y\\ne0$） $\\mathrm{rs}_R=0,\\mathrm{cs}_C\\ne0$ 同理。 所以，我们可以依次考虑每一行 $R$（$\\mathrm{rs}_R\\ne 0$），相当于固定了 $\\mathrm{rs}_R$。这时，我们只需找到一列 $C$（$\\mathrm{cs}_C\\ne 0$），使得 $\\mathrm{cs}_C-A_{R,C}$ 最大，就可以解决此问题。\n但如果依次考虑所有包含点的列，则最坏情况下时间复杂度为 $\\mathcal O(N^2)$，无法通过此题。这时，我们可以使用一个 multiset 或 map 来维护当前每列对答案的贡献（$\\mathrm{cs}_C-A_{R,C}$）。对于每一行 $R$，仅需更新这一行上有非 $0$ 数字的点 $(R,C)$ 的贡献（减去 $A_{R,C}$）即可。\n这样，由于每个点会被更新正好一次，所以总时间复杂度为 $\\mathcal O(N\\log N)$。\n代码\r注意更新完成，求得当前答案后需要复原 map 或 multiset。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; using LL = long long; using pii = pair\u0026lt;int, int\u0026gt;; unordered_map\u0026lt;int, vector\u0026lt;pii\u0026gt;\u0026gt; rows; unordered_map\u0026lt;int, LL\u0026gt; col_sum; template \u0026lt;typename T\u0026gt; class MaxSet { private: multiset\u0026lt;T\u0026gt; s; public: inline void insert(const T\u0026amp; x) { s.insert(x); } inline void update(const T\u0026amp; old, const T\u0026amp; New) { s.erase(s.find(old)); s.insert(New); } inline T max() { return *s.rbegin(); } }; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while(n--) { int x, y, v; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;v); rows[x].emplace_back(y, v); col_sum[y] += v; } MaxSet\u0026lt;LL\u0026gt; s; for(auto [_, sum]: col_sum) s.insert(sum); LL ans = 0LL; for(auto\u0026amp; [x, v]: rows) { for(auto [y, val]: v) s.update(col_sum[y], col_sum[y] - val); LL cur = s.max(); for(auto [y, val]: v) s.update(col_sum[y] - val, col_sum[y]), cur += val; if(cur \u0026gt; ans) ans = cur; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } G - Strawberry War\r题目大意\r==注意本题时间限制为 $6\\mathrm s$。==\n我们有一块长方形的蛋糕。它可被看作一个 $H\\times W$ 的网格，第 $i$ 行 $j$ 列上有 $s_{i,j}$ 个草莓。\n我们对蛋糕进行 $T$ 次切分，切成 $T+1$ 块。每次切蛋糕可以选择当前的一块，并将其从中间横切或竖切成两块：\n你想把蛋糕切的尽可能均匀。意思是，令 $M$ 表示切分完成后每一块上的草莓数量的最大值，$m$ 表示最小值，求出 $M-m$ 的最小值。\n$1\\le H,W\\le 6$\n$1\\le T\\le HW-1$\n$0\\le s_{i,j}\\le 10^{16}$\n分析\r本题解参考官方题解。\n操作完成后得到的蛋糕一定是蛋糕的子矩形，所以最多只有 $\\binom {H+1}2\\times\\binom {W+1}2=\\frac{H(H+1)W(W+1)}4\\le 441$ 种数字在剩下的块中。令这些可能的数分别为 $a_1,a_2,\\dots,a_X$。可知 $X\\le \\frac{H(H+1)W(W+1)}4\\le 441$。\n根据上面的 $a$，我们只需先确定 $m\\in \\{a_1,a_2,\\dots,a_X\\}$，再找到与其对应的最小 $M$，算出 $M-m$ 的最小值即可。\n定义 $f_{i,j,k,l,m}$ 表示将 $x\\in[i,j),y\\in[k,l)$ 的子矩形切成 $m$ 片时最小可能的每片上草莓数的最大值。\n详见代码。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const long long INF = 1000000000000000000; int main(){ int H, W, T; cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W \u0026gt;\u0026gt; T; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; s(H, vector\u0026lt;long long\u0026gt;(W)); for (int i = 0; i \u0026lt; H; i++){ for (int j = 0; j \u0026lt; W; j++){ cin \u0026gt;\u0026gt; s[i][j]; } } vector\u0026lt;vector\u0026lt;vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026gt;\u0026gt; sum(H, vector\u0026lt;vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026gt;(H + 1, vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;(W, vector\u0026lt;long long\u0026gt;(W + 1, 0)))); vector\u0026lt;long long\u0026gt; x; for (int i = 0; i \u0026lt; H; i++){ for (int j = i + 1; j \u0026lt;= H; j++){ for (int k = 0; k \u0026lt; W; k++){ for (int l = k + 1; l \u0026lt;= W; l++){ for (int m = i; m \u0026lt; j; m++){ for (int n = k; n \u0026lt; l; n++){ sum[i][j][k][l] += s[m][n]; } } x.push_back(sum[i][j][k][l]); } } } } int cnt = x.size(); long long ans = INF; for (int i = 0; i \u0026lt; cnt; i++){ vector\u0026lt;vector\u0026lt;vector\u0026lt;vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; dp(T + 1, vector\u0026lt;vector\u0026lt;vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026gt;\u0026gt;(H, vector\u0026lt;vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026gt;(H + 1, vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;(W, vector\u0026lt;long long\u0026gt;(W + 1, INF))))); for (int j = H - 1; j \u0026gt;= 0; j--){ for (int k = j + 1; k \u0026lt;= H; k++){ for (int l = W - 1; l \u0026gt;= 0; l--){ for (int m = l + 1; m \u0026lt;= W; m++){ if (sum[j][k][l][m] \u0026gt;= x[i]){ dp[0][j][k][l][m] = sum[j][k][l][m]; } for (int n = j + 1; n \u0026lt; k; n++){ for (int o = 0; o \u0026lt; (n - j) * (m - l); o++){ for (int p = 0; p \u0026lt; (k - n) * (m - l) \u0026amp;\u0026amp; o + p \u0026lt; T; p++){ dp[o + p + 1][j][k][l][m] = min(dp[o + p + 1][j][k][l][m], max(dp[o][j][n][l][m], dp[p][n][k][l][m])); } } } for (int n = l + 1; n \u0026lt; m; n++){ for (int o = 0; o \u0026lt; (k - j) * (n - l); o++){ for (int p = 0; p \u0026lt; (k - j) * (m - n) \u0026amp;\u0026amp; o + p \u0026lt; T; p++){ dp[o + p + 1][j][k][l][m] = min(dp[o + p + 1][j][k][l][m], max(dp[o][j][k][l][n], dp[p][j][k][n][m])); } } } } } } } ans = min(ans, dp[T][0][H][0][W] - x[i]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } ","date":"2023-04-19T18:34:00+08:00","permalink":"https://goodcoder666.github.io/p/abc298/","title":"TOYOTA MOTOR CORPORATION Programming Contest 2023#1 (AtCoder Beginner Contest 298) A~G 题解"},{"content":"前言\r最近公共祖先简称 LCA（Lowest Common Ancestor）。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。\n这种算法应用很广泛，可以很容易解决树上最短路等问题。\n为了方便，我们记某点集 $S=\\{v_1,v_2,\\ldots,v_n\\}$ 的最近公共祖先为 $\\text{LCA}(v_1,v_2,\\ldots,v_n)$ 或 $\\text{LCA}(S)$。\n部分内容参考 OI Wiki，文章中所有算法均使用C++实现。\n例题：洛谷 P3379 【模板】最近公共祖先（LCA）\n性质\r$\\text{LCA}(\\{u\\})=u$； $u$ 是 $v$ 的祖先，当且仅当 $\\text{LCA}(u,v)=u$； 如果 $u$ 不为 $v$ 的祖先并且 $v$ 不为 $u$ 的祖先，那么 $u,v$ 分别处于 $\\text{LCA}(u,v)$ 的两棵不同子树中； 前序遍历中，$\\text{LCA}(S)$ 出现在所有 $S$ 中元素之前，后序遍历中 $\\text{LCA}(S)$ 则出现在所有 $S$ 中元素之后； 两点集并的最近公共祖先为两点集分别的最近公共祖先的最近公共祖先，即 $\\text{LCA}(A\\cup B)=\\text{LCA}(\\text{LCA}(A), \\text{LCA}(B))$； 两点的最近公共祖先必定处在树上两点间的最短路上； $d(u,v)=h(u)+h(v)-2h(\\text{LCA}(u,v))$，其中 $d$ 是树上两点间的距离，$h$ 代表某点到树根的距离。 求解算法\r前置知识1：树的邻接表存储\r简单来说，树的邻接表存储就是对于每个结点，存储其能通过一条有向或无向边，直接到达的所有结点。\n传统的存储方式是使用链表（或模拟链表），这样实现比较麻烦，也容易写错。\n此处为了更好的可读性我们使用STL中的可变长度顺序表vector。\n1 2 3 4 #include \u0026lt;vector\u0026gt; // 需要使用STL中的vector #define maxn 100005 // 最大结点个数 std::vector\u0026lt;int\u0026gt; G[maxn]; 此时，若要添加一条无向边$u\\leftrightarrow v$，可使用：\n1 2 G[u].push_back(v); G[v].push_back(u); 若要添加$u\\to v$的有向边：\n1 G[u].push_back(v); 遍历$v$能直接到达的所有结点：\n1 2 for(int u: G[v]) cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; endl; 前置知识2：DFS 遍历 \u0026amp; 结点的深度计算\r对于两种算法，都需要预处理出每个结点的深度。\n一个结点的深度定义为这个结点到树根的距离。\n要预处理出所有结点的深度，很简单：\n运用树形dp的方法，令 $h_u$ 表示结点 $u$ 的深度，逐层向下推进：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 100005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; // 邻接表存储 int depth[maxn]; // 每个结点的深度 void dfs(int v, int par) // dfs(当前结点，父亲结点) { int d = depth[v] + 1; // 子结点的深度=当前结点的深度+1 for(int u: G[v]) if(u != par) // 不加这条判断会无限递归 { depth[u] = d; // dp更新子结点深度 dfs(u, v); // 往下dfs } } int main() { // 构建一张图 // ... // 假定图已存入邻接表G: int root = 0; // 默认树根为0号结点，根据实际情况设置 dfs(root, -1); // 对于根结点，父亲结点为-1即为无父亲结点 return 0; } 朴素算法\r令 $u,v$ 表示两个待求 LCA 的结点。需提前预处理出每个结点的父亲（记结点 $v$ 的父亲为 $f_v$）。\n算法步骤：\n使 $u,v$ 的深度相同：可以让深度大的结点往上走，直到与深度小的结点深度相同。 当 $u\\ne v$时：$u\\gets f_u,v\\gets f_v$。 循环直到 $u=v$，此条件成立后 $u$ 和 $v$ 的值即为我们要求的 LCA。 时间复杂度分析：\n预处理：DFS 遍历整棵树，$\\mathcal O(N)$ 单次查询：最坏 $\\mathcal O(N)$，平均 $\\mathcal O(\\log N)$（随机树的高为 $\\lceil\\log N\\rceil$） 参考代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 500005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; int depth[maxn], par[maxn]; void dfs(int v) { int d = depth[v] + 1; for(int u: G[v]) if(u != par[v]) { par[u] = v, depth[u] = d; dfs(u); } } int lca(int u, int v) { if(depth[u] \u0026lt; depth[v]) swap(u, v); while(depth[u] \u0026gt; depth[v]) u = par[u]; while(u != v) u = par[u], v = par[v]; return u; } int main() { int n, q, root; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;q, \u0026amp;root); for(int i=1; i\u0026lt;n; i++) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[u].push_back(v); G[v].push_back(u); } par[root] = -1, depth[root] = 0; dfs(root); while(q--) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); printf(\u0026#34;%d\\n\u0026#34;, lca(u, v)); } return 0; } 可以发现，程序在最后四个测试点上TLE了：\n这是因为，这四个点是专门针对朴素算法设计的（正好是一个 Subtask），使算法的时间复杂度达到了最坏情况 $\\mathcal O(NQ)$，而 $N,Q\\le 5\\times 10^5$，所以无法通过测试点。当然，朴素算法在随机树上回答 $Q$ 次询问的时间复杂度还是 $\\mathcal O(N+Q\\log N)$，被极端数据卡掉也没办法。\n倍增\r倍增算法是朴素算法的改进算法，也是最经典的 LCA 求法。\n预处理：\n令 $\\text{fa}_{x,i}$ 表示点 $x$ 的第 $2^i$ 个祖先。 dfs 预处理深度信息时，也可以预处理出 $\\text{fa}_{x,i}$： 首先考虑$i$的范围：$2^i\\le d_x$（前面说的，$d_x$ 表示结点 $x$ 的深度），所以有$0\\le i\\le \\lfloor\\log_2 d_x\\rfloor$。 对于 $i=0$，$2^i=2^0=1$，所以直接令 $\\text{fa}_{x,0}=(x\\text{的父亲})$ 即可。 对于 $1\\le i\\le \\lfloor\\log_2 d_x\\rfloor$，$x$ 的第 $2^i$ 个祖先可看作 $x$ 的第 $2^{i-1}$ 个祖先的第 $2^{i-1}$ 个祖先（$2^{i-1}+2^{i-1}=2^i$），即：\n$$\r\\text{fa}_{x,i}=\\text{fa}_{\\text{fa}_{x,i-1},i-1}\r$$ 求解步骤：\n使 $u,v$ 的深度相同：计算出 $u,v$ 两点的深度之差，设其为 $y$。通过将 $y$ 进行二进制拆分，我们将 $y$ 次游标跳转优化为「$y$ 的二进制表示所含 1 的个数」次游标跳转（详见代码）。 特判：如果此时$u=v$，直接返回 $u$ 或 $v$ 作为 LCA 结果。 同时上移$u$和$v$：从 $i=\\lfloor\\log_2 d_u\\rfloor$ 开始循环尝试，一直尝试到 $0$（包括 $0$），如果 $\\text{fa}_{u,i}\\not=\\text{fa}_{v,i}$，则 $u\\gets\\text{fa}_{u,i},v\\gets\\text{fa}_{v,i}$，那么最后的 LCA 为 $\\text{fa}_{u,0}$。 时间复杂度分析：\n预处理：$\\mathcal O(N)$ DFS $\\times~\\mathcal O(\\log N)$ 预处理 $=\\mathcal O(N\\log N)$ 单次查询：平均 $O(\\log N)$，最坏 $O(\\log N)$ 预处理 + $Q$ 次查询：$\\mathcal O(N+Q\\log N)$ 另外倍增算法可以通过交换 fa 数组的两维使较小维放在前面。这样可以减少 cache miss 次数，提高程序效率。\n参考代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; #define maxn 500005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; int fa[maxn][19]; // 2^19=524288 int depth[maxn]; void dfs(int v, int par) { fa[v][0] = par; int d = depth[v] + 1; for(int i=1; (1\u0026lt;\u0026lt;i)\u0026lt;d; i++) fa[v][i] = fa[fa[v][i - 1]][i - 1]; for(int u: G[v]) if(u != par) depth[u] = d, dfs(u, v); } inline int lca(int u, int v) { if(depth[u] \u0026lt; depth[v]) u ^= v ^= u ^= v; int m = depth[u] - depth[v]; for(int i=0; m; i++, m\u0026gt;\u0026gt;=1) if(m \u0026amp; 1) u = fa[u][i]; if(u == v) return u; // 这句不能丢 for(int i=log2(depth[u]); i\u0026gt;=0; i--) if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i]; return fa[u][0]; } int main() { int n, q, root; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;q, \u0026amp;root); for(int i=1; i\u0026lt;n; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G[--x].push_back(--y); G[y].push_back(x); } depth[--root] = 0; dfs(root, -1); while(q--) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); printf(\u0026#34;%d\\n\u0026#34;, lca(--u, --v) + 1); } return 0; } 习题\r题目链接：洛谷 P8805 [蓝桥杯 2022 国 B] 机房 题解：https://best-blogs.blog.luogu.org/solution-p8805 总结\r本文详细讲解了 LCA 问题以及求解 LCA 的两种算法。对比如下：\n算法 预处理时间复杂度 单次查询时间复杂度1 空间复杂度 能否通过例题2？ 朴素算法 $\\mathcal O(N)$ $\\mathcal O(N)$ $\\mathcal O(N)$ \u0026#x274c; 倍增算法 $\\mathcal O(N\\log N)$ $\\mathcal O(\\log N)$ $\\mathcal O(N\\log N)$ \u0026#x2714;\u0026#xfe0f; 创作不易，希望大家能给个三连，感谢支持！\n此时间复杂度按照最坏情况计算。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n例题：洛谷 P3379 【模板】最近公共祖先（LCA）\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-01-06T23:03:00+08:00","permalink":"https://goodcoder666.github.io/p/algonotes-lca/","title":"【算法笔记】最近公共祖先（LCA）问题求解——倍增算法"},{"content":"前言\r好久没更算法笔记专栏了，正好学了新算法来更新……\n这也是本专栏的第一个专题问题，涉及到三种数据结构，如果写得有问题请各位大佬多多指教，谢谢！\n关于 RMQ 问题\rRMQ 的全称是 Range Minimum/Maximum Query，即区间最大/最小值问题。\n本文中，我们的算法以求最大值为例（最小值基本一致）。题面如下：\n给定一个长为$N$的序列$A=(A_1,A_2,\\dots,A_N)$。\n有$Q$个询问，第$i$个询问如下：\n$\\to~$给定$1\\le l_i\\le r_i\\le N$，求区间$[l_i,r_i]$的最大值，即$\\displaystyle\\max_{j=l_i}^{r_i} A_j$。\n下面，我们将从暴力算法开始，逐步讲解 RMQ 问题的常用解法。\n通用的 RMQ 问题（除暴力外所有算法都能通过）：\n洛谷 P1816 忠诚（标准的RMQ，没有任何变动，全篇通用例题） 洛谷 P2880 [USACO07JAN] Balanced Lineup G 洛谷 P2251 质量检测 洛谷 P8818 [CSP-S 2022] 策略游戏（有一定思维难度） 解法\r暴力法\r我们先读取序列$A$，再逐个读取询问，对于每个询问直接遍历$A_l\\dots A_r$，最终输出结果。\n总时间复杂度为$\\mathcal O(\\sum r_i-l_i)=\\mathcal O(NQ)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 using namespace std; int a[maxn]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); while(q--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); l --, r --; int res = a[l]; for(int i=l+1; i\u0026lt;=r; i++) if(a[i] \u0026lt; res) res = a[i]; printf(\u0026#34;%d \u0026#34;, res); } return 0; } 然而，当你提交到洛谷 P1816时……\n肯定还是时间复杂度的锅，算法需要进一步优化。\nSparse Table\rSparse Table（以下称ST表）是用于静态求解 RMQ 问题的数据结构。\n静态求解是指在原始序列不改变的情况下求解问题。或者说，ST表不能直接进行修改操作。\nST表的初始化时间复杂度为$\\mathcal O(N\\log N)$，单次查询时间复杂度为$\\mathcal O(1)$。\n存储结构\r$$\rst[i][j]=\\max\\{A_i,A_{i+1},\\dots,A_{i+2^j-1}\\}\r$$\n也就是说，$st[i][j]$表示从$A_i$开始，$2^j$个元素中的最大值。这运用了倍增的思想。\n下面考虑如何快速初始化整个数组。\n初始化\r$$\rst[i][j]=\\max\\{st[i][j-1],st[i+2^{j-1}][j-1]\\}\r$$\n填表时，先枚举$j$，再枚举$i$。由于整个表共有大约$N\\log N$个状态，而计算一个状态值的时间复杂度为$\\mathcal O(1)$，所以初始化的总时间复杂度为$\\mathcal O(N\\log N)$。\n伪代码如下：\n1 2 3 4 5 6 7 function init() { for i = 1 to N st[i][0] = A[i] for j = 1 to log2(N) for i = 1 to (N + 1 - 2^j) st[i][j] = max(st[i][j - 1], st[i + 2^(j-1)][j - 1]) } C++ 实现：\n1 2 3 4 5 6 7 8 void init() { for(int i=0; i\u0026lt;n; i++) st[i][0] = A[i]; for(int j=1; j\u0026lt;=log2(n); j++) for(int i=0; i+(1\u0026lt;\u0026lt;j)\u0026lt;=n; i++) // 注意必须是\u0026lt;=n，1\u0026lt;\u0026lt;j即为2^j st[i][j] = max(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; j - 1)][j - 1]); } 查询\r对于$[l,r)$区间的 RMQ 查询，根据ST表的原理，我们要找到两个区间$[l,a)$和$[b,r)$，使得它们的并集正好为$[l,r)$。即：$l\\le b\\le a\\le r$。\n为什么是并集?\n$\\to~$因为$\\max(a,a)=a$，所以重复的不影响结果。\n$\\to~$如果出现遗漏，且遗漏的正好为最大/最小值，那会影响最终结果，所以不能遗漏。\n$\\to~$如果检查到了多余的元素，且多余的正好大于原区间的最大值，会使查询结果变大，所以不能有多余。\n综上，必须满足$[l,a)$和$[b,r)$的并集正好为$[l,r)$才能查询。\n要满足上述条件，我们可以让$a$尽可能靠近$r$，让$b$尽可能靠近$l$，来达到这样的效果。\n此时，我们还需要满足并集的条件$l\\le a,b\\le r$，因此我们需要找到最大的$k$，使得$a=l+2^k$，$b=r-2^k$。\n$$\r\\left\\{ \\begin{array}{c} l+2^k\\le r \\\\\rr-2^k\\ge l\r\\end{array} \\right.~~\\to~~ 2^k\\le r-l\\\\\r~\\\\\r\\to~k\\le \\log_2(r-l)\r$$\n又因为$k$必须是整数，所以取$k=\\lfloor\\log_2(r-l)\\rfloor$即可。\n1 2 3 4 5 6 // query(l, r) = max(A[l], ..., A[r - 1]) inline int query(int l, int r) { int k = log2(r - l); return max(st[l][k], st[r - (1 \u0026lt;\u0026lt; k)][k]); } 完整实现\r下面给出用Sparse Table解决例题的完整代码。总时间复杂度为$\\mathcal O(Q+N\\log N)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 100005 using namespace std; int st[maxn][17]; // 2^17=131072 void init(int n) { for(int j=1, t=log2(n); j\u0026lt;=t; j++) for(int i=0; i+(1\u0026lt;\u0026lt;j)\u0026lt;=n; i++) st[i][j] = min(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; j - 1)][j - 1]); } inline int query(int l, int r) { int k = log2(r - l); return min(st[l][k], st[r - (1 \u0026lt;\u0026lt; k)][k]); // 注意此题为min，不是求max } int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, st[i]); // 直接读入到ST表中，节约时间和空间 init(n); while(q--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); // 此处注意因为是左闭右开区间[l,r)，所以只有l需要-1 printf(\u0026#34;%d \u0026#34;, query(--l, r)); } return 0; } 运行时间：$128\\mathrm{ms}$\n使用内存：$6.90\\mathrm{MB}$\n树状数组\r关于树状数组的原理我已经在这篇文章中讲过，这里不再多说了。下面我们考虑如何应用树状数组解决 RMQ 问题。\n原算法\r树状数组可以用lowbit操作实现prefixSum（前缀和）以及update（更新）操作，时间复杂度均为$\\mathcal O(N\\log N)$。不仅是加法，对于任意满足结合律的运算这两种操作都有效。\n我们来简单实现一下支持prefixMax和update操作的树状数组：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #define INF 2147483647 #define lowbit(x) ((x) \u0026amp; -(x)) inline void setmax(int\u0026amp; x, int y) { if(y \u0026gt; x) x = y; } int n, A[N], bit[N]; // max(A[1], ..., A[i]) inline int prefixMax(int i) { int res = -INF; for(; i\u0026gt;0; i-=lowbit(i)) setmax(res, bit[i]); return res; } // A[i] = max(A[i], val) inline void update(int i, int val) { for(; i\u0026lt;=n; i+=lowbit(i)) setmax(bit[i], val); } 若要初始化树状数组，可以利用update操作进行$\\mathcal O(N\\log N)$的初始化：\n1 2 3 4 5 6 7 inline void init() { for(int i=1; i\u0026lt;=n; i++) bit[i] = -INF; // 这一段不要忘！ for(int i=1; i\u0026lt;=n; i++) update(i, A[i]); } 另外，我们也可以用子节点直接更新父节点，达到$\\mathcal O(N)$建树的效果：\n1 2 3 4 5 6 7 8 9 10 inline void init() { for(int i=1; i\u0026lt;=n; i++) bit[i] = A[i]; for(int i=1; i\u0026lt;=n; i++) { int j = i + lowbit(i); if(j \u0026lt;= n) setmax(bit[j], bit[i]); } } 考虑加法时我们计算rangeSum（区间和）的算法：\n1 2 3 4 inline int rangeSum(int l, int r) { return prefixSum(r) - prefixSum(l - 1); } 也就是用$(A_1+A_2+\\dots+A_r)-(A_1+A_2+\\dots+A_{l-1})=A_l+\\dots+A_r$。\n现在回过来考虑 RMQ 的查询，Min/Max运算不可逆，所以很明显不能用这种计算方式。\n下面我们来介绍针对 RMQ 的树状数组设计。\nRMQ 树状数组\r$$\rf(l,r)=\\begin{cases}\r\\max\\{B_r,f(l,t)\\} \u0026 (t\\ge l)\\\\\r\\max\\{A_r,f(l,r-1)\\} \u0026 (t","date":"2023-01-05T22:48:00+08:00","permalink":"https://goodcoder666.github.io/p/algonotes-rmq/","title":"【算法笔记】【专题】RMQ 问题：ST表/树状数组/线段树"},{"content":"吐槽：这比赛名字为啥没有英文版。。。\nA - Batting Average\r题目大意\r给定整数$A,B$，输出$\\frac BA$，保留三位小数。\n$1\\le A\\le 10$\n$0\\le B\\le A$\n分析\r签到题，使用printf或cout格式化输出即可。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;%.3Lf\\n\u0026#34;, (long double)b / a); return 0; } B - Line Sensor\r题目大意\r给定一个$H\\times W$的网格，每个方格内都是.或#。\n求每一列的#的个数，分别输出。\n$1\\le H,W\\le 1000$\n分析\r开一个数组ans[W]，存储每一列的#的个数。输入时统计一下即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #define maxn 1005 using namespace std; char s[maxn]; int ans[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(n--) { scanf(\u0026#34;%s\u0026#34;, s); for(int i=0; i\u0026lt;m; i++) if(s[i] == \u0026#39;#\u0026#39;) ans[i] ++; } for(int i=0; i\u0026lt;m; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); return 0; } C - Ameba\r题目大意\r有一棵由$2N+1$个结点组成的树，根结点是$1$。\n整棵树用一个序列$A=(A_1,A_2,\\dots,A_N)$表示：\n结点$A_i$是$2i$和$2i+1$的父亲。 求每个结点的深度。\n$1\\le N\\le 2\\times 10^5$\n$1\\le A_i\\le 2i-1$\n解法1\r根据题意构造树的邻接表，从根结点$1$开始向下搜索，从而推出每个结点的深度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 200005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn \u0026lt;\u0026lt; 1]; int dep[maxn \u0026lt;\u0026lt; 1]; void dfs(int v, int par) { for(int u: G[v]) if(u != par) { dep[u] = dep[v] + 1; dfs(u, v); } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=1; i\u0026lt;=n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); G[x].push_back(i \u0026lt;\u0026lt; 1); G[x].push_back(i \u0026lt;\u0026lt; 1 | 1); } dep[1] = 0; dfs(1, -1); for(int i=1; i\u0026lt;=(n\u0026lt;\u0026lt;1)+1; i++) printf(\u0026#34;%d\\n\u0026#34;, dep[i]); return 0; } 解法2（最优解）\r我们从解法$1$进一步考虑：由于$1\\le A_i\\le 2i-1$，所以$A_i$一定在$2i$和$2i+1$前被处理，那么直接在输入时计算depth[2*i] = depth[2*i+1] = depth[A[i]] + 1即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 200005 using namespace std; int dep[maxn \u0026lt;\u0026lt; 1]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=1; i\u0026lt;=n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); dep[i \u0026lt;\u0026lt; 1] = dep[i \u0026lt;\u0026lt; 1 | 1] = dep[x] + 1; } for(int i=1; i\u0026lt;=(n\u0026lt;\u0026lt;1)+1; i++) printf(\u0026#34;%d\\n\u0026#34;, dep[i]); return 0; } D - Robot Arms 2\r题目大意\r给定整数$N$和序列$A=(A_1,A_2,\\dots,A_N)$，能否在平面直角坐标系中通过$N$步从$(0,0)$走到$(x,y)$？每一步如下：\n第$1$步：从$(0,0)$走到$(A_1,0)$（向右前进$A_1$格）。 第$i$步（$i \u003e 1$）先左转或右转$90\\degree$，再前进$A_i$格。 $2\\le N\\le 10^3$\n$1\\le A_i\\le 10$\n$-10^4\\le x,y\\le 10^4$\n分析\r先考虑另一个问题：\n在一维坐标系中，从$s$开始进行$N$次位移，第$i$次的操作如下：\n$\\to~$选择左移或者右移$A_i$个长度单位，即坐标加上$A_i$或者减去$A_i$。\n$N$次操作后是否能到达终点$t$？注意：必须为最终到达，中途经过不算数！\n很容易想到使用一个简单的$\\text{DP}$，令$f(i,j)$表示前$i$次操作后是否能达到$j$（$0$或$1$），转移显而易见：$f(i,j)=f(i-1,j-A_i)\\vee f(i-1,j+A_i)$。\n但是这样的时间复杂度很高，高达$\\mathcal O(Nk)$，其中$k$为坐标系大小。\n稍加思考会发现，只有小部分坐标能真正达到，其余都没有必要参与转移，所以使用set进行存储，$S_i$表示前$i$次操作后能到达的坐标集合，利用$S_i=(S_{i-1}+A_i)\\cup(S_{i-1}-A_i)$进行转移即可。\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 inline bool check(vector\u0026lt;int\u0026gt;\u0026amp; v, int start, int target) { set\u0026lt;int\u0026gt; s; s.insert(start); for(int d: v) { set\u0026lt;int\u0026gt; ls = s; s.clear(); for(int x: ls) s.insert(x + d), s.insert(x - d); } return s.count(target); } 然后回到原来的问题，发现由于$x$和$y$两个坐标互不影响，所以把两个坐标轴分别独立出来是没有问题的，可以转换为刚才的子问题：\n对于$x$坐标，起始位置为$A_1$，终点为$x$，移动序列为$A_3,A_5,\\dots$。 对于$y$坐标，起始位置为$0$，终点为$y$，移动序列为$A_2,A_4,\\dots$。 只要两个子问题的条件都满足，那么一定存在一种可行的操作序列来满足原题的要求。\n至此，问题得到解决。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; inline bool check(vector\u0026lt;int\u0026gt;\u0026amp; v, int start, int target) { set\u0026lt;int\u0026gt; s; s.insert(start); for(int d: v) { set\u0026lt;int\u0026gt; ls = s; s.clear(); for(int x: ls) s.insert(x + d), s.insert(x - d); } return s.count(target); } int main() { int n, x, y; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;x, \u0026amp;y); vector\u0026lt;int\u0026gt; a(n); for(int\u0026amp; t: a) scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); vector\u0026lt;int\u0026gt; dx; for(int i=2; i\u0026lt;n; i+=2) dx.push_back(a[i]); if(!check(dx, a[0], x)) { puts(\u0026#34;No\u0026#34;); return 0; } vector\u0026lt;int\u0026gt; dy; for(int i=1; i\u0026lt;n; i+=2) dy.push_back(a[i]); puts(check(dy, 0, y)? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } E - Booster\r题目大意\r在平面直角坐标系中，有$N$个城市和$M$个箱子。城市$i$位于坐标$(X_i,Y_i)$，箱子$i$则在坐标$(P_i,Q_i)$。\nTakahashi现在要从原点$(0,0)$开始访问$N$个城市，中途箱子可去可不去。他初始的速度为$1$，每碰到一个箱子都可以将速度提升至原先的两倍（每个箱子只能加速一次）。\n至少要用多少时间，才能将$N$个城市都访问至少一次？\n分析\r参考AtCoder 官方题解的做法，这里不详细解释。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #define maxn 17 using namespace std; inline double ppow(int x) { return 1.0 / (1 \u0026lt;\u0026lt; __builtin_popcount(x)); } inline void setmin(double\u0026amp; x, double y) { if(y \u0026lt; x) x = y; } double x[maxn], y[maxn], dp[maxn][1 \u0026lt;\u0026lt; maxn]; int main() { // Input int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); m += n; for(int i=0; i\u0026lt;m; i++) scanf(\u0026#34;%lf%lf\u0026#34;, x + i, y + i); int mx = 1 \u0026lt;\u0026lt; m; for(int i=0; i\u0026lt;m; i++) for(int s=0; s\u0026lt;mx; s++) dp[i][s] = 1e18; // DP: Initial state for(int i=0; i\u0026lt;m; i++) dp[i][1 \u0026lt;\u0026lt; i] = hypot(x[i], y[i]); // DP: Transfer for(int s=1; s\u0026lt;mx; s++) { double coef = ppow(s \u0026gt;\u0026gt; n); for(int i=0; i\u0026lt;m; i++) { if(!(s \u0026gt;\u0026gt; i \u0026amp; 1)) continue; for(int j=0; j\u0026lt;m; j++) { if(s \u0026gt;\u0026gt; j \u0026amp; 1) continue; setmin(dp[j][s | (1 \u0026lt;\u0026lt; j)], dp[i][s] + hypot(x[i] - x[j], y[i] - y[j])*coef); } } } // Output double ans = 1e18; for(int i=0, t=1\u0026lt;\u0026lt;n; i\u0026lt;m; i++) for(int s=t-1; s\u0026lt;mx; s+=t) setmin(ans, dp[i][s] + dp[i][1 \u0026lt;\u0026lt; i] * ppow(s \u0026gt;\u0026gt; n)); printf(\u0026#34;%.10f\\n\u0026#34;, ans); return 0; } ","date":"2022-10-24T08:30:00+08:00","permalink":"https://goodcoder666.github.io/p/abc274/","title":"AtCoder Beginner Contest 274 A~E 题解"},{"content":"前言\r突然想到位运算是个好东西，就来水一波文章了……\n注意：我把能想到的有关位运算的所有内容都放进来了，所以篇幅较长，请谅解！若有写的不清楚或者不够详细的地方欢迎在评论区补充，谢谢支持！\n本文中参考代码均使用C++编写。\n废话不多说，下面步入正题。\n基本运算\r有一定基础的可以跳过该部分。\n位运算的简要法则：\n符号 描述 规则 \u0026amp; 按位与 两位都为1才为1，不同为0 | 按位或 两位都为0才为0，不同为1 ^ 异或 相同为0，不同为1 ~ 取反 0变1，1变0 \u0026lt;\u0026lt; 左移 二进制位向左移动，高位去掉，低位补0 \u0026gt;\u0026gt; 右移 二进制位向右移动，低位去掉，高位补0 详细解释：\n取反\r取反（~x）是最简单的位运算操作，只有一个参数$x$。将参数上的每一位对应取反即可。例如：\n~0011 = 1100\n~1011 = 0100\n性质：~(~x) = x\n按位与\r按位与（x \u0026amp; y）有两个参数$x$和$y$。对于$x$和$y$中的每个对应位，参照下表输出到结果的对应位：\n$x$ $y$ x \u0026amp; y $0$ $0$ $0$ $0$ $1$ $0$ $1$ $0$ $0$ $1$ $1$ $1$ 例子：\n0011 \u0026amp; 1100 = 0000\n1010 \u0026amp; 1011 = 1010\n性质：\n交换律：a \u0026amp; b = b \u0026amp; a 结合律：a \u0026amp; b \u0026amp; c = a \u0026amp; (b \u0026amp; c) 自与：a \u0026amp; a = a 与$0$：0 \u0026amp; a1 \u0026amp; a2 \u0026amp; a3 \u0026amp; ... = 0 与$\\infty$（全$1$）：a \u0026amp; inf = a 按位或\r按位与（x | y）有两个参数$x$和$y$。对于$x$和$y$中的每个对应位，参照下表输出到结果的对应位：\n$x$ $y$ x | y $0$ $0$ $0$ $0$ $1$ $1$ $1$ $0$ $1$ $1$ $1$ $1$ 例子：\n1100 | 0011 = 1111\n1010 | 0001 = 1011\n性质：\n交换律：a | b = b | a 结合律：a | b | c = a | (b | c) 自或：a | a = a 或$0$：a | 0 = a 或$\\infty$（全$1$）：a | inf = inf 异或\r异或（$x\\oplus y$或x ^ y）有两个参数$x$和$y$。对于$x$和$y$中的每个对应位，参照下表输出到结果的对应位：\n$x$ $y$ $x\\oplus y$ $0$ $0$ $0$ $0$ $1$ $1$ $1$ $0$ $1$ $1$ $1$ $0$ 举例：\n1000 ^ 1011 = 0011\n0101 ^ 1010 = 1111\n性质：\n交换律：$a\\oplus b=b\\oplus a$ 结合律：$a\\oplus b\\oplus c=a\\oplus(b\\oplus c)$ 自异或：$a\\oplus a=0$ 异或$0$：$a\\oplus 0=a$ 多重异或：$a\\oplus b\\oplus b=a\\oplus (b\\oplus b)=a\\oplus 0=a$ 异或$\\infty$（全$1$）：$a\\oplus \\infty=~$~a 若$a\\oplus b=c$，则$a\\oplus c=b$。 位移\r位移分为左移（\u0026lt;\u0026lt;）和右移（\u0026gt;\u0026gt;）。\na \u0026lt;\u0026lt; b：将$a$末尾添上$b$个$0$的结果。 a \u0026gt;\u0026gt; b：从$a$末尾删掉$b$位的结果。 性质：\n(a \u0026lt;\u0026lt; b) \u0026gt;\u0026gt; b = a a \u0026lt;\u0026lt; b$~=a\\times 2^b$ a \u0026gt;\u0026gt; b$~=\\lfloor\\frac a {2^b}\\rfloor$ 练习题\r判断$2$的整数次幂\r题意：给定整数$N$，判断其是否为$2$的整数次幂。\n洛谷 P1100 高低位交换\r题意：给定一个$32$位整数$x$，在二进制下交换其前$16$位与后$16$位，输出最终的数。\n答案为ans = (x \u0026gt;\u0026gt; 16) | (x \u0026lt;\u0026lt; 16)，这样解释：\n数值 前$16$位 后$16$位 $x$ $A$ $B$ x \u0026gt;\u0026gt; 16 $16$个$0$ $A$ x \u0026lt;\u0026lt; 16 $B$ $16$个$0$ ans $B$ $A$ 注意此处使用$32$位无符号整数进行计算，这样x \u0026lt;\u0026lt; 16会自然溢出，导致前$16$位被丢弃，恰好满足要求。\n参考程序：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { unsigned int x; scanf(\u0026#34;%u\u0026#34;, \u0026amp;x); printf(\u0026#34;%u\\n\u0026#34;, (x \u0026gt;\u0026gt; 16) | (x \u0026lt;\u0026lt; 16)); return 0; } 找出不同的数\r给定一个序列$A=(A_1,A_2,\\dots,A_{2N+1})$，其中有$N$个数各出现$2$次，还有一个数正好出现$1$次。找到这个数。请尽可能优化程序的时间和空间复杂度。\n- 时间$\\mathcal O(N)$或$\\mathcal O(N\\log N)$，空间$\\mathcal O(N)$解法\n简单统计每个数的出现次数，最后找到正好出现$1$次的数。\n- 时间$\\mathcal O(N)$，空间$\\mathcal O(1)$解法\n考虑所有数的异或和$S=A_1\\oplus A_2\\oplus\\dots\\oplus A_{2N+1}$，则$A$中所有出现两次的数抵消为$0$，剩下的即为唯一出现一次的数，所以直接输出$S$即可。\n参考程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); n = (n \u0026lt;\u0026lt; 1) + 1; int ans = 0; while(n--) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); ans ^= x; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } AtCoder Beginner Contest 261 E - Many Operations\r解法：对于$i=1,2,\\dots,N$，记录操作$1,2,\\dots,i$后每一位上的$0$和$1$分别变成什么，可以在$\\mathcal O(N)$的时间内用类似于前缀和的方法完成；最后用位运算快速模拟$N$次连续操作即可，总时间复杂度为$\\mathcal O(N)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // https://atcoder.jp/contests/abc261/submissions/33495431 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { unsigned n, c, zero = 0, one = 0xffffffff; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;c); while(n--) { int t, a; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;t, \u0026amp;a); if(t == 1) one \u0026amp;= a, zero \u0026amp;= a; else if(t == 2) one |= a, zero |= a; else one ^= a, zero ^= a; printf(\u0026#34;%d\\n\u0026#34;, c = (c \u0026amp; one) | (~c \u0026amp; zero)); } return 0; } 扩展概念\u0026amp;运算\rlowbit\rlowbit(x)即为二进制下$x$的最低位，如lowbit(10010) = 10、lowbit(1) = 1。严格来说$0$没有lowbit，部分情况下可视为lowbit(0) = 1。利用lowbit函数可实现树状数组等数据结构。\nlowbit 计算方式\n暴力计算\n简单粗暴的按位直接计算，如下： 1 2 3 4 5 6 7 int lowbit(int x) { int res = 1; while(x \u0026amp;\u0026amp; !(x \u0026amp; 1)) x \u0026gt;\u0026gt;= 1, res \u0026lt;\u0026lt;= 1; return res; } 时间复杂度$\\mathcal O(\\log X)$。缺点：速度慢，代码长，没有体现位运算的优势 x \u0026amp; -x\n巧妙利用lowbit(x) = x \u0026amp; -x。感兴趣的读者可自行尝试证明。\n时间复杂度$\\mathcal O(1)$。相比(1)来说，代码更短，速度更快。 x \u0026amp; (x - 1)\n注意：x \u0026amp; (x - 1)不是lowbit(x)，而是x - lowbit(x)。\n这种方法常用于树状数组中，可提升x - lowbit(x)的计算速度。 popcount\rpopcount(x)定义为$x$在二进制下$1$的个数，如popcount(10101) = 3，popcount(0) = 0。\npopcount 计算方式\n暴力计算检查\n还是最粗暴的算法，通过枚举每一位并检查是否为$1$达到目的，时间复杂度为$\\mathcal O(\\log X)$。 1 2 3 4 5 6 7 8 9 10 int popcount(int x) { int res = 0; while(x) { res += x \u0026amp; 1; x \u0026gt;\u0026gt;= 1; } return res; } lowbit 优化\n时间复杂度还是$\\mathcal O(\\log X)$，不过平均用时会比(1)快2~3倍左右。 1 2 3 4 5 6 int popcount(int x) { int res = 0; for(; x; x\u0026amp;=x-1) res ++; return res; } builtin 函数（最快）\n详见3.1 __builtin_popcount/__builtin_popcountll。 builtin 位运算函数\r注意：后面带ll的传入long long类型，不带ll接受int类型。本部分内容按常用程度递减排序。\n参考：https://blog.csdn.net/zeekliu/article/details/124848210\n__builtin_popcount/__builtin_popcountll\r返回参数在二进制下$1$的个数。\n__builtin_ctz / __buitlin_ctzll\r返回参数在二进制下末尾$0$的个数。\n__buitlin_clz / __buitlin_clzll\r返回参数在二进制下前导$0$的个数。\n__builtin_ffs / __buitlin_ffsll\r返回参数在二进制下最后一个1在第几位（从后往前）。\n注意：一般来说，builtin_ffs(x) = __builtin_ctz(x) + 1。当$x=0$时，builtin_ffs(x) = 0。\n__builtin_parity / __builtin_parityll\r返回参数在二进制下$1$的个数的奇偶性（偶：0，奇：1），即__builtin_parity(x) = __builtin_popcount(x) % 2。\nP.S. 这函数，不知是哪位神仙想出来的……\n位运算的应用\r子集表示法\r对于集合$\\{0,1,\\dots,N-1\\}$，我们使用一个$N$位的二进制整数$S$来表示它的一个子集。从右往左第$i$位表示子集是否包含了$i$。容易发现，对于任意子集$S$，$S\\in [0,2^N-1]$，且对于任意$S\\in [0,2^N-1]$，$S$都是$\\{0,1,\\dots,N-1\\}$的一个有效子集。下面我们来讲这种子集表示的具体操作。\n子集操作\r子集的操作如下（规定$N$为集合元素个数）：\n空集：$0$ 满集：$2^N-1$（$N$个$1$） 集合$S$的元素个数：__builtin_popcount(S)或__builtin_popcountll(S) 集合$S$是否包含$i$：S \u0026gt;\u0026gt; i \u0026amp; 1 将$i$加入$S$（操作前$S$是否包含$i$不影响操作结果）：S |= 1 \u0026lt;\u0026lt; i 将$i$从$S$中删除（操作前$S$必须包含$i$）：S ^= 1 \u0026lt;\u0026lt; i 将$i$从$S$中删除（操作前$S$是否包含$i$不影响操作结果）：S \u0026amp;= ~(1 \u0026lt;\u0026lt; i) $S$和$T$的交集（$S$和$T$都包含的集合）：S \u0026amp; T $S$和$T$的并集（$S$和$T$中有任意一个包含的集合）：S | T $S$和$T$的差集（$S$和$T$中恰好有一个包含的集合）：S ^ T 子集枚举\r讲了这么多，也该到子集的实际应用了吧。下面我们来看子集最初步的应用——子集枚举。\n- 必会：枚举$N$个元素的所有子集\n这个很简单，直接枚举$S\\in [0,2^N-1]$即可。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;cstdio\u0026gt; using namespace std; const int N = 3; int main() { printf(\u0026#34;N = %d\\n\u0026#34;, N); for(int s=0, full=(1\u0026lt;\u0026lt;N)-1; s\u0026lt;=full; s++) { printf(\u0026#34;Subset %d:\u0026#34;, s + 1); for(int i=0; i\u0026lt;N; i++) if(s \u0026gt;\u0026gt; i \u0026amp; 1) printf(\u0026#34; %d\u0026#34;, i); putchar(\u0026#39;\\n\u0026#39;); } return 0; } - 必会：枚举子集的子集\n如果我们想枚举$\\{0,1,\\dots,N-1\\}$的子集的子集，怎么办？这是一个经典套路，常用于状压DP，写法如下：\n1 2 3 4 5 6 for(int S=0; S\u0026lt;(1\u0026lt;\u0026lt;N); S++) // 枚举子集S for(int T=S; T; T=(T-1)\u0026amp;S) // 枚举子集的子集T { // Do something... printf(\u0026#34;%d\\n\u0026#34;, t); } 请注意：这个算法的时间复杂度为$\\mathcal O(3^N)$，不是$\\mathcal O(4^N)$，使用此算法时请准确估算时间复杂度。\n- 扩展：枚举$N$个元素中大小为$K$的子集\n首先很容易想到先枚举所有$\\{0,1,\\dots,N-1\\}$的所有子集，再依次检查大小是否为$K$。代码如下：\n1 2 3 4 5 6 for(int s=0; s\u0026lt;(1\u0026lt;\u0026lt;n); s++) { int cnt = __builtin_popcount(s); if(cnt != K) continue; // Do something... } 这种做法虽然正确，也很易懂，但可惜效率太低，$2^N$次popcount操作浪费了很多时间。我们考虑优化。《挑战程序设计竞赛》上给出了一种算法，如下：\n1 2 3 4 5 6 7 8 9 int S = (1 \u0026lt;\u0026lt; k) - 1; while(S \u0026lt; 1 \u0026lt;\u0026lt; n) { // Do something... printf(\u0026#34;%d\\n\u0026#34;, S); // 移到下一个合法子集 int x = S \u0026amp; -S, y = S + x; S = ((S \u0026amp; ~y) / x \u0026gt;\u0026gt; 1) | y; } 这样可保证每次枚举到的都是大小为$K$的子集，可以大大提高算法效率。\n扩展：std::bitset\rbitset，顾名思义，即为用位运算操作的集合。\n对于元素个数$N\\in [1,64]$，集合$\\{0,1,\\dots,N-1\\}$的任意子集都可以用一个$32$或$64$位整数表示出来，操作时间复杂度为$\\mathcal O(1)$。那么对于$N \u003e 64$，怎么办？我们可以用多个$32$或$64$位无符号整数拼凑为一个$N$位的bitset，容易发现其操作的时间复杂度为$\\mathcal O(\\frac Nw)$（$N$位的二进制数可用$\\lceil\\frac Nw\\rceil$个$w$位无符号整数拼凑而成），其中$w$一般为$32$或$64$。\nC++的Standard Template Library（STL）为我们提供了\u0026lt;bitset\u0026gt;头文件，用于bitset的定义。\n用法如下：\n函数/操作 作用 b.any() b中是否存在至少1位的二进制位？ b.none() b中不存在至少1位的二进制位吗？ b.count() b中值为1的二进制位的个数 b.size() b中二进制位的个数 b[pos] 访问b中pos处的二进制位 b.test(pos) 检测b中pos处的二进制位是否为1 b.set(pos) 把b中pos处的二进制位设置为1 b.set() 把b中的所有二进制位设置为1 b.reset(pos) 把b中pos处的二进制位设置为0 b.reset() 把b中的所有二进制位设置为0 b.flip() 把b中的所有二进制位按位取反 b.flip(pos) 把b中pos处的二进制位按位取反 b.to_ulong() 用b中所有的二进制位返回unsigned long值 os \u0026lt;\u0026lt; b 把b的值输出到流os中 用法示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;bitset\u0026gt; // 头文件 using namespace std; int main() { const int N = 500; bitset\u0026lt;N\u0026gt; S; // 定义大小为N的bitset S，初始为全0 S.set(1); // 将S的第1位设为1 S[0] = 1; // 将S的第0位设为1，注意bitset可使用下标访问和赋值 S.reset(1); // 将S的第1位设为0 printf(\u0026#34;S[1]: %d\\n\u0026#34;, (int)S[1]); // 输出S第2位上的值 printf(\u0026#34;Count: %d\\n\u0026#34;, (int)S.count()); // S的popcount（二进制下1的个数） printf(\u0026#34;Size: %d\\n\u0026#34;, (int)S.size()); // S的二进制位数（N） printf(\u0026#34;None? %d\\n\u0026#34;, (int)S.none()); // S是否为空？ printf(\u0026#34;Any? %d\\n\u0026#34;, (int)S.any()); // S是否有1？ bitset\u0026lt;N\u0026gt; T; // 定义一个新的bitset -- T T.set(); // T置为全1 S.set(2), T.reset(2); printf(\u0026#34;Intersection: %d\\n\u0026#34;, (int)(S \u0026amp; T).count()); // 交集 printf(\u0026#34;Union: %d\\n\u0026#34;, (int)(S | T).count()); // 并集 printf(\u0026#34;Difference: %d\\n\u0026#34;, (int)(S ^ T).count()); // 差集 return 0; } 习题：AtCoder Beginner Contest 258 G - Triangle\r题意和解法见我的题解。\n深度优先搜索（DFS）的位运算优化\r本算法其实还是二进制表示子集的一种优化，不过内容较多，所以单独放了出来。\n考虑经典的八皇后问题：\n有一个$8\\times 8$的国际象棋棋盘，要在其中摆$8$个皇后，求有多少种不同的摆法，使得任意两个皇后之间都没有互相攻击。\n注：皇后的攻击范围是一个“米”字，如下图所示：\n八皇后问题很容易求解，用一个简单的回溯就可以了。\n考虑$N$皇后问题，即：\n有一个$N\\times N$的国际象棋棋盘，要在其中摆$N$个皇后，求有多少种不同的摆法，使得任意两个皇后之间都没有互相攻击。\n此时，还是先用标准的「回溯」算法解决问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;cstdio\u0026gt; #define maxn 20 using namespace std; bool row[maxn], diag_left[maxn \u0026lt;\u0026lt; 1], diag_right[maxn \u0026lt;\u0026lt; 1]; int ans, n; void dfs(int i) { if(i == n) { ans ++; return; } for(int j=0; j\u0026lt;n; j++) if(!row[j] \u0026amp;\u0026amp; !diag_left[i + j] \u0026amp;\u0026amp; !diag_right[i - j + n]) { row[j] = diag_left[i + j] = diag_right[i - j + n] = true; dfs(i + 1); row[j] = diag_left[i + j] = diag_right[i - j + n] = false; } } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); ans = 0; dfs(0); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 代码很移动，也不是重点，这里就不详细解释了。对于$N=13$，搜索时间约为$243\\mathrm{ms}$；$N=14$，$1.31\\mathrm s$；$N=15$，$8.14\\mathrm s$；$N=16$…… $53.4\\mathrm s$。\n明显，这样的算法效率太低，我们来考虑使用位运算优化。\n首先，我们把上面程序里的row、diag_left和diag_right换成一个int整数，赋值、取值全部改用位运算。但这样对整体的时间优化还是不大，我们要充分发挥位运算的优势——“百发百中”，即利用lowbit算法，确保每次枚举到的都是目前一步可放置的位置，减少不必要的判断。此时，我们改变diag_left和diag_right的含义，使diag_left表示左下-右上的$45\\degree$对角线上当前一步可放置的皇后位置集合，diag_right同理。见代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;cstdio\u0026gt; using namespace std; int ans, mx; void dfs(int row, int diag_left, int diag_right) { if(row == mx) { ans ++; return; } int a = mx \u0026amp; ~(row | diag_left | diag_right); while(a) { int p = a \u0026amp; -a; a ^= p; dfs(row | p, (diag_left | p) \u0026gt;\u0026gt; 1, (diag_right | p) \u0026lt;\u0026lt; 1); } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); ans = 0; mx = (1 \u0026lt;\u0026lt; n) - 1; dfs(0, 0, 0); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 此时，计算$16$皇后只需$6.23\\mathrm s$！\n习题：洛谷 P1092 [NOIP2004 提高组] 虫食算\n附：N皇后问题的两种解法耗时对比\r本测试中，两种算法耗时均为在Intel i7-12700H CPU上$5$次程序运行的最快速度。\n$N$ 无优化 位运算优化 速度提升 $13$ $253\\mathrm{ms}$ $66\\mathrm{ms}$ $2.83\\text x$ $14$ $1.31\\mathrm s$ $179\\mathrm{ms}$ $6.32\\text x$ $15$ $8.14\\mathrm s$ $955\\mathrm{ms}$ $7.52\\text x$ $16$ $53.4\\mathrm s$ $6.23\\mathrm s$ $7.57\\text x$ 其他应用\r两数交换\r1 2 3 4 void swap(int\u0026amp; a, int\u0026amp; b) { a ^= b ^= a ^= b; } 位运算交换法扩展：超快GCD\n1 2 3 4 5 inline int gcd(int a, int b) { if(b) while(b ^= a ^= b ^= a %= b); return a; } 两数平均数（防溢出）\r1 2 3 4 5 6 7 8 9 inline int average1(int x, int y) { return (x \u0026gt;\u0026gt; 1) + (y \u0026gt;\u0026gt; 1) + (x \u0026amp; y \u0026amp; 1); } inline int average2(int x, int y) { return (x \u0026amp; y) + ((x ^ y) \u0026gt;\u0026gt; 1); } 判断一个数是否为$2$的整数次幂\r1 2 3 4 inline bool ispowof2(int x) { return x \u0026gt; 0 \u0026amp;\u0026amp; !(x \u0026amp; x - 1); } 总结\r本文详细讲解了位运算的使用和扩展。\n创作不易，各位如果觉得好的话就请给个三连，感谢大家的支持！\n","date":"2022-10-18T08:30:00+08:00","permalink":"https://goodcoder666.github.io/p/algonotes-bwop/","title":"【算法笔记】位运算详解"},{"content":"前言\r树状数组，即树形存储的数组，又称Binary Indexed Tree或Fenwick Tree。\n抛开它树形的存储结构，这种神奇的数据结构的应用看起来与「 树」没什么关系：\n有一个序列$A=(A_1,A_2,\\dots,A_N)$，在不超过$\\mathcal O(\\log N)$的时间复杂度内完成下列操作：\n$\\to~$求$[L,R]$区间内所有数之和。\n$\\to~$指定一个元素$A_x$，将其加上$k$。\n如果想要使求和操作尽可能快，很容易想到前缀和，这样求和操作只要$\\mathcal O(1)$的时间，但更新操作的时间复杂度就升至$\\mathcal O(N)$，无法满足题目要求；反之，若直接暴力维护$A$中所有元素的值，则虽然更新操作只需要$\\mathcal O(1)$，但求和操作的时间又变成了$\\mathcal O(N)$，还是满足不了要求。那有没有一种算法，综合了两种方式的优势，达到题目时间要求呢？\n肯定有，那就是今天说的——树状数组。\n基本算法\r洛谷 P3374【模板】树状数组 1\n同“前言”中的部分，$1\\le n,m\\le 10^5$，其中$m$为操作总次数。\n由于$n,m\\le 10^5$，所以$\\mathcal O(nm)$的暴力解法肯定行不通，需要使用$\\mathcal O(M\\log N)$的树状数组。其存储结构大致上是这样的：\n是不是已经有些明白了？这里我们我们把$B$当作树状数组的内部存储，则据图可知：\n$B_1=A_1$ $B_2=A_1+A_2$ $B_3=A_3$ $B_4=A_1+A_2+A_3+A_4$ $B_5=A_5$ $B_6=A_5+A_6$ $B_7=A_7$ $B_8=A_1+A_2+A_3+A_4+A_5+A_6+A_7+A_8$ .. 可以看出，$B_i=A_{i-2^k+1}+A_{i-2^k+2}+\\dots+A_i$，其中$k$为$i$在二进制下末尾$0$的的个数。换句话说，$2^k$就是$i$在二进制中的的lowbit。\n关于lowbit函数\n$\\to~$lowbit的定义：\n$\\mathrm{lowbit}(0)$ 无意义。 对于任意$x \u003e 0$，$\\mathrm{lowbit}(x)=2^k$，其中$k$为$x$在二进制下末尾$0$的的个数。 $\\to~$举例：$\\mathrm{lowbit}(10010)=10$；$\\mathrm{lowbit}(10000)=10000$\n$\\to~$C/C++实现：\n1 2 3 inline int lowbit(int x) { return x \u0026amp; -x; } 或宏定义形式：\n1 #define lowbit(x) (x) \u0026amp; -(x) $$\rl:=i-\\mathrm{lowbit}(i)+1\\\\\rr:=i\\\\\rB_i=\\sum_{j=l}^{r} A_j\r$$按照这样，就可以在$\\mathcal O(\\log n)$的时间复杂度内求$[0,x]$中整数之和（prefixSum(x)）或将$A_x$加上$k$（update(x, k)）。\n对于$[L,R]$的区间之和，可以按照segmentSum(l, r) = prefixSum(r) - prefixSum(l - 1)的方式进行计算。详见代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;cstdio\u0026gt; using namespace std; template \u0026lt;typename value_type\u0026gt; class fenwick_tree { private: const int n; value_type* a; inline int lowbit(int x) { return x \u0026amp; -x; } public: inline fenwick_tree(int m): n(m) { a = new value_type[n + 1]; for(int i=0; i\u0026lt;=n; i++) a[i] = 0; } inline ~fenwick_tree() { delete[] a; } inline value_type prefixSum(int i) { value_type res = 0; for(; i; i-=lowbit(i)) res += a[i]; return res; } inline value_type segmentSum(int l, int r) { return prefixSum(r) - prefixSum(l - 1); } inline void update(int i, const value_type\u0026amp; d) { for(; i\u0026lt;=n; i+=lowbit(i)) a[i] += d; } }; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); fenwick_tree\u0026lt;int\u0026gt; bit(n); for(int i=1; i\u0026lt;=n; i++) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); bit.update(i, a); } while(m--) { int op, x, y; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;op, \u0026amp;x, \u0026amp;y); if(op == 1) bit.update(x, y); else printf(\u0026#34;%d\\n\u0026#34;, bit.segmentSum(x, y)); } return 0; } 在洛谷 P3374上提交耗时仅$572\\mathrm{ms}$，同题用同样为$\\mathcal O(\\log N)$的线段树耗时约$2.5\\mathrm{s}$，可见相比于线段树算法，使用树状数组不仅代码量小、容易实现，还有运行速度快等等优势。\n基础算法到此为止，下面来看一些经典的扩展应用。\n扩展应用\r知识补充：离散化\n对于序列$A=(A_1,A_2,\\dots,A_N)$，我们将$A$中的每个数都按原先的映射到一个$[1,N]$的范围内，这个过程被称为离散化。一般来说，离散化时同样的元素映射到同样的值，不同的元素映射到不同的值，且满足原先的大小关系。换句话说，令原先的序列为$(A_1,\\dots,A_N)$，离散化后的序列为$(B_1,\\dots,B_N)$，则满足如下条件：\n$1\\le B_i\\le N$（$1\\le i\\le N$） 若$i \\ne j$，且$A_i \u003c A_j$，则$B_i \u003c B_j$。 若$i \\ne j$，且$A_i = A_j$，则$B_i = B_j$。 若$i \\ne j$，且$A_i \u003e A_j$，则$B_i \u003e B_j$。 求逆序对\r逆序对问题是经典的序列问题。众所周知，这类问题可以用归并排序在$\\mathcal O(N\\log N)$的时间内解决。不过，既然今天讲的是树状数组，那就不能用归并排序，就主要来说一说树状数组的解法。\n洛谷 P1908 逆序对\n给定一个整数序列$A=(A_1,A_2,\\dots,A_N)$，求其中逆序对的个数。\n一个整数对$(i,j)$被称为“逆序对”，当且仅当如下条件满足：\n$\\to 1\\le i \u003c j\\le N$\n$\\to A_i \u003e A_j$\n数据范围：$N\\le 10^5,A_i\\le 10^9$。\n由于$N\\le 10^5$，所以暴力的$\\mathcal O(N^2)$做法肯定不行。\n我们考虑使用树状数组，先将数组离散化成$[1,N]$之间的数，记离散化后的序列为$B=(B_1,\\dots,B_N)$。我们按$($总数对数量$)-($非逆序对数量$)=($逆序对数量$)$的公式计算，其中总数对的数量为$1+2+\\dots+N-1=\\frac {N(N-1)}2$。用树状数组维护每个数字的出现次数，则非逆序对的数量可以在遍历$B$中的每个元素时动态计算。详见代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 500005 using namespace std; inline int read() { static char c; while((c = getchar()) \u0026lt; \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026gt; \u0026#39;9\u0026#39;); int res = c ^ 48; while((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) res = (res \u0026lt;\u0026lt; 3) + (res \u0026lt;\u0026lt; 1) + (c ^ 48); return res; } template \u0026lt;typename value_type\u0026gt; class fenwick_tree { private: const int n; value_type* a; inline int lowbit(int x) { return x \u0026amp; -x; } public: inline fenwick_tree(int m): n(m) { a = new value_type[n + 1]; for(int i=0; i\u0026lt;=n; i++) a[i] = 0; } inline ~fenwick_tree() { delete[] a; } inline value_type prefixSum(int i) { value_type res = 0; for(++i; i; i-=lowbit(i)) res += a[i]; return res; } inline void update(int i, const value_type\u0026amp; d) { for(++i; i\u0026lt;=n; i+=lowbit(i)) a[i] += d; } }; int a[maxn], rk[maxn]; int main() { int n = read(); for(int i=0; i\u0026lt;n; i++) a[rk[i] = i] = read(); stable_sort(rk, rk + n, [\u0026amp;](int x, int y) -\u0026gt; bool { return a[x] \u0026lt; a[y]; }); // 因为可能会有重复的数字，所以必须使用稳定的stable_sort排序，用sort只有40分 fenwick_tree\u0026lt;int\u0026gt; bit(n); // 初始化树状数组，离散化之后大小为n就行 long long ans = n * (n - 1LL) \u0026gt;\u0026gt; 1LL; // 总数对个数 for(int i=0; i\u0026lt;n; i++) { ans -= bit.prefixSum(rk[i]); // 减去非逆序数对，即prefixSum(b[i]) bit.update(rk[i], 1); // 动态更新当前元素出现次数 } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } 习题：CF1676H2 Maximum Crossings (Hard Version)\n区间更新\r用过线段树的都知道，树状数组最大的缺点就是无法直接实现区间更新。不过，在一些特殊情况1下，我们可以通过差分+离散化来间接实现区间的更新。先来看洛谷上的模板：\nP3368【模板】树状数组 2\n已知一个长为$N$的数列，你需要进行下面两种操作：\n1 x y k：将$[x,y]$区间内的每个数都加上$k$。 2 x：求第$x$个数的值。 运用差分的思想，用树状数组维护$A$的差分数组$B$（$B_i=A_i-A_{i-1}$）。\n此时，我们可以把“区间$[x,y]$中所有元素都加上$k$”看作：\n$B_x:=B_x+k$ $B_{y+1}:=B_{y+1}-k$ 此时，$A_x=B_1+\\dots+B_x$，正好是树状数组的前缀和操作。\n于是，我们在$\\mathcal O(N\\log N)$的时间复杂度内解决了这个问题。\nC++实现如下（此实现方式与前面讲的略有不同）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;cstdio\u0026gt; #define maxn 500005 using namespace std; template \u0026lt;typename value_type\u0026gt; class fenwick_tree { private: const int n; value_type* a; inline int lowbit(int x) { return x \u0026amp; -x; } public: inline fenwick_tree(int m): n(m) { a = new value_type[n + 1]; for(int i=0; i\u0026lt;=n; i++) a[i] = 0; } inline ~fenwick_tree() { delete[] a; } inline value_type prefixSum(int i) { value_type res = 0; for(; i; i-=lowbit(i)) res += a[i]; return res; } inline void update(int i, const value_type\u0026amp; d) { for(; i\u0026lt;=n; i+=lowbit(i)) a[i] += d; } }; int a[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); fenwick_tree\u0026lt;int\u0026gt; bit(n); while(m--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if(op == 1) { int l, r, k; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;k); bit.update(l, k); if(r \u0026lt; n) bit.update(r + 1, -k); } else { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); printf(\u0026#34;%d\\n\u0026#34;, a[x] + bit.prefixSum(x)); } } return 0; } 习题\r洛谷 P1168 中位数（求第$k$大问题） 洛谷 P1637 三元上升子序列 洛谷 P6477 [NOI Online #2 提高组] 子序列问题 洛谷 P8253 [NOI Online 2022 提高组] 如何正确地排序 AtCoder Beginner Contest 256 F - Cumulative Cumulative Cumulative Sum P3372【模板】线段树 1（没错，就是线段树模板，不妨考虑一下「 超级树状数组」？） 总结\r树状数组支持更新、求和两种操作。欢迎大家前来提问或补充~\n求三连qwq\n实际上所有情况都可以，不过其他的非特殊情况实现起来非常繁琐，有时还不如直接用线段树来得方便，因此这里忽略这种情况。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-08-20T20:08:00+08:00","permalink":"https://goodcoder666.github.io/p/algonotes-fenwick-tree/","title":"【算法笔记】树状数组/Binary Indexed Tree/Fenwick Tree"},{"content":"前言\r背包（Knapsack）问题是经典的动态规划问题，也很有实际价值。\n##背包\n洛谷 P2871 [USACO07DEC] Charm Bracelet S\nAtCoder Educational DP Contest D - Knapsack 1\n有$n$个物品和一个总容量为$W$的背包。第$i$件物品的重量是$w_i$，价值是$v_i$。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。\n$$\rf_{i,j}=\\begin{cases}\r0 \u0026 (i=0/j=0) \\\\\r\\max(f_{i-1,j},f_{i-1,j-w_i}+v_i) \u0026 (i\u003e0,j\\ge w_i)\r\\end{cases}\r$$\n依次递增$i$，逐步增加问题规模即可求解。时间、空间复杂度均为$\\mathcal O(nW)$。\n在本题中，$\\mathcal O(nW)$的空间复杂度容易MLE，因此考虑使用数组重复利用或者滚动表的优化。\n$$\rf_j=\\max(f_j,f_{j-w_i}+v_i)\r$$\n此时空间复杂度为$\\mathcal O(W)$。\n一定要牢记这个公式，注意使用时需倒序枚举$j$，防止串连转移。参考代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define setmax(x, y) if(x \u0026lt; y) x = y using namespace std; int f[12881]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(n--) { int w, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;v); for(int i=m; i\u0026gt;=w; i--) setmax(f[i], f[i - w] + v); } printf(\u0026#34;%d\\n\u0026#34;, f[m]); return 0; } 01背包还有一种简单变形，即求最小剩余空间，此时用$($总空间$-$最大可装空间$)$即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define setmax(x, y) if(x \u0026lt; y) x = y using namespace std; int f[20005]; int main() { int n, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;v, \u0026amp;n); while(n--) { int w; scanf(\u0026#34;%d\u0026#34;, \u0026amp;w); for(int i=v; i\u0026gt;=w; i--) setmax(f[i], f[i - w] + w); } printf(\u0026#34;%d\\n\u0026#34;, v - f[v]); return 0; } 扩展：对付更大的$W$\rAtCoder Educational DP Contest E - Knapsack 2\n本题和普通的01背包完全相同，只是数据范围改为$n\\le 100,W\\le 10^9,v_i\\le 10^3$。\n$$\rf_{i,j}=\\begin{cases}\r+\\infin \u0026 (i=0,j\\ne0) \\\\\r0 \u0026 (i\\ge 0,j=0) \\\\ \\min(f_{i-1,j},f_{i-1,j-v_i}+w_i) \u0026 (i\u003e0,j\u003e0)\r\\end{cases}\r$$\n其中，$i=0,j\\ne 0$这种情况不存在，所以初始值为$+\\infin$。最终答案，即为最大的$j$，使得$f_{n,j}\\le W$，更新状态时可同时记录这个答案。\n这种算法的时间和空间都可以优化：\n时间：对于每个$i$，循环迭代$j$时只需到$v_1+v_2+\\dots+v_i$即可，因为当前的总价值不可能超过这个值； 空间：用与前面完全相同的方法，压缩掉第一维空间，变成$f_j=\\min(f_j,f_{j-v_i}+w_i)$（注意要倒序枚举$j$） 运用了两种优化的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; long long f[100005], t, tot, ans; int main() { int n, sz; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;sz); memset(f, 0x3f, sizeof f); f[0] = 0; while(n--) { int w, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;v); tot += v; for(int i=tot; i\u0026gt;=v; i--) if((t = f[i - v] + w) \u0026lt; f[i] \u0026amp;\u0026amp; t \u0026lt;= sz) { f[i] = t; if(i \u0026gt; ans) ans = i; } } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } 完全背包\r洛谷 P1616 疯狂的采药\n有$n$个物品和一个总容量为$W$的背包。第$i$件物品的重量是$w_i$，价值是$v_i$。每个物品可以使用无限次。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。\n$$\r\\begin{aligned}\rf_{i,j}=\\max_{k=0}^{+\\infin}\\{f_{i-1,j-k\\times w_i}\\}+v_i\\times k\\\\\r=\\max_{k=0}^{\\lfloor\\frac j{w_i}\\rfloor}\\{f_{i-1,j-k\\times w_i}\\}+v_i\\times k\r\\end{aligned}\r$$\n可以发现，实际上只需要用$f_{i,j}=\\max(f_{i-1,j},f_{i,j-w_i}+v_i)$即可，因为此时的$f_{i,j-w_i}$会被$f_{i,j-2w_i}$更新，$f_{i,j-2w_i}$又会被$f_{i,j-3w_i}$更新，以此类推，这样算与前面的公式等效。\n$$\r\\begin{aligned}\rf_{i,j}=\\max(f_{i-1,j},f_{i-1,j-w_i}+v_i) \\\\\rf_{i,j}=\\max(f_{i-1,j},f_{i,j-w_i}+v_i)\r\\end{aligned}\r$$\n实际上，区别就在于一个是$f_{i-1,j-w_i}$，一个是$f_{i,j-w_i}$。所以仍可以使用数组压缩，只需要改变一下循环顺序，是不是很神奇？\nlong long别忘了~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define setmax(x, y) if(x \u0026lt; y) x = y using namespace std; long long f[10000005]; int main() { int sz, n; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;sz, \u0026amp;n); while(n--) { int w, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;v); for(int i=w; i\u0026lt;=sz; i++) setmax(f[i], f[i - w] + v); } printf(\u0026#34;%lld\\n\u0026#34;, f[sz]); return 0; } 多重背包\r洛谷 P1776 宝物筛选\n有$n$个物品和一个总容量为$W$的背包。第$i$件物品的重量是$w_i$，价值是$v_i$，最多能选择$m_i$次。我们要选择一些物品，使这些物品的重量总和不超过背包容量，且价值总和最大。$n\\le100,\\sum m_i\\le10^5,W\\le 4\\times10^4$。\n很容易想到，可以转换成每件物品都被拆分成$m_i$个只能选一次的物品，即$N=\\sum m_i$的01背包。很明显，这样做的时间复杂度是$\\mathcal O(W\\sum m_i)$，会TLE。因此，我们可以优化拆分的方法，将$m$转化为$x+\\sum\\limits_{j=0}^i 2^j$的形式，举几个栗子：\n$5=(1+2)+2$，其中$i=1,x=2$； $16=(1+2+4+8)+1$，其中$i=3,x=1$； $31=(1+2+4+8+16)$，其中$i=4,x=0$。 这种方法的正确性这里就不详细说明了，主要依赖于二进制的拼凑。容易发现，数字$m$按这种拆分的方法会被拆分为$\\lceil\\log_2m\\rceil$个数字的和，因此总时间复杂度为$\\mathcal O(W\\sum\\limits_{i=1}^n\\log m_i)$，可以通过此题。\n还有一种单调队列/单调栈优化，同样针对多重背包问题，时间复杂度为$\\mathcal O(nW)$，有时不一定优于二进制优化，这里就不多说了。下面给出二进制优化的参考程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; #define maxw 40004 #define setmax(x, y) if(x \u0026lt; y) x = y using namespace std; int n, w, f[maxw]; inline void add(int a, int b) // a: value, b: weight { for(int i=w; i\u0026gt;=b; i--) setmax(f[i], f[i - b] + a); } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;w); while(n--) { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); for(int i=0; (1\u0026lt;\u0026lt;i)\u0026lt;=c; i++) add(a \u0026lt;\u0026lt; i, b \u0026lt;\u0026lt; i), c -= 1 \u0026lt;\u0026lt; i; if(c) add(a * c, b * c); } printf(\u0026#34;%d\\n\u0026#34;, f[w]); return 0; } 混合背包\r没错，就是前三种放在一起的背包。不用的物品有不同的种类。比如洛谷 P1833 樱花，就是混合背包。不过，也不要慌，直接用个分支判断，比如：\n1 2 3 4 5 6 7 8 for (循环物品种类) { if (是 0 - 1 背包) 套用 0 - 1 背包代码; else if (是完全背包) 套用完全背包代码; else if (是多重背包) 套用多重背包代码; } 实际上也不一定要这样，可以全部统一成混合背包：\n对于01背包，可选数目$k_i=1$。 对于完全背包，可选数目$k_i=\\lceil\\frac W{w_i}\\rceil$。 这里就不给出详细代码，有兴趣的读者可以自己尝试一下。\n总结\r让我们来总结一下三种基本背包DP的异同：\n项目 01背包 完全背包 多重背包 适用场景 每件物品只能选择一次 每件物品可以无限选择 每件物品可以选择的次数有限 状态转移方程1 $\\max(f_j,f_{j-w_i}+v_i)$ $\\max(f_j,f_{j-w_i}+v_i)$ 基本同01背包 时间复杂度2 $\\mathcal O(nW)$ $\\mathcal O(nW)$ $\\mathcal O(W\\sum\\log k_i)$ 空间复杂度3 $\\mathcal O(W)$ $\\mathcal O(W)$ $\\mathcal O(W)$ 编码难度 低 低 中 创作不易，如果觉得好就请给个三连，谢谢支持！\n压缩掉第一维的$f_j$，01背包为倒序枚举$j$，完全背包为正序\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n完全背包为优化后的复杂度，多重背包为二进制优化的复杂度。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n指压缩第一维后的dp数组大小。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-08-18T19:05:00+08:00","permalink":"https://goodcoder666.github.io/p/algonotes-knapsack-dp/","title":"【算法笔记】三种背包问题——背包 DP"},{"content":"前言\r生活中经常遇到类似这种的问题：\n公路修建\n有一些城市，城市之间要修建高速公路，每两个城市之间都可以修双向的路。其中每两个城市之间修路都需要花费对应的金额。请问如何修路，使得总花费的金额最少，且任意两个城市之间都可以直接或间接通过修建的路来通行？\n实际上，我们可以把这种问题抽象化，把城市看作图的顶点，公路看作带权的无向边，这样整个国家就被抽象成了一张带权无向图。又因为要求总花费最小，所以修的路一定组成一棵生成树，于是转换成下面的问题：\n给定一张带权无向图$G$，求它的一棵生成树，使其中所有边权之和最小。\n实际上，这就是大名鼎鼎的「最小生成树问题」。\n比如看下面这张图：\n其中，标绿的部分即为其最小生成树。\n对于这种问题，很多数学家都有所研究。但毕竟是数学家，不懂计算机，就只管算法的正确性，不管实现起来的简单性、可行性和效率，所以很多算法都被人们所抛弃。不过，还是有两种算法脱颖而出，它们就是标题中的——Kruskal 和 Prim。\n模板：洛谷 P3366【模板】最小生成树\n数据范围：$N\\le5000,M\\le2\\times10^5,w\\le 10^4$。\nKruskal\rKruskal算法是由Joseph Kruskal于1956年提出的最小生成树算法，时间复杂度为$\\mathcal O(m\\log m)$。下面来看这种算法的流程。\nKruskal 算法流程\r将所有边按权值从小到大排序，依次遍历每一条边； 对于每一条边，如果在当前子图中连上之后不会形成环，则选择这条边作为最小生成树的一部分，加入子图； 选择$N-1$条边后即可结束算法。 并查集 - 加快算法速度\r在正式实现Kruskal算法之前，我们还需要先了解一下并查集。如果判定是否会出现环的部分使用$\\text{DFS}$，则时间复杂度为$\\mathcal O(nm+m\\log m)$，费时费力。若使用并查集来实现，则代码非常简单，且时间复杂度仅为$\\mathcal O(m\\log m)$（排序的耗时）。并查集模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class dsu { private: const int n; int* fa; public: inline dsu(int count): n(count) // 初始化大小为n的并查集 { fa = new int[n]; // 申请新的内存 for(int i=0; i\u0026lt;n; i++) fa[i] = i; // 初始化fa[i]=i } inline ~dsu() { delete[] fa; } // 销毁存储空间，防止内存泄露 inline int size() { return n; } // 返回并查集大小 int find(int x) { return fa[x] == x? x: fa[x] = find(fa[x]); } // 查找父亲+路径压缩 inline bool same(int x, int y) { return find(x) == find(y); } // x,y是否在同一个连通分量里？ inline void merge(int x, int y) { fa[find(x)] = find(y); } // 合并x、y，即连接x\u0026lt;-\u0026gt;y这条双向边 inline bool connected() // 判断整个图是否连通 { int p = find(0); for(int i=0; i\u0026lt;n; i++) if(find(i) != p) return false; return true; } }; 使用并查集后，算法时间复杂度降到$\\mathcal O(m\\log m)$，即排序的时间复杂度。下面来看代码。\n参考代码\r如果对并查集不熟悉的读者可以先复制模板写代码，后面再仔细研究TA\n单次Kruskal算法的排序建议用priority_queue（比sort效率更高），如果要多次Kruskal则需要提前排好序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; // 代表一条边，方便排序 struct Edge { int from, to, weight; inline bool operator \u0026lt;(const Edge\u0026amp; e2) const { return weight \u0026gt; e2.weight; // 注意：使用优先队列时要把大小倒过来过来 } inline void read() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;from, \u0026amp;to, \u0026amp;weight); from --, to --; } }; // 并查集模板 class dsu { private: const int n; int* fa; public: inline dsu(int count): n(count) { fa = new int[n]; for(int i=0; i\u0026lt;n; i++) fa[i] = i; } inline ~dsu() { delete[] fa; } inline int size() { return n; } int find(int x) { return fa[x] == x? x: fa[x] = find(fa[x]); } inline bool same(int x, int y) { return find(x) == find(y); } inline void merge(int x, int y) { fa[find(x)] = find(y); } inline bool connected() { int p = find(0); for(int i=0; i\u0026lt;n; i++) if(find(i) != p) return false; return true; } }; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); // 读入顶点数和边数 priority_queue\u0026lt;Edge\u0026gt; q; // 初始化优先队列，用于排序 while(m--) { Edge e; e.read(); // 读入一条边 q.push(e); // 放入队列进行排序 } int ans = 0, // 记录总权值 cnt = 0; // 当前选择边的个数 dsu d(n); // 初始化并查集 while(!q.empty() \u0026amp;\u0026amp; cnt \u0026lt; n - 1) // 遍历所有边，选择了n-1条边即可退出 { auto [u, v, w] = q.top(); q.pop(); // 弹出边权最小的边 if(!d.same(u, v)) // 如果连通后不会形成环 { d.merge(u, v); // 连上这条边 ans += w, cnt ++; // 更新答案和计数 } } if(cnt == n - 1) printf(\u0026#34;%d\\n\u0026#34;, ans); // 如果最终选择了n-1条边，输出答案 else puts(\u0026#34;orz\u0026#34;); // 否则... return 0; } 最后一段也可以写成这样（不用cnt计数，输出答案时判定连通，速度稍慢）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int ans = 0; dsu d(n); while(!q.empty()) { auto [u, v, w] = q.top(); q.pop(); if(!d.same(u, v)) { d.merge(u, v); ans += w; } } if(d.connected()) printf(\u0026#34;%d\\n\u0026#34;, ans); else puts(\u0026#34;orz\u0026#34;); Prim\rPrim算法于1930年由捷克数学家Vojtěch Jarník发现，在1957年又由美国计算机科学家Robert C. Prim独立发现。1959年，Edsger Wybe Dijkstra（没错，就是Dijkstra算法的发明者）再次发现了该算法。因此，在某些场合，Prim算法又被称为DJP算法、Jarník算法或Prim－Jarník算法。\nPrim 算法流程\rPrim与Dijkstra很相似，将顶点分为$S$和$T$两个集合，具体流程如下：\n初始时，所有顶点全部在$S$中，$T$为空集。 从$S$中选择任意顶点，移动到集合$T$； 重复以下步骤，直到所有顶点都在$T$中： 选择一条边$(u,v,w)$，使得$u$在点集$S$中，$v$在点集$T$中，且权值$w$最小； 将这条边加入最小生成树，并将$u$移入点集$T$。 Prim算法的原始写法就不多说了，这里和Dijkstra一样，介绍priority_queue和set优化。\n优先队列优化\r运行时间：$328\\mathrm{ms}$\n时间复杂度：$\\mathcal O(n\\log m)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define maxn 5005 #define INF 2147483647 using namespace std; using pii = pair\u0026lt;int, int\u0026gt;; vector\u0026lt;pii\u0026gt; G[maxn]; int dis[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int u, v, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); G[--u].emplace_back(--v, w); G[v].emplace_back(u, w); } for(int i=1; i\u0026lt;n; i++) dis[i] = INF; priority_queue\u0026lt;pii, vector\u0026lt;pii\u0026gt;, greater\u0026lt;pii\u0026gt;\u0026gt; q; q.emplace(0, 0); int ans = 0, left = n; while(!q.empty() \u0026amp;\u0026amp; left \u0026gt; 0) { auto [d, v] = q.top(); q.pop(); if(d != dis[v]) continue; dis[v] = -INF, left --, ans += d; for(auto [u, w]: G[v]) if(w \u0026lt; dis[u]) q.emplace(dis[u] = w, u); } if(left) puts(\u0026#34;orz\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } set优化\r运行时间：$351\\mathrm{ms}$\n时间复杂度：$\\mathcal O(n\\log n)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 5005 #define INF 2147483647 using namespace std; using pii = pair\u0026lt;int, int\u0026gt;; vector\u0026lt;pii\u0026gt; G[maxn]; int dis[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int u, v, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); G[--u].emplace_back(--v, w); G[v].emplace_back(u, w); } for(int i=1; i\u0026lt;n; i++) dis[i] = INF; set\u0026lt;pii\u0026gt; s; s.emplace(0, 0); int ans = 0, left = n; while(!s.empty() \u0026amp;\u0026amp; left \u0026gt; 0) { auto it = s.begin(); auto [d, v] = *it; s.erase(it); dis[v] = -INF, left --, ans += d; for(auto [u, w]: G[v]) if(w \u0026lt; dis[u]) { if(dis[u] != INF) s.erase(pii(dis[u], u)); s.emplace(dis[u] = w, u); } } if(left) puts(\u0026#34;orz\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 习题\r洛谷 P1551 亲戚（并查集练习） UVA1151 买还是建 Buy or Build（Kruskal） UVA1395 苗条的生成树 Slim Span（Kruskal） 洛谷 P1265 公路修建（Prim） 总结\r我们来看一下Kruskal、Prim两种算法的对比：\n指标 Kruskal Prim 时间复杂度 $\\mathcal O(m\\log m)$ $\\mathcal O(n\\log m)$1 运行时间2 $255\\mathrm{ms}$ $328\\mathrm{ms}$ 编码难度 低 中 适用域 稀疏图 稠密图 由此可见，大部分题目首选Kruskal，有特殊需要时才使用Prim。\n本篇文章到此结束，如果觉得好的话就请给个三连，感谢大家的支持！\n此处为优先队列优化的复杂度，set优化为$\\mathcal O(n\\log n)$\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n在洛谷 P3366上的提交结果，Kruskal算法使用并查集+优先队列，Prim使用优先队列优化\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-08-15T11:43:00+08:00","permalink":"https://goodcoder666.github.io/p/algonotes-mst/","title":"【算法笔记】Kruskal/Prim算法——求解最小生成树问题"},{"content":"前言\rDijkstra算法可在$\\mathcal O(m\\log m)$或$\\mathcal O(m\\log n)$的时间内求解无负权单源最短路问题。本文中，我们将详细介绍算法的原理、实现，以及常用的两种优化。\n另外，Dijkstra算法也不要乱用，比如说多源的最短路，用Dijkstra求解的复杂度只有$\\mathcal O(nm\\log m)$，但太麻烦，如果数据范围允许，直接用Floyd就能在$\\mathcal O(n^3)$的时间内完成任务。\n废话不多说，下面来看Dijkstra算法的流程。\n流程\r将结点分成两个集合：已确定最短路长度的点集（记为$S$集合）的和未确定最短路长度的点集（记为$T$集合）。一开始所有的点都属于$T$集合。\n用$d_v$表示顶点$v$到起始点的距离、$s$表示起始点。\n初始化$d_s=0$，其他点的$d$均为$+\\infin$。\n然后重复这些操作：\n从$T$集合中，选取一个最短路长度最小的结点$v$，移到$S$集合中。 对于与$v$相邻的每个点$u$，执行松弛操作：dis[u] = min(dis[u], dis[v] + G[v][u])。 直到$T$集合为空，算法结束。下面来看最简单的实现。\n实现\r本算法的代码可以在CF20C/洛谷链接提交。后面提供的参考代码的输入输出格式都是基于这道题的。数据范围：$n,m\\le 10^5,w_i\\le 10^6$。\n在编写代码之前，我们还要考虑一个问题：如何输出最短路径？\n定义一个数组$\\mathrm{par}$，$\\mathrm{par}[i]$表示最短路径上在点$i$前面的点。初始时，$\\mathrm{par}[s]=-1$，表示前面没有点。\n在$v\\to u$这条边上更新dis[u] = dis[v] + G[v][u]时，同时更新par[u] = v，最后输出时顺着par[v]的路径往下逆序输出到达的点即可。\n朴素实现（无优化）\r这种实现完全按照算法流程，时间复杂度为$\\mathcal O(n^2)$，无法通过例题。下面给出代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 100005 using namespace std; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; G[maxn]; long long dis[maxn]; int par[maxn]; bool vis[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int u, v, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;c); G[--u].emplace_back(--v, c); G[v].emplace_back(u, c); } // Dijkstra 算法流程 // 初始化 memset(dis, 0x3f, sizeof dis); memset(vis, 0, sizeof vis); dis[0] = 0LL, par[0] = -1; // 起点的距离为0 while(true) { int v = n; // 不存在的虚拟结点，距离为+INF，方便判断 for(int i=0; i\u0026lt;n; i++) if(!vis[i] \u0026amp;\u0026amp; dis[i] \u0026lt; dis[v]) v = i; if(v \u0026gt;= n - 1) break; // 找不到或到达终点，退出 vis[v] = true; // 标记访问过 for(auto [u, d]: G[v]) if(dis[v] + d \u0026lt; dis[u]) // 是否有更优路径？ { dis[u] = dis[v] + d; // 更新距离 par[u] = v; // 更新路径 } } if(dis[n - 1] == dis[n]) // 没有找到解（图不连通） { puts(\u0026#34;-1\u0026#34;); return 0; } vector\u0026lt;int\u0026gt; path; // 存储路径，注意要倒序输出 int v = n - 1; // 从终点向前获取最优路径 while(v != -1) { path.push_back(v); // 加入路径 v = par[v]; // 向前回溯 } for(int i=path.size()-1; i\u0026gt;=0; i--) printf(\u0026#34;%d \u0026#34;, path[i] + 1); // 输出 return 0; } 评测结果：\n优先队列优化\r优先队列，又称二叉堆，是常用的一种数据结构。可以执行下列操作（$n$为优先队列队列中的元素个数）：\n弹出最小/最大的元素，时间$\\mathcal O(\\log n)$ 添加新元素，时间$\\mathcal O(\\log n)$ 利用这些特点，我们可以在$\\mathcal O(m\\log m)$的时间内完成一轮Dijkstra。其细节为：\n初始时，仅将起始点和距离$(s,0)$放入队列； 当队列不为空时，执行： 弹出距离最小的顶点和距离$(v,d)$，如果距离$d\\ne dis[v]$，则说明已经找到了其他更短路径，舍弃这条路； 否则，依次更新每条邻边$v\\to u$，如果距离比原来的更短，则不仅要更新$\\mathrm{dis}$和$\\mathrm{par}$，还要把$(u,\\mathrm{dis}[u])$放入队列。 实现代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define maxn 100005 #define INF 9223372036854775807LL using namespace std; using LL = long long; using pli = pair\u0026lt;LL, int\u0026gt;; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; G[maxn]; LL dis[maxn]; int par[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int u, v, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;c); G[--u].emplace_back(--v, c); G[v].emplace_back(u, c); } for(int i=1; i\u0026lt;n; i++) dis[i] = INF; par[0] = -1; priority_queue\u0026lt;pli, vector\u0026lt;pli\u0026gt;, greater\u0026lt;pli\u0026gt;\u0026gt; q; q.emplace(0LL, 0); while(!q.empty()) { auto [d, v] = q.top(); q.pop(); if(dis[v] == d) for(auto [u, w]: G[v]) if(d + w \u0026lt; dis[u]) par[u] = v, q.emplace(dis[u] = d + w, u); } if(dis[n - 1] == INF) { puts(\u0026#34;-1\u0026#34;); return 0; } vector\u0026lt;int\u0026gt; path; int v = n - 1; while(v != -1) { path.push_back(v); v = par[v]; } for(int i=path.size()-1; i\u0026gt;=0; i--) printf(\u0026#34;%d \u0026#34;, ++path[i]); return 0; } 时间复杂度为$\\mathcal O(m\\log m)$，可以通过此题。运行时间：$93\\text{ms}$\nset优化\rset又称集合，与优先队列相似，支持添加、删除，另外还可以删除任意元素，时间$\\mathcal O(\\log n)$。要发挥出set的优势，就要在维护时删掉多余的顶点-距离对，防止不必要的dis[v] == d这种判断。\n此时，集合中的元素个数永远不会超过$N$，因此总时间复杂度为$\\mathcal O(m\\log n)$。\n在$m\\ge n$，即边数大于顶点数时，这种方法优于priority_queue。不过，一般使用Dijkstra算法的题目中都是$m\\le n$，所以set的优化不常用，但下面还是给出代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 100005 #define INF 9223372036854775807LL using namespace std; using LL = long long; using pli = pair\u0026lt;LL, int\u0026gt;; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; G[maxn]; LL dis[maxn]; int par[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int u, v, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;c); G[--u].emplace_back(--v, c); G[v].emplace_back(u, c); } for(int i=1; i\u0026lt;n; i++) dis[i] = INF; par[0] = -1; set\u0026lt;pli\u0026gt; s; s.emplace(0LL, 0); while(!s.empty()) { auto it = s.begin(); s.erase(it); auto [d, v] = *it; for(auto [u, w]: G[v]) if(d + w \u0026lt; dis[u]) { par[u] = v; if(dis[u] != INF) s.erase(pli(dis[u], u)); s.emplace(dis[u] = d + w, u); } } if(dis[n - 1] == INF) { puts(\u0026#34;-1\u0026#34;); return 0; } vector\u0026lt;int\u0026gt; path; int v = n - 1; while(v != -1) { path.push_back(v); v = par[v]; } for(int i=path.size()-1; i\u0026gt;=0; i--) printf(\u0026#34;%d \u0026#34;, ++path[i]); return 0; } AC，运行时间：$78\\text{ms}$\n后记\r总结一下Dijkstra算法的实现方式：\n暴力（$\\mathcal O(n^2)$，TLE ;(） 优先队列（$\\mathcal O(m\\log m)$，$93\\text{ms}$ :|） 集合/set（$\\mathcal O(m\\log n)$，$78\\text{ms}$ :)） ","date":"2022-08-13T12:37:00+08:00","permalink":"https://goodcoder666.github.io/p/algonotes-dijkstra/","title":"【算法笔记】单源最短路问题——Dijkstra算法（无优化/优先队列/set优化）"},{"content":"前言\r在图中，如果要求任意两点间的距离，则可以使用Floyd（$\\mathcal O(N^3)$;)）和Dijkstra（$\\mathcal O(NM\\log M)$:)）。对于比较小的数据范围（一般为顶点数$N\\le 150$），可以使用Floyd算法。本文将讲述Floyd算法的原理、实现和扩展应用。\n如果有哪里写得不好请各位dalao多多指教，谢谢！\n原理\r$$\rf(x,y)=\r\\begin{cases}\r0 \u0026 (x=y) \\\\\rG[x][y] \u0026 (G[x][y]\\ne0)\\\\\r+\\infin \u0026 (x\\ne y,G[x][y]=0)\r\\end{cases}\r$$\n其中$G$为图的邻接矩阵，$G[x][y]$表示顶点$x$到$y$的边权，$0$表示$x$到$y$没有连边。\n接下来，考虑枚举中间点$k$，按$x\\to k\\to y$的路线计算最短路，则伪代码为：\n1 2 3 4 for k = 1, 2, ..., n for x = 1, 2, ..., n for y = 1, 2, ..., n f[x][y] = min(f[x][y], f[x][k] + f[k][y]) 此时，算法结束，最终$f(x,y)$即为从$x$到$y$的最短路。\n注意：当给定图为无向图时，对于任意$(x,y)$，$G[x][y]=G[y][x]$，则$f(x,y)=f(y,x)$，可改变计算过程（如变成f[k][x]+f[k][y]）；但若是有向图，请务必按照伪代码中的顺序编写程序！\n代码\rFloyd算法的代码可在洛谷 B3647提交。下面给出这题对应的AC代码（注意是按边输入）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define maxn 100 using namespace std; int dis[maxn][maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); // 初始化，注意初始值不能超过INT_MAX/2（防止两个INF相加溢出） memset(dis, 0x3f, sizeof dis); // 每个点到自己的距离为0 for(int i=0; i\u0026lt;n; i++) dis[i][i] = 0; // 读入边 while(m--) { int u, v, d; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;d); u --, v --; // 0-index dis[u][v] = dis[v][u] = d; // 注意两个值都要设 } // Floyd 算法流程 for(int k=0; k\u0026lt;n; k++) // 中间点 for(int i=0; i\u0026lt;n; i++) // 起始点 for(int j=0; j\u0026lt;n; j++) // 终点 { int d = dis[i][k] + dis[k][j]; // i-\u0026gt;k-\u0026gt;j if(d \u0026lt; dis[i][j]) dis[i][j] = d; // 取最短长度 } for(int i=0; i\u0026lt;n; i++, putchar(\u0026#39;\\n\u0026#39;)) for(int j=0; j\u0026lt;n; j++) printf(\u0026#34;%d \u0026#34;, dis[i][j]); return 0; } 扩展\r下面问题来了：如何输出结果路径？其实方法很简单。与Dijkstra类似但略有不同，设$\\text{path}(x, y)=x\\to y$的最短路径上的某一点，则状态转移时若$f(x,k)+f(k,y) \u003c f(x,y)$，则不仅要更新$f(x,y)$，还要更新$\\text{path}(x,y):=k$。最后，递归输出结果即可。\n题面\r给定一张有$N$个点，$M$条边的简单无向图，对于每一对$(i,j)$（$1\\le i \u003c j\\le N$），求$i\\to j$的最短路径上的每一点。\n样例\r输入：\n1 2 3 4 5 6 7 5 6 3 4 3 4 1 1 4 5 4 1 2 2 5 2 10 3 2 7 输出：\n1 2 3 4 5 6 7 8 9 10 1-\u0026gt;2: 1 2 1-\u0026gt;3: 1 4 3 1-\u0026gt;4: 1 4 1-\u0026gt;5: 1 4 5 2-\u0026gt;3: 2 1 4 3 2-\u0026gt;4: 2 1 4 2-\u0026gt;5: 2 1 4 5 3-\u0026gt;4: 3 4 3-\u0026gt;5: 3 4 5 4-\u0026gt;5: 4 5 代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define maxn 100 using namespace std; int dis[maxn][maxn], path[maxn][maxn]; void print(int x, int y) // 递归输出x-\u0026gt;y的路径，不包含y { int k = path[x][y]; // x-\u0026gt;k-\u0026gt;y if(k == x || k == y) // 两点相邻，直接输出 printf(\u0026#34; %d\u0026#34;, x); else { // 分成两部分递归 print(x, k); // x-\u0026gt;k print(k, y); // k-\u0026gt;y } } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); // 初始化 memset(dis, 0x3f, sizeof dis); for(int i=0; i\u0026lt;n; i++) dis[i][i] = 0; // 读入边 while(m--) { int u, v, d; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;d); dis[u][v] = dis[v][u] = d; // 注意两个值都要设 path[u][v] = path[v][u] = u; // 初始化path } // Floyd 算法流程，为了方便输出，采用1-index for(int k=1; k\u0026lt;=n; k++) // 中间点 for(int i=1; i\u0026lt;=n; i++) // 起始点 for(int j=1; j\u0026lt;=n; j++) // 终点 { int d = dis[i][k] + dis[k][j]; // i-\u0026gt;k-\u0026gt;j if(d \u0026lt; dis[i][j]) // 更新最短路径 dis[i][j] = d, path[i][j] = k; } // 依次枚举(i,j) 输出路径 for(int i=1; i\u0026lt;n; i++) for(int j=i+1; j\u0026lt;=n; j++) { printf(\u0026#34;%d-\u0026gt;%d:\u0026#34;, i, j); print(i, j); printf(\u0026#34; %d\\n\u0026#34;, j); } return 0; } 注：由于每条路径的长度不会超过$N$，所以总时间复杂度仍为$\\mathcal O(N^3)$。\n后记\r总结：Floyd算法时间复杂度为$\\mathcal O(N^3)$，写起来很方便。如果觉得好就请给个三连，谢谢支持！\n","date":"2022-08-12T21:07:00+08:00","permalink":"https://goodcoder666.github.io/p/algonotes-floyd/","title":"【算法笔记】多源最短路问题——Floyd算法"},{"content":"定义\r树形DP，又称树状DP，即在树上进行的DP，是DP（动态规划）算法中较为复杂的一种。\n基础\r令$f[u]=~$与树上顶点$u$有关的某些数据，并按照拓扑序（从叶子节点向上到根节点的顺序）进行$\\text{DP}$，确保在更新一个顶点时其子节点的dp值已经被更新好，以更新当前节点的$\\text{DP}$值。为方便计算，一般写成dfs的形式，如下：\n1 2 3 4 5 6 7 void dfs(int v) { // 遍历节点v dp[v] = ...; // 初始化 for(int u: G[v]) { // 遍历v的所有子节点 dfs(u); update(u, v); // 用子节点的dp值对当前节点的dp值进行更新 } } 下面来看一道简单的例题：\n【例1.1】子树大小\r给定一棵有$N$个结点的树，根结点为结点$1$。对于$i=1,2,\\dots,N$，求以结点$i$为根的子树大小（即子树上结点的个数，包括根结点）。\n$$\rf[v]=1+\\sum_{i=1}^{\\text{deg}_v} G[v][i]\r$$\n即：一个结点的子树大小$~=1$（根节点）$+~$每个子树的大小。\n沿用刚才的模板，可得：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 100 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; // 邻接表 int sz[maxn]; // dp数组，sz[v] = 子树v的大小 void dfs(int v) { sz[v] = 1; // 初始化，最初大小为1，后面累加 for(int u: G[v]) // 遍历子结点 { dfs(u); // 先对子结点进行dfs sz[v] += sz[u]; // 更新当前子树的大小 } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); // 结点个数 for(int i=1; i\u0026lt;n; i++) // N-1条边 { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); // 读入一条边 G[u].push_back(v); // 存入邻接表 } dfs(1); for(int i=1; i\u0026lt;=n; i++) printf(\u0026#34;%d\\n\u0026#34;, sz[i]); return 0; } 下面来看一道稍微复杂一点的题：\n【例1.2】洛谷P1352 没有上司的舞会\r本题即树的最大独立集问题。\n有$N$名职员，编号为$1\\dots N$，他们的关系就像一棵以老板为根的树，父节点就是子节点的直接上司。每个职员有一个快乐指数$r_i$，现在要召开一场舞会，使得没有职员和直接上司一起参会。主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。\n令$f(v)$表示以$v$为根的子树中，选择$v$的最优解，$g(v)$表示以$v$为根的子树中，不选$v$的最优解。\n则对于每个状态，都存在两种决策（其中$u$代表$v$的儿子）：\n不选$v$时，可选也可不选$u$，此时有$g(v)=\\sum\\max\\{f(u),g(u)\\}$； 选择$v$时，一定不能选$u$，此时有$f(v)=r_i+\\sum g(u)$。 时间复杂度为$\\mathcal O(N)$。\n注意本题需要寻找根节点，没有上司的结点即为根节点，读入时用数组标记即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 6005 using namespace std; inline int max(int x, int y) { return x \u0026gt; y? x: y; } vector\u0026lt;int\u0026gt; G[maxn]; // 邻接表 bool bad[maxn]; // 根结点标记 int f[maxn], g[maxn]; // 数据存储 void dfs(int v) // 遍历结点v { // 读入时已初始化，这里可省略 for(int u: G[v]) // 遍历子结点 { dfs(u); // 先对子结点进行dfs // 更新当前dp状态 f[v] += g[u]; // 选择v，不能选u g[v] += max(f[u], g[u]); // 不选v，u可选可不选 } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); // 结点个数 for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, f + i); // 相当于提前初始化好f[i]=r[i] for(int i=1; i\u0026lt;n; i++) // N-1条边 { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); // 读入一条边 G[--v].push_back(--u); // 0-index，存入邻接表 bad[u] = true; // 标记不可能是根结点 } int root = -1; // 根结点变量 for(int i=0; i\u0026lt;n; i++) if(!bad[i]) // 找到根结点 { root = i; // 记录根结点 break; } dfs(root); // 开始进行树形DP printf(\u0026#34;%d\\n\u0026#34;, max(f[root], g[root])); // 根结点也有两种选择 return 0; } 习题\rHDU 2196 Computer / vjudge链接 POJ 1463 Strategic game 洛谷 P3574 [POI2014] FAR-FarmCraft 树上背包\r在基本算法之上，树形dp还可以用于树上背包问题。来看一道例题：\n【例2.1】洛谷P2014 / AcWing 286 选课\r有$N$门课，第$i$门课的学分是$s_i$。每门课有不超过一门先修课，需要上了先修课才能上这门课。现要选$M$门课，使得学分总和最大。\n每门课最多只有一门先修课，这符合树结构的特点，与有根树中一个点最多只有一个父亲结点的特点类似。因此，我们根据数据构造一棵树，课程的先修课为这门课的父结点。又由于给定的输入是一个森林（多棵树组成的不一定连通的图），不是一棵完整的树，因此我们添加虚拟根结点$0$（$s_0=0$），将没有先修课的结点全部连到它下面，并从这里开始dfs。注意此时必须选中$0$号结点（它是所有课程的直接或间接先修课），所以操作前先将$M$加上$1$。\n格式问题解决，下面考虑如何$\\text{DP}$。\n令$f[i][j]$表示当前在结点$i$、且已经选了$j$门课时的最大学分数量，则答案为$f[0][M+1]$。状态转移方程等详见代码。时间复杂度为$\\mathcal O(NM)$，有兴趣的可以自己尝试证明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 305 using namespace std; // dp算法中常用的模板，等效于x=max(x,y) inline void setmax(int\u0026amp; x, int y) { if(x \u0026lt; y) x = y; } vector\u0026lt;int\u0026gt; G[maxn]; // 邻接表 int n, m, f[maxn][maxn]; int dfs(int u) // 遍历结点u，返回值为其子树大小 { int tot = 1; // 记录子树大小，初始为1 for(int v: G[u]) // 遍历u的所有子结点 { int sz = dfs(v); // 对当前子结点进行搜索 // 状态转移，注意i倒序，防止串连转移现象 for(int i=min(tot, m); i\u0026gt;0; i--) // 子树大小优化可降低算法复杂度 for(int j=1, lim=min(sz, m-i); j\u0026lt;=lim; j++) setmax(f[u][i + j], f[u][i] + f[v][j]); // 更新状态 tot += sz; // 加到当前子树下 } return tot; // 返回子树大小 } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=1; i\u0026lt;=n; i++) { int a; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, f[i] + 1); // 初始化f[i][1]=s[i] G[a].push_back(i); } m ++; // 别忘了这一句 dfs(0); printf(\u0026#34;%d\\n\u0026#34;, f[0][m]); return 0; } 习题\rLOJ #2546. 「JSOI2018」潜入行动 LOJ #2268. 「SDOI2017」苹果树 换根 DP\r换根DP，即为不知道根结点时使用的一种树形DP，时间复杂度一般为$\\mathcal O(N)$。\n【例3.1】洛谷 P3478 [POI2008] STA-Station\r给定一个$n$个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。\n先考虑最简单粗暴的方法，即为枚举所有结点，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 1000005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; int dfs(int v, int d, int par) { int s = d; for(int u: G[v]) if(u != par) s += dfs(u, d + 1, v); return s; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int t=n; --t; ) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[--u].push_back(--v); G[v].push_back(u); } int ans = 0, maxDepth = dfs(0, 0, -1); for(int root=1; root\u0026lt;n; root++) { int d = dfs(root, 0, -1); if(d \u0026gt; maxDepth) ans = root, maxDepth = d; } printf(\u0026#34;%d\\n\u0026#34;, ++ans); return 0; } 很明显，这种做法时间复杂度为$\\mathcal O(n^2)$，又因为$n\\le 10^6$，所以无法得全分，评测结果如下：\n好家伙，居然还有50分，本以为最多30..\n下面来考虑换根DP的方法。不妨令$u$为当前结点，$v$为其子结点。先预处理出每个结点的子树大小$s[u]=1+\\sum s[v]$和以$1$为根结点时所有结点的深度（$\\text{depth}_i$），此时第一遍DFS即为预处理。\n令$f_u$表示以$u$为根时，所有结点的总深度和，则$f_1=\\sum\\text{depth}_i$。\n考虑$f_u\\to f_v$的转移，即“根结点从$u$变成$v$时所有结点深度和的变化”，则有：\n所有在$v$的子树上的结点深度全部$-1$，则总深度和减少$s_v$； 所有不在$v$的子树上的结点深度都$+1$，则总深度和增加$n-s_v$； 此时，可得$f_v=f_u-s_v+n-s_v=f_u+n-2s_v$。注意数据类型，使用long long。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 1000005 using namespace std; using LL = long long; vector\u0026lt;int\u0026gt; G[maxn]; LL sz[maxn], f[maxn]; int n, ans; LL dfs1(int v, int d, int par) { sz[v] = 1; LL s = d; for(int u: G[v]) if(u != par) s += dfs1(u, d + 1, v), sz[v] += sz[u]; return s; } void dfs2(int v, int par) { if(f[v] \u0026gt; f[ans]) ans = v; for(int u: G[v]) if(u != par) { f[u] = f[v] + n - (sz[u] \u0026lt;\u0026lt; 1LL); dfs2(u, v); } } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int t=n; --t; ) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[--u].push_back(--v); G[v].push_back(u); } f[0] = dfs1(0, 0, -1); dfs2(0, -1); printf(\u0026#34;%d\\n\u0026#34;, ++ans); return 0; } 习题\rPOJ 3585 Accumulation Degree 洛谷 P2986 [USACO10MAR] Great Cow Gathering G CodeForce 708C Centroids ABC 222F - Expensive Expense 后记\r好像这玩意也并不是开头所说的那么难…… 记得给个三连哦！\n参考文献：\n树形 DP - OI wiki 树形dp - tom0727\u0026rsquo;s blog 【动态规划】树形DP完全详解！ - RioTian - 博客园 ","date":"2022-08-12T10:15:00+08:00","permalink":"https://goodcoder666.github.io/p/algonotes-tree-dp/","title":"【算法笔记】树形DP算法总结\u0026amp;详解"},{"content":"A - Full House\r题目大意\r来自一个掼蛋爱好者的翻译qwq\n给定一副扑克牌中五张牌的编号$A,B,C,D,E$，判断这五张是否为一组“三带二”。（不懂的自行百度\n数据范围：$1\\le A,B,C,D,E\\le 13$，且$A,B,C,D,E$不会全部相同。\n输入格式\r$A~B~C~D~E$\n输出格式\r如果是“三带二”，输出Yes；否则，输出No。\n样例\r$A$ $B$ $C$ $D$ $E$ 输出 $1$ $2$ $1$ $2$ $1$ Yes $12$ $12$ $11$ $1$ $2$ No 分析\r嘿嘿，被自己的翻译给笑喷了吓住了，从来没见过这么好垃圾的翻译！\n话不多说，这A题就是水（虽然studentWheat这位大佬还WA了3次，具体怎么WA的请大家好好学学引以为戒），解法很多，但是个人感觉还是直接统计一下来得简单明了，见代码。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; using namespace std; int cnt[13]; int main() { for(int i=0; i\u0026lt;5; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); cnt[--x] ++; } bool has2 = false, has3 = false; for(int i=0; i\u0026lt;13; i++) if(cnt[i] == 2) has2 = true; else if(cnt[i] == 3) has3 = true; puts(has2 \u0026amp;\u0026amp; has3? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Ancestor\r题目大意\r有$N$个人，第$i$个人的父/母是$P_i$，题目保证$P_i \u003c i$。\n问：第$N$个人是第$1$个人的第几代？\n$2\\le N\\le 50$\n$1\\le P_i \u003c i$\n输入格式\r$N$\n$P_2~P_3~\\dots~P_N$\n输出格式\r输出答案。\n分析\r本题可以使用$\\text{DFS}$，但没有必要。题目限制条件特别给出了$P_i \u003c i$，因此如果按输入顺序依次处理每个人的世代，一个人的父亲肯定在这个人之前被考察到。\n下面来看详细过程。\n我们设$\\text{depth}_i=~$第$i$个节点的深度，因此答案为$\\text{depth}_N$。\n初始时，$\\text{depth}_0=0$。对于$i=1\\dots N$，依次设置$\\text{depth}_i:=\\text{depth}_{P_i}+1$。\n最终，输出结果即可。总时间复杂度为$\\mathcal O(N)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;cstdio\u0026gt; #define maxn 55 using namespace std; int dep[maxn]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=1; i\u0026lt;n; i++) { int f; scanf(\u0026#34;%d\u0026#34;, \u0026amp;f); dep[i] = dep[--f] + 1; } printf(\u0026#34;%d\\n\u0026#34;, dep[n - 1]); return 0; } C - Monotonically Increasing\r题目大意\r输出所有的长度为$N$的严格上升的序列，其中每个元素都在$[1,M]$之间，按字典升序输出，$1\\le N\\le M\\le 10$。\n输入格式\r$N~M$\n输出格式\r按字典升序输出所有符合条件的序列，一行一个，序列中的每个元素用空格分隔。\n分析\r基础的回溯算法题，见代码。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; #define maxn 15 using namespace std; int n, m, ans[maxn]; void dfs(int pos, int last) { if(pos == n) { for(int i=0; i\u0026lt;n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); putchar(\u0026#39;\\n\u0026#39;); return; } while(++last \u0026lt;= m) { ans[pos] = last; dfs(pos + 1, last); } } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); dfs(0, 0); return 0; } D - Left Right Operation\r题目大意\r给定长为$N$的整数序列$A=(A_1,A_2,\\dots,A_N)$。\n你可以进行下列两个操作，每个最多一次：\n选择整数$x$，将$A$的前$x$项全部改成$L$。 选择整数$y$，将$A$的后$y$项全部改成$R$。 求操作后，最小的$A$中所有元素之和。\n$1\\le N\\le 2\\times 10^5$\n$-10^9\\le L,R,A_i\\le 10^9$\n输入格式\r$N~L~R$\n$A_1~A_2~\\dots~A_N$\n输出格式\r输出答案。\n分析\r令$f_i=($使用操作$1$选择$x\\le i$时的前$i$个序列元素的最小和$)$，\n$~~~~g_i=($使用操作$2$选择$y\\le i$时的后$i$个序列元素的最小和$)$，\n则可得递推式$f_i=\\min\\{f_{i-1}+A_i,L\\times i\\}$，$g_i$同理。\n此时，枚举两种操作的分界点$i$，则答案为$\\min\\limits_{i=1}^N(f_i+g_{N-i})$。实现时，可将$g$数组倒过来计算，这样答案为$\\min\\limits_{i=1}^N(f_i+g_{i+1})$。\n递推式的正确性证明\n前面已经提到了，$f_i=\\min\\{f_{i-1}+A_i,L\\times i\\}$。为什么？\n先看$\\min$后面的部分，应该好理解，就是前$i$个全部替换成$L$的总和。前面的$f_{i-1}+A_i$才是关键。考虑$f_{i-1}$的计算来源，要么是从$f_{i-2}+A_{i-1}$递推过来的，要么也是直接用$L\\times(i-1)$得到的。再考虑$f_{i-2},f_{i-3},\\dots,f_1$会发现，递推式的结果一定是(一段$L$)+(一段$A_i$)得到的。因此，这个递推式正确。$g$的正确性也可以用同样的方法证明，感兴趣的读者可以自行尝试。\n总时间复杂度为$\\mathcal O(N)$。\n代码\r注意使用long long。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; using LL = long long; inline LL min(const LL\u0026amp; x, const LL\u0026amp; y) { return x \u0026lt; y? x: y; } int a[maxn]; LL f[maxn], g[maxn]; int main() { int n, l, r; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;l, \u0026amp;r); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); f[0] = min(l, a[0]); for(int i=1; i\u0026lt;n; i++) f[i] = min(f[i - 1] + a[i], (i + 1LL) * l); for(int i=n-1; i\u0026gt;=0; i--) g[i] = min(g[i + 1] + a[i], LL(n - i) * r); LL ans = g[0]; for(int i=0; i\u0026lt;n; i++) ans = min(ans, f[i] + g[i + 1]); printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } E - Sugoroku 3\r题目大意\r有$N$个方格，分别是方格$1$，方格$2$，..，方格$N$。\n在方格$1,2,\\dots,N-1$上，各有一枚骰子。方格$i$上的骰子会按照相同的概率随机输出$0,1,\\dots,A_i$中的一个。\n直到到达方格$N$之前，你每次会前进骰子输出的步数。换句话说，如果你在方格$x$上（$1\\le x \u003c N$），骰子输出了数字$y$（$0\\le y\\le A_i$），你下一步会到达方格$x+y$。\n求到达方格$N$步数的期望值，对$998244353$取模。\n$2\\le N\\le 2\\times 10^5$\n$1\\le A_i\\le N-i$（$1\\le i \u003c N$）\n有理数取模【洛谷模板：P2613】\n任意一个有理数都可被表示为$\\frac PQ$的形式。令$R$为取模的结果，则$R\\times Q\\equiv P~(\\bmod~998244353)$。\n友情提示：对于除法计算，如$\\frac AB$计算时，改为$A\\times B^{P-2}\\bmod P$，其他逐步取模即可。本题中，$P=998244353$。\n输入格式\r$N$\n$A_1~A_2~\\dots~A_{N-1}$\n输出格式\r输出答案，对$998244353$取模。\n分析\r$$\r\\text{dp}_i=\\frac{\\sum\\limits_{j=i}^{i+A_i}\\text{dp}_j}{A_i+1}+1\r$$$$\r\\text{dp}_i=\\frac{(\\sum\\limits_{j=i}^{i+A_i}\\text{dp}_j)+A_i+1}{A_i}\r$$\n此时，时间复杂度为$\\mathcal O(N^2\\log P)$（快速幂inv操作需要$\\log P$的时间，其中$P=998244353$），使用后缀和优化后可达$\\mathcal O(N\\log P)$，可以通过本题。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 #define MOD 998244353 using namespace std; using LL = long long; int a[maxn], suf[maxn]; inline int inv(LL x) { LL res = 1LL; int p = MOD - 2; while(p) { if(p \u0026amp; 1) (res *= x) %= MOD; (x *= x) %= MOD, p \u0026gt;\u0026gt;= 1; } return res; } int main() { int n, cur; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n-1; i++) scanf(\u0026#34;%d\u0026#34;, a + i); for(int i=n-2; i\u0026gt;=0; i--) { int t = suf[i + 1] - suf[i + 1 + a[i]]; if(t \u0026lt; 0) t += MOD; cur = (a[i] + t + 1LL) % MOD * inv(a[i]) % MOD; if((suf[i] = suf[i + 1] + cur) \u0026gt;= MOD) suf[i] -= MOD; } printf(\u0026#34;%d\\n\u0026#34;, cur); return 0; } ","date":"2022-08-07T19:45:00+08:00","permalink":"https://goodcoder666.github.io/p/abc263/","title":"LINE Verda Programming Contest (AtCoder Beginner Contest 263) A~E 题解"},{"content":"前言\r最近在家里闲着没事，正好又看到朋友@studentWheat发了篇用Tkinter做的账本，于是决定跟他一起改进这个程序。\n屏幕截图：\n后端\r后端主要是朋友做的，在这里就不多说了，放个代码：\nsrc/api.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 from collections import defaultdict class ApiError(RuntimeError): pass def openFile(filename): \u0026#39;\u0026#39;\u0026#39; Open file. File format: 4 lines per record for date, event type, money delta, and note. Such as: (file.example, encoding=utf-8) (Record 1) (ln 1) date1 (ln 2) event_type1 (ln 3) money_delta1 (ln 4) note1 (Record 2) (ln 5) date2 (ln 6) event_type2 (ln 7) money_delta2 (ln 8) note2 @param filename: File name. Returns: data in the format [[date1, event_type1, money_delta1, note1], ...] \u0026#39;\u0026#39;\u0026#39; with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: res = [] while date := f.readline(): if (etype := f.readline()) and (mdelta := f.readline()) and (note := f.readline()): res.append([date.rstrip(\u0026#39;\\n\u0026#39;), etype.rstrip(\u0026#39;\\n\u0026#39;), mdelta.rstrip(\u0026#39;\\n\u0026#39;), note.rstrip(\u0026#39;\\n\u0026#39;)]) else: raise ApiError(\u0026#39;Unexpected EOF at \u0026#39; + filename) return res def saveFile(filename, data): # Save \u0026#39;\u0026#39;\u0026#39; Save with the same format mentioned in openFile(). @param filename: File name. @param data: Data with the same format returned in openFile(). \u0026#39;\u0026#39;\u0026#39; with open(filename, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: for line in data: print(*line, sep=\u0026#39;\\n\u0026#39;, file=f) def query(data, key): return [record for record in data if any(key in x for x in record)] if key else data def total(data): in_total = out_total = 0 for _, _, mdelta, _ in data: mdelta = int(mdelta) if mdelta \u0026lt; 0: out_total -= mdelta else: in_total += mdelta return in_total, out_total def totalByEvent(data): cnt = defaultdict(lambda: [0, 0]) for _, event, mdelta, _ in data: mdelta = int(mdelta) if mdelta \u0026lt; 0: cnt[event][1] -= mdelta else: cnt[event][0] += mdelta return cnt def totalByDate(data): cnt = defaultdict(lambda: [0, 0]) for date, _, mdelta, _ in data: mdelta = int(mdelta) if mdelta \u0026lt; 0: cnt[date][1] -= mdelta else: cnt[date][0] += mdelta return cnt 详见https://blog.csdn.net/qq_67190987/article/details/125918530。\n前端\r正如标题中所说，框架采用Qt6+Python，一般有两种选择（PyQt6和PySide6），我这里使用的是PySide6。\n准备资源\r在src/icons下存好所有图片资源：\nDesigner 窗口绘制\r用Qt Designer绘制好各个窗口，如图:\n安装依赖项\r准备一份requirements.txt，内容如下：\n1 PySide6\u0026gt;=6.3.1 然后，cmd中输入：\n1 pip install -r requirements.txt 搞定安装。\n编译资源和UI\r这个就不用多说了，直接用pyside6-uic和pyside6-rcc命令编译文件，编译出的文件列表如下：\n1 2 3 4 5 6 7 8 9 10 11 AccountBook └─src │ dlgAdd.ui │ dlgCharts.ui │ MainWindow.ui │ res.qrc │ res_rc.py │ ui_dlgAdd.py │ ui_dlgCharts.py │ ui_dlgHelp.py │ ui_MainWindow.py 代码编写\rsrc/dlgAdd.py\n“添加账目”窗口，一个简单的QDialog实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from PySide6.QtWidgets import * from PySide6.QtCore import QDate, QRegularExpression from PySide6.QtGui import QRegularExpressionValidator from ui_dlgAdd import Ui_Dialog class dlgAdd(QDialog): def __init__(self, parent=None): super().__init__(parent) self.ui = Ui_Dialog() self.ui.setupUi(self) self.ui.dateEdit.setDate(QDate.currentDate()) self.ui.moneyEdit.setValidator(QRegularExpressionValidator(QRegularExpression(r\u0026#39;(\\+|\\-)[1-9]+[0-9]*\u0026#39;))) self.ui.buttonBox.button(QDialogButtonBox.Ok).setText(\u0026#39;确定\u0026#39;) self.ui.buttonBox.button(QDialogButtonBox.Cancel).setText(\u0026#39;取消\u0026#39;) def getRow(self): date = self.ui.dateEdit.text() event = self.ui.eventEdit.text() money = self.ui.moneyEdit.text() note = self.ui.noteEdit.text() return [date, event, money, note] def accept(self): if not self.ui.eventEdit.text(): QMessageBox.critical(self, \u0026#34;错误\u0026#34;, \u0026#34;事件不能为空，请重新填写。\u0026#34;) return if self.ui.moneyEdit.text() in (\u0026#39;\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;): QMessageBox.critical(self, \u0026#34;错误\u0026#34;, \u0026#34;金额不能为空，请重新填写。\u0026#34;) return return super().accept() src/dlgCharts.py\n图表展示窗口，使用QtCharts（用法跟PyQt5/PySide2略有区别）绘制柱状图。后续会考虑增加更多图表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 from bisect import bisect_left, bisect_right from PySide6.QtCore import QDate, Qt from PySide6.QtWidgets import * from PySide6.QtCharts import QBarCategoryAxis, QBarSeries, QBarSet, QChart, QChartView, QValueAxis from api import total, totalByDate, totalByEvent from ui_dlgCharts import Ui_Dialog class dlgCharts(QDialog): def __init__(self, data, parent=None): super().__init__(parent) self.ui = Ui_Dialog() self.ui.setupUi(self) self.showMaximized() self.data = data minDate = QDate.fromString(data[0][0], \u0026#39;yyyy/MM/dd\u0026#39;) maxDate = QDate.fromString(data[-1][0], \u0026#39;yyyy/MM/dd\u0026#39;) self.ui.startDateEdit.setDateRange(minDate, maxDate) self.ui.endDateEdit.setDateRange(minDate, maxDate) self.ui.startDateEdit.setDate(minDate) self.ui.endDateEdit.setDate(maxDate) self.__update_totalChart(*total(data)) self.__update_eventChart(totalByEvent(data)) self.__update_dateChart(totalByDate(data)) self.ui.startDateEdit.editingFinished.connect(self.__updateCharts) self.ui.endDateEdit.editingFinished.connect(self.__updateCharts) @staticmethod def createChart(chartView: QChartView, title, xAxis, yAxisList): chart = QChart() chart.setTitle(title) chart.setAnimationOptions(QChart.SeriesAnimations) series = QBarSeries() for axisName, data in yAxisList: barSet = QBarSet(axisName) barSet.append(data) series.append(barSet) chart.addSeries(series) axisX = QBarCategoryAxis() axisX.append(xAxis) chart.addAxis(axisX, Qt.AlignBottom) series.attachAxis(axisX) axisY = QValueAxis() axisY.setLabelFormat(\u0026#39;%d\u0026#39;) chart.addAxis(axisY, Qt.AlignLeft) series.attachAxis(axisY) chartView.setChart(chart) def __update_totalChart(self, total_in, total_out): self.createChart( chartView = self.ui.totalView, title = \u0026#39;总收支\u0026#39;, xAxis = [\u0026#39;收入\u0026#39;, \u0026#39;支出\u0026#39;], yAxisList = [ (\u0026#39;金额\u0026#39;, [total_in, total_out]) ] ) def __update_eventChart(self, events): self.createChart( chartView = self.ui.eventView, title = \u0026#39;收支分类\u0026#39;, xAxis = list(events.keys()), yAxisList = [ (\u0026#39;收入\u0026#39;, list(map(lambda x: x[0], events.values()))), (\u0026#39;支出\u0026#39;, list(map(lambda x: x[1], events.values()))) ] ) def __update_dateChart(self, dates): self.createChart( chartView = self.ui.dateView, title = \u0026#39;每日收支\u0026#39;, xAxis = list(dates.keys()), yAxisList = [ (\u0026#39;收入\u0026#39;, list(map(lambda x: x[0], dates.values()))), (\u0026#39;支出\u0026#39;, list(map(lambda x: x[1], dates.values()))) ] ) def __updateCharts(self): startDate = self.ui.startDateEdit.text() endDate = self.ui.endDateEdit.text() left = bisect_left(self.data, startDate, key=lambda x: x[0]) right = bisect_right(self.data, endDate, key=lambda x: x[0]) data = self.data[left:right] self.__update_totalChart(*total(data)) self.__update_eventChart(totalByEvent(data)) self.__update_dateChart(totalByDate(data)) src/main.py\n主程序，同时管理主窗口。最麻烦的地方是QTableView，要同时处理搜索和排序问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 import sys from bisect import insort_right from functools import partial from os.path import basename from webbrowser import open_new_tab from PySide6.QtWidgets import * from PySide6.QtCore import Slot, QDate from PySide6.QtGui import QStandardItem, QStandardItemModel from api import ApiError, openFile, query, saveFile from dlgAdd import dlgAdd from dlgCharts import dlgCharts from ui_dlgHelp import Ui_Dialog as Ui_dlgHelp from ui_MainWindow import Ui_MainWindow # Version info VERSION = \u0026#39;1.0.1\u0026#39; CHANNEL = \u0026#39;stable\u0026#39; BUILD_DATE = \u0026#39;2022-07-01\u0026#39; FULL_VERSION = f\u0026#39;{VERSION}-{CHANNEL} ({BUILD_DATE}) on {sys.platform}\u0026#39; app = QApplication(sys.argv) class AccountBookMainWindow(QMainWindow): version_str = \u0026#39;账本 \u0026#39; + VERSION unsaved_tip = \u0026#39;*\u0026#39; SUPPORTED_FILTERS = \u0026#39;账本文件(*.abf);;文本文件(*.txt);;所有文件(*.*)\u0026#39; def __init__(self, parent=None): # Initialize window super().__init__(parent) self.ui = Ui_MainWindow() self.ui.setupUi(self) self.setWindowTitle(\u0026#39;账本 \u0026#39; + VERSION) self.labStatus = QLabel(self) self.ui.statusBar.addWidget(self.labStatus) # Initialize table self.model = QStandardItemModel(0, 4, self) self.model.setHorizontalHeaderLabels([\u0026#39;日期\u0026#39;, \u0026#39;事项\u0026#39;, \u0026#39;金额\u0026#39;, \u0026#39;备注\u0026#39;]) self.ui.table.setModel(self.model) self.ui.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch) self.__data = [] self.on_actFile_New_triggered() self.ui.actEdit_Remove.setEnabled(False) # Connect slots self.ui.table.selectionModel().selectionChanged.connect(self.__selectionChanged) self.model.itemChanged.connect(self.__itemChanged) def __updateTable(self, data): self.model.itemChanged.disconnect(self.__itemChanged) self.model.setRowCount(len(data)) for row in range(len(data)): for col in range(len(data[row])): self.model.setItem(row, col, QStandardItem(data[row][col])) self.model.itemChanged.connect(self.__itemChanged) def __openFile(self, filename): try: self.__data = openFile(filename) except IOError: QMessageBox.critical(self, \u0026#39;错误\u0026#39;, \u0026#39;文件打开失败。请稍后再试。\u0026#39;) except ApiError: QMessageBox.critical(self, \u0026#39;错误\u0026#39;, \u0026#39;文件格式错误。请检查文件完整性。\u0026#39;) except Exception as e: QMessageBox.critical(self, \u0026#39;错误\u0026#39;, \u0026#39;未知错误：\u0026#39; + str(e.with_traceback())) else: self.ui.searchEdit.clear() self.__key = \u0026#39;\u0026#39; self.__updateTable(self.__data) self.labStatus.setText(filename) self.setWindowTitle(self.version_str) self.__filename = filename def __saveFile(self, filename): try: saveFile(filename, self.__data) except IOError: QMessageBox.critical(self, \u0026#39;错误\u0026#39;, \u0026#39;文件保存错误。请稍后再试。\u0026#39;) except Exception as e: QMessageBox.critical(self, \u0026#39;错误\u0026#39;, \u0026#39;未知错误：\u0026#39; + str(e.with_traceback())) else: self.labStatus.setText(\u0026#39;保存成功：\u0026#39; + filename) self.setWindowTitle(self.version_str) self.__filename = filename @Slot() def on_actFile_New_triggered(self): self.__filename = self.__key = \u0026#39;\u0026#39; self.setWindowTitle(self.unsaved_tip + self.version_str) self.labStatus.setText(\u0026#39;新文件\u0026#39;) self.model.setRowCount(0) self.__data.clear() @Slot() def on_actFile_Open_triggered(self): filename, _ = QFileDialog.getOpenFileName(self, \u0026#39;打开\u0026#39;, filter=self.SUPPORTED_FILTERS) if filename: self.__openFile(filename) @Slot() def on_actFile_Save_triggered(self): if self.__filename: self.__saveFile(self.__filename) else: filename, _ = QFileDialog.getSaveFileName(self, \u0026#39;保存\u0026#39;, filter=self.SUPPORTED_FILTERS) if filename: self.__saveFile(filename) @Slot() def on_actFile_SaveAs_triggered(self): filename, _ = QFileDialog.getSaveFileName(self, \u0026#39;另存为\u0026#39;, filter=self.SUPPORTED_FILTERS) if filename: self.__saveFile(filename) @Slot() def on_actHelp_About_triggered(self): dialog = QDialog(self) ui = Ui_dlgHelp() ui.setupUi(dialog) for link in (ui.githubLink, ui.giteeLink, ui.licenseLink, ui.readmeLink): link.clicked.connect(partial(open_new_tab, link.description())) ui.labVersion.setText(\u0026#39;版本号：\u0026#39; + FULL_VERSION) ui.btnUpdate.clicked.connect(partial(open_new_tab, \u0026#39;https://github.com/GoodCoder666/AccountBook/releases\u0026#39;)) dialog.exec() @Slot() def on_actHelp_AboutQt_triggered(self): QMessageBox.aboutQt(self, \u0026#39;关于Qt\u0026#39;) @Slot() def on_actEdit_Add_triggered(self): dialog = dlgAdd(self) if dialog.exec() == QDialog.Accepted: row = dialog.getRow() insort_right(self.__data, row) self.__updateTable(query(self.__data, self.__key)) self.setWindowTitle(self.unsaved_tip + self.version_str) @Slot() def on_actEdit_Remove_triggered(self): rows = list(set(map(lambda idx: idx.row(), self.ui.table.selectedIndexes()))) for row in rows: self.__data.remove([self.model.item(row, col).text() for col in range(self.model.columnCount())]) self.model.itemChanged.disconnect(self.__itemChanged) self.model.removeRows(rows[0], len(rows)) self.model.itemChanged.connect(self.__itemChanged) self.setWindowTitle(self.unsaved_tip + self.version_str) def __selectionChanged(self): self.ui.actEdit_Remove.setEnabled(self.ui.table.selectionModel().hasSelection()) def __itemChanged(self, item: QStandardItem): i, j, new = item.row(), item.column(), item.text() if (old := self.__data[i][j]) == new: return if j == 0 and not QDate.fromString(new, \u0026#39;yyyy/MM/dd\u0026#39;).isValid(): QMessageBox.critical(self, \u0026#39;错误\u0026#39;, \u0026#39;日期格式错误。\u0026#39;) self.model.itemChanged.disconnect(self.__itemChanged) item.setText(old) self.model.itemChanged.connect(self.__itemChanged) return row = self.__data.pop(i) row[j] = new insort_right(self.__data, row) self.__updateTable(query(self.__data, self.__key)) self.setWindowTitle(self.unsaved_tip + self.version_str) @Slot() def on_searchEdit_textChanged(self): self.__key = self.ui.searchEdit.text() self.__updateTable(query(self.__data, self.__key)) @Slot() def on_actStat_Show_triggered(self): if self.__data: dlgCharts(self.__data, self).exec() else: QMessageBox.information(self, \u0026#39;提示\u0026#39;, \u0026#39;请添加数据以使用统计功能。\u0026#39;) def closeEvent(self, event): if not self.windowTitle().startswith(self.unsaved_tip): return filename = basename(self.__filename) if self.__filename else \u0026#39;新文件\u0026#39; messageBox = QMessageBox( parent=self, icon=QMessageBox.Warning, windowTitle=\u0026#39;提示\u0026#39;, text=f\u0026#39;是否要保存对 {filename} 的更改？\u0026#39;, informativeText=\u0026#39;如果不保存，你的更改将丢失。\u0026#39;, standardButtons=QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel ) messageBox.setButtonText(QMessageBox.Save, \u0026#39;保存\u0026#39;) messageBox.setButtonText(QMessageBox.Discard, \u0026#39;不保存\u0026#39;) messageBox.setButtonText(QMessageBox.Cancel, \u0026#39;取消\u0026#39;) reply = messageBox.exec() if reply == QMessageBox.Save: self.on_actFile_Save_triggered() event.accept() elif reply == QMessageBox.Discard: event.accept() else: event.ignore() def dropEvent(self, event): self.__openFile(event.mimeData().text()[8:]) # [8:] is to get rid of \u0026#39;file:///\u0026#39; mainform = AccountBookMainWindow() mainform.show() sys.exit(app.exec()) 总结\r本项目到此结束。\n【附：项目地址】\nGitHub 地址：https://github.com/GoodCoder666/AccountBook Gitee 镜像地址：https://gitee.com/GoodCoder666/AccountBook 记得点个Star哦~\n创作不易，若您喜欢这篇文章就请点个三连吧！万分感激！！！\n","date":"2022-07-23T08:00:00+08:00","permalink":"https://goodcoder666.github.io/p/pyside6-accountbook/","title":"PyQt6/PySide6：账本项目前端制作【附完整项目地址】"},{"content":"A - A Unique Letter\r题目大意\r给定一个长度为$3$的字符串$S$。\n输出$S$中出现正好一次的字母（任意，如abc中，三个字母都可为答案）。\n如果没有，输出-1。\n数据保证$S$的长为$3$，且由小写英文字母组成。\n输入格式\r$S$\n输出格式\r输出任意符合条件的答案。\n样例\r$S$ 输出 pop o abc a/b/c xxx -1 分析\r我们设输入的3个字母分别为a、b、c。\n首先，如果$a=b=c$，那么输出$-1$。\n其次，我们依次尝试找到两个相同的字母：\nxxy形式（$a=b$）：输出$c$ xyx形式（$a=c$）：输出$b$ yxx形式（$b=c$）：输出$a$ xyz形式（$a\\ne b\\ne c$）：输出任意一个 代码\r这里，我把最后两种情况合并了（一个else搞定，都输出$a$）：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char a = getchar(), b = getchar(), c = getchar(); if(a == b \u0026amp;\u0026amp; b == c) puts(\u0026#34;-1\u0026#34;); else if(a == c) putchar(b); else if(a == b) putchar(c); else putchar(a); return 0; } B - Better Students Are Needed!\r题目大意\r$N$个员工参加了一场选聘考试。\n第$i$个员工数学考了$A_i$分，英语$B_i$分。\n公司按如下的方式选聘员工：\n数学分数在前$X$的被直接录取； 剩下的人中，英语分数在前$Y$的被录取； 最后，总分在前$Z$的被录取，剩下的人被淘汰。 注意：分数相同的员工按编号排序。\n输出被录取的所有员工的编号，按升序排列。\n$1\\le N\\le 1000$\n$0\\le X,Y,Z\\le N$\n$1\\le X+Y+Z\\le N$\n$0\\le A_i,B_i\\le 100$\n输入格式\r$N~X~Y~Z$\n$A_1~A_2~\\dots~A_N$\n$B_1~B_2~\\dots~B_N$\n输出格式\r输出被录取的所有员工的编号，按升序排列，每行一个。\n样例\r略，请自行前往AtCoder查看\n分析\r本题主要有两种思路：\n用pair\u0026lt;int, int\u0026gt;代表一个员工，再使用vector+sort或priority_queue执行三次分别排序数学、英语、总分； 用struct { int math, english, id; }表示员工，存储一次，排序三次（使用不同的排序依据） 详见代码1、代码2。\n代码\r代码1\rvector+sort实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 1005 using namespace std; int a[maxn], b[maxn]; bool used[maxn]; int main() { int n, x, y, z; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;x, \u0026amp;y, \u0026amp;z); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, b + i); // Math vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; sel_a; for(int i=0; i\u0026lt;n; i++) sel_a.emplace_back(-a[i], i); sort(sel_a.begin(), sel_a.end()); for(int i=0; i\u0026lt;x; i++) used[sel_a[i].second] = true; // English vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; sel_b; for(int i=0; i\u0026lt;n; i++) if(!used[i]) sel_b.emplace_back(-b[i], i); sort(sel_b.begin(), sel_b.end()); for(int i=0; i\u0026lt;y; i++) used[sel_b[i].second] = true; // Total vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; sel_t; for(int i=0; i\u0026lt;n; i++) if(!used[i]) sel_t.emplace_back(-(a[i] + b[i]), i); sort(sel_t.begin(), sel_t.end()); for(int i=0; i\u0026lt;z; i++) used[sel_t[i].second] = true; for(int i=0; i\u0026lt;n; i++) if(used[i]) printf(\u0026#34;%d\\n\u0026#34;, i + 1); return 0; } priority_queue实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define maxn 1005 using namespace std; int a[maxn], b[maxn], c[maxn]; bool used[maxn]; inline void selectOnce(int* scores, int n, int snum) { priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; sel; for(int i=0; i\u0026lt;n; i++) if(!used[i]) { sel.emplace(-scores[i], i); if(sel.size() \u0026gt; snum) sel.pop(); } while(!sel.empty()) used[sel.top().second] = true, sel.pop(); } int main() { int n, x, y, z; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;x, \u0026amp;y, \u0026amp;z); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, b + i); for(int i=0; i\u0026lt;n; i++) c[i] = a[i] + b[i]; selectOnce(a, n, x); selectOnce(b, n, y); selectOnce(c, n, z); for(int i=0; i\u0026lt;n; i++) if(used[i]) printf(\u0026#34;%d\\n\u0026#34;, i + 1); return 0; } 代码2\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 1005 using namespace std; struct Emp { // Employee int math, eng, id; } emps[maxn]; inline bool cmp1(const Emp\u0026amp; e1, const Emp\u0026amp; e2) { return e1.math == e2.math? e1.id \u0026lt; e2.id: e1.math \u0026gt; e2.math; } inline bool cmp2(const Emp\u0026amp; e1, const Emp\u0026amp; e2) { return e1.eng == e2.eng? e1.id \u0026lt; e2.id: e1.eng \u0026gt; e2.eng; } inline bool cmp3(const Emp\u0026amp; e1, const Emp\u0026amp; e2) { int tot1 = e1.math + e1.eng, tot2 = e2.eng + e2.math; return tot1 == tot2? e1.id \u0026lt; e2.id: tot1 \u0026gt; tot2; } inline bool cmp4(const Emp\u0026amp; e1, const Emp\u0026amp; e2) { return e1.id \u0026lt; e2.id; } int main() { // Input int n, x, y, z; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;x, \u0026amp;y, \u0026amp;z); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;emps[i].math), emps[i].id = i; for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;emps[i].eng); // Sort auto last = emps + n; sort(emps, last, cmp1); sort(emps + x, last, cmp2); sort(emps + x + y, last, cmp3); sort(emps, emps + x + y + z, cmp4); // 按编号升序排序 // Output for(int i=0; i\u0026lt;x+y+z; i++) printf(\u0026#34;%d\\n\u0026#34;, emps[i].id + 1); return 0; } C - Changing Jewels\r题目大意\rTakahashi有一个$N$级的红色宝石。\n他可以重复下列操作任意次数：\n将一个$N$级的红色宝石转换为“一个$(N-1)$级的红色宝石和$X$个$N$级的蓝色宝石”。 将一个$N$级的蓝色宝石转换为“一个$(N-1)$级的红色宝石和$Y$个$N-1$级的蓝色宝石”。 Takahashi最后最多能得到几个$1$级的蓝色宝石？\n$1\\le N\\le 10$\n$1\\le X,Y\\le 5$\n输入格式\r$N~X~Y$\n输出格式\r输出一个整数，即最终蓝色宝石的数量。\n样例\r$N$ $X$ $Y$ 输出 $2$ $3$ $4$ $12$ $10$ $5$ $5$ $3942349900$ 注意小心$32$位整数（int/int32）溢出。\n分析\r要获得$(N-1)$级的蓝宝石，必须先尽可能多的获得$N$级的蓝宝石。\n而要达到这个目的，就需要有尽可能多的$N$级红宝石。\n以此类推，我们可以按顺序进行操作$1$，操作$2$……直到所有宝石全部为$1$级（也就是循环$(N-1)$次）。维护两个变量$\\text{red}$（初始为$1$）和$\\text{blue}$（初始为$0$），分别表示当前的红、蓝宝石的数目。\n每次循环，先将$\\text{blue}$加上$\\text{red}\\times X$（操作$1$），再将$\\text{red}$加上$\\text{blue}$、$\\text{blue}$乘上$Y$（操作$2$）。\n时间复杂度$\\mathcal O(n)$，如有读不懂的地方，可参考代码。\n代码\r注意使用long long。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n, x, y; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;x, \u0026amp;y); long long red = 1LL, blue = 0LL; while(--n) { blue += red * x; red += blue, blue *= y; } printf(\u0026#34;%lld\\n\u0026#34;, blue); return 0; } D - Draw Your Cards\r题目大意\r有$N$张牌，上面分别写着数字$P_1,P_2,\\dots,P_N$。\n按照这个顺序，我们进行$N$个操作，第$i$个操作的具体步骤如下：\n取出第$i$张牌，令$X=P_i$； 找到存堆中顶牌$~\\ge X$的最小一张，将这张牌置于其上； 如果没有符合条件的牌，将$X$放入一新堆； 当某堆牌数达到$K$时，把这堆的牌全部吃掉。 求每张牌被吃掉的时间（若没有被吃掉，输出-1，详见输出格式）。\n$1\\le K\\le N \\le 2\\times 10^5$\n$P$是$(1,2,\\dots,N)$的一种排列。\n输入格式\r$N~K$\n$P_1~P_2~\\dots~P_N$\n输出格式\r输出$N$行，第$i$行表示卡片$i$被吃掉的时间（如果没被吃掉，输出-1）。\n样例\r略，就是懒\n分析\r首先肯定不能用vector\u0026lt;stack\u0026lt;int\u0026gt;\u0026gt;这种数据结构，效率太低，容易写错，还不好用。可以用一个类似于并查集的数据结构，每次叠放操作都可看作“把下面的牌的父亲设置为上面的牌”。我们还需要记录并查集中每个连通分量的大小，方便模拟“吃掉”操作。\n最终对于每个节点，输出其祖宗被吃掉的时间（咋听起来有点怪）。\n目前的时间复杂度是$\\mathcal O(N^2)$，因为每次操作都需要用$\\mathcal O(n)$的时间，找到最小的符合条件的牌堆。\n很容易想到，可以使用set优化。\nset是自动排序的集合，常用的的操作有插入（insert）、删除（erase）、二分查找（lower_bound/upper_bound），一次操作的时间复杂度均为$\\mathcal O(\\log n)$。\n这时，使用一个set\u0026lt;int\u0026gt;维护每个堆顶的卡牌编号，就可以把时间复杂度降到$\\mathcal O(n\\log n)$以内。\n至此，此题完。注意对$K=1$的特判。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 200005 using namespace std; int fa[maxn], eat[maxn], sz[maxn]; int find(int x) { return fa[x] == x? x: fa[x] = find(fa[x]); } int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); set\u0026lt;int\u0026gt; cards; for(int i=0; i\u0026lt;n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); x --; eat[x] = -1, fa[x] = x; if(k == 1) { eat[x] = i + 1; continue; } auto it = cards.upper_bound(x); if(it == cards.end()) cards.insert(x), sz[x] = 1; else { fa[*it] = x; cards.erase(it); if((sz[x] = sz[*it] + 1) == k) eat[x] = i + 1; else cards.insert(x); } } for(int i=0; i\u0026lt;n; i++) printf(\u0026#34;%d\\n\u0026#34;, eat[find(i)]); return 0; } E - At Least One\r题目大意\r给定整数$M$和$N$对整数：$(A_1,B_1),(A_2,B_2),\\dots,(A_N,B_N)$。\n题目保证对于任意$i$，$1\\le A_i \u003c B_i\\le M$。\n符合如下条件的整数序列$S$被称作好的序列：\n$S$是$(1,2,\\dots,M)$的连续子序列； 对于每个$i$，$S$中包含$A_i$或$B_i$（或同时包含）。 令$f(k)=($长为$k$的好序列的个数$)$。求$f(1),f(2),\\dots,f(M)$。\n$1\\le N\\le 2\\times 10^5$\n$2\\le M\\le 2\\times 10^5$\n$1\\le A_i \u003c B_i\\le M$\n输入格式\r$N~M$\n$A_1~B_1$\n$A_2~B_2$\n$\\vdots$\n$A_N~B_N$\n输出格式\r输出一行，即$f(1),f(2),\\dots,f(M)$，用空格分隔。\n样例\r略，请自行前往AtCoder查看\n分析\r首先，根据题意，$S$可被表示为一个区间$[l,r]$，其中$1\\le l\\le r\\le M$。\n当对于每个$i$，$l\\le A_i\\le r$或$l\\le B_i\\le r$时，区间$[l,r]$符合条件。\n若按这样直接暴力枚举，时间复杂度为$\\mathcal O(N^2M)$，明显超时，不可取。\n仔细想想会发现，对于两个区间$[l,r]$和$[a,b]$，若$a\\le l\\le r\\le b$，且$[l,r]$符合条件，则$[a,b]$也肯定符合条件。\n此时，可以考虑使用滑动窗口优化，则时间复杂度降至$\\mathcal O(MN)$。\n继续优化。在窗口滑动的过程中，每次移动左/右端点时考虑一次移动对当前符合条件的$i$的数量的贡献，需要两个数组$\\mathrm{cnt}[N]$（记录每个$A_i$和$B_i$符合条件的个数）和$\\mathrm{inv}[M+1][\\dots]$（预处理每个数值对应的所有元素下标）。\n总时间复杂度为$\\mathcal O(N+M)$，详见代码。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 200005 using namespace std; vector\u0026lt;int\u0026gt; inv[maxn]; int cnt[maxn], ans[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;n; i++) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); inv[a].push_back(i); inv[b].push_back(i); } int left = n; for(int i=1, j=1; i\u0026lt;=m; i++) { for(; j \u0026lt;= m \u0026amp;\u0026amp; left \u0026gt; 0; j++) for(int x: inv[j]) if(++cnt[x] == 1) left --; if(left \u0026gt; 0) break; ans[j - i] ++, ans[m - i + 2] --; for(int x: inv[i]) if(--cnt[x] == 0) left ++; } for(int i=1; i\u0026lt;=m; i++) printf(\u0026#34;%d \u0026#34;, ans[i] += ans[i - 1]); return 0; } F - Find 4-cycle\r给定一个二分图$G$，形如下：\n图片来源：二分图_百度百科\r其中顶点集$U$中的顶点数为$S$，$V$的顶点数为$T$，总边数为$M$（第$i$条边连接$u_i$和$v_i$）。\n请找出此图中任意长为$4$的环。如果没有，输出-1。\n$2\\le S\\le 3\\times 10^5$\n==$2\\le T\\le 3000$==\n$4\\le M\\le \\min(S\\times T,3\\times 10^5)$\n$1\\le u_i\\le S \u003c v_i\\le S+T$\n输入格式\r$S~T~M$\n$u_1~V_1$\n$u_2~V_2$\n$\\vdots$\n$u_M~V_M$\n输出格式\r如果有长为$4$的环，输出其中四个顶点的编号（顺序随意，用空格分隔）。\n如果没有，输出-1。\n样例\r略，请自行前往AtCoder查看\n分析\r注意到样例中$T$只有$3000$，$\\mathcal O(T^2)=9\\times 10^6$可以接受。\n然后因为是二分图，所以长为$4$的环肯定是在两个顶点集中各有两个点。\n令$f(x,y)$为目前发现的与点$x,y$都相连的点，初始化为$-1$（表示未发现）。\n输入使用邻接表存储，$G[v]$存储连到$v$的所有点，注意只需存顶点集$U$的$G[v]$即可。\n再对于每个$v$，依次枚举$G[v]$中的两个点$(x,y)$，如果$f(x,y)=-1$，则执行$f(x,y):=v$，如果不是$-1$，则输出{x} {y} {v} {f(x,y)}，结束程序。\n时间复杂度约为$\\mathcal O(T^2)$。\n本题中的时间复杂度怎么算？\n$\\to f(x,y)$中不同$(x,y)$的组合只有$T(T-1)=T^2-T\\approx T^2$种。\n$\\to~$ 根据鸽笼原理（又称抽屉原理），在最坏情况下，$T^2$种组合都记录过$f$之后，下一种组合无论是什么肯定都已经记录过$f$，因此最坏时间复杂度为$\\mathcal O(T^2)$，对于随机数据的平均时间复杂度远远小于这个值。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #define maxs 300005 #define maxt 3005 using namespace std; vector\u0026lt;int\u0026gt; G[maxs]; int f[maxt][maxt]; int main() { int s, t, m; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;s, \u0026amp;t, \u0026amp;m); while(m--) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[--u].push_back(--v - s); } memset(f, -1, sizeof(f)); for(int i=0; i\u0026lt;s; i++) for(int j=0; j+1\u0026lt;G[i].size(); j++) for(int k=j+1; k\u0026lt;G[i].size(); k++) { int u = G[i][j], v = G[i][k]; if(u \u0026gt; v) u ^= v ^= u ^= v; if(f[u][v] != -1) { printf(\u0026#34;%d %d %d %d\\n\u0026#34;, f[u][v] + 1, i + 1, u + s + 1, v + s + 1); return 0; } f[u][v] = i; } puts(\u0026#34;-1\u0026#34;); return 0; } ","date":"2022-07-19T20:31:00+08:00","permalink":"https://goodcoder666.github.io/p/abc260/","title":"AtCoder Beginner Contest 260 A~F 题解"},{"content":"D - Trophy\r题目大意\r有一个游戏，由$N$个关卡组成。第$i$个关卡由一个数对$(A_i,B_i)$组成。\n要通过一个关卡，你必须先花$A_i$的时间看一次介绍。然后，用$B_i$的时间打通这个关卡。若想多次通过同一个关卡，则第一次需要看介绍，后面无需再看（即如果想打通第$i$关$N$次，则所需时间为$A_i+N\\times B_i$）。\n开始时，只有第一关被解锁。当你每打通一关，其下一关会自动解锁（最后一关除外）。求总共打通$X$关的最少时间（重复通关也算）。\n$1\\le N\\le 2\\times 10^5$\n$1\\le A_i,B_i\\le 10^9$\n$1\\le X\\le N$\n输入格式\r$N~X$\n$A_1~B_1$\n$\\vdots$\n$A_N~B_N$\n输出格式\r输出答案。\n样例\r略，请自行前往AtCoder查看。\n分析\r仔细想想会发现，通过的方式都是先不重复通过某一关前所有关卡，再通过这一关一定次数，最终达到正好$X$次。因此，我们利用前缀和，依次枚举每个关卡，最终时间复杂度可达$\\mathcal O(n)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define INF 0x7FFFFFFFFFFFFFFFLL using namespace std; int main() { int n, x; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;x); if(x \u0026lt; n) n = x; long long s = 0LL, ans = INF, cur; for(int i=1; i\u0026lt;=n; i++) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); if((cur = (s += a + b) + (long long)(x - i) * b) \u0026lt; ans) ans = cur; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } E - Packing Potatoes\r题目大意\r$10^{100}$个土豆排成一列。它们的重量分别是$W_0,W_1,\\dots,W_{N-1},W_0,\\dots$，即第$i$个土豆的重量是$W_{i\\bmod N}$（$i=0,1,2,\\dots$）。\nTakahashi会往一个盒子里依次放入每个土豆，当放入的土豆总重量$~\\ge X$的时候他会换一个新盒子。\n给定$Q$个询问。第$i$个询问：给定整数$K_i$，求第$K_i$个盒子中土豆的个数。\n$1\\le N,Q\\le 2\\times 10^5$\n$1\\le X,W_i\\le 10^9$\n$1\\le K_i\\le 10^{12}$\n输入格式\r$N~Q~X$\n$W_0~\\dots~W_{N-1}$\n$K_1$\n$\\vdots$\n$K_Q$\n输出格式\r输出$Q$行，第$i$行是第$i$个询问的答案。\n样例\r略，请自行前往AtCoder查看。\n分析\r周期问题。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 200005 using namespace std; using LL = long long; int cnt[maxn], ord[maxn], w[maxn \u0026lt;\u0026lt; 1]; template \u0026lt;typename T\u0026gt; inline T read() { char c; while((c = getchar()) \u0026lt; \u0026#39;0\u0026#39; || c \u0026gt; \u0026#39;9\u0026#39;); T res = c ^ 48; while((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) res = (res \u0026lt;\u0026lt; T(3)) + (res \u0026lt;\u0026lt; T(1)) + (c ^ 48); return res; } inline void print(int x) { if(x \u0026gt; 9) print(x / 10); putchar(x % 10 ^ 48); } inline void println(int x) { print(x); putchar(\u0026#39;\\n\u0026#39;); } int main() { int n = read\u0026lt;int\u0026gt;(), q = read\u0026lt;int\u0026gt;(), x = read\u0026lt;int\u0026gt;(); LL sum = 0LL; for(int i=0; i\u0026lt;n; i++) sum += w[i + n] = w[i] = read\u0026lt;int\u0026gt;(); int fill = x / sum * n; for(int i=0; i\u0026lt;n; i++) cnt[i] = fill, ord[i] = -1; x %= sum; for(int i=0, j=0, s=0; i\u0026lt;n; i++) { if(j \u0026lt; i) j = i, s = 0; while(s \u0026lt; x) { s += w[j]; j += 1; } cnt[i] += j - i; s -= w[i]; } vector\u0026lt;int\u0026gt; path; int loop = -1; for(int u=0, k=0; ; k++) { if(ord[u] != -1) { loop = k - ord[u]; break; } ord[u] = k; path.push_back(u); (u += cnt[u]) %= n; } int non_loop = path.size() - loop; while(q--) { LL k = read\u0026lt;LL\u0026gt;(); println(cnt[path[--k \u0026lt; non_loop? k: non_loop + (k - non_loop) % loop]]); } return 0; } F - Main Street\rWJ...\nG - Triangle\r题目大意\r给定一张由$N$个点组成的简单无向图$G$和它的邻接矩阵$A$。\n什么是邻接矩阵 ？\n邻接矩阵，顾名思义，即表示图中每两点之间关系的矩阵。 如本题中$A_{i,j}$表示$i,j$两点之间是否有边。$A_{i,j}=0$表示无边，$1$表示有边。 一般来说，对于任意简单无向图，$A_{i,i}=0$，$A_{i,j}=A_{j,i}$ ($i\\ne j$)。 求数对$(i,j,k)$的个数，使得：\n$1\\le i \u003c j \u003c k\\le N$ $(i,j,k)$三个点在图中组成一个三角形，即$i,j,k$中任意两点之间有一条连边。 $3\\le N\\le 3000$\n输入格式\r$N$\n$A_{1,1}A_{1,2}\\dots A_{1,N}$\n$A_{2,1}A_{2,2}\\dots A_{2,N}$\n$\\vdots$\n$A_{N,1}A_{N,2}\\dots A_{N,N}$（注意没有空格，如10110）\n输出格式\r输出一个整数，即符合条件的数对$(i,j,k)$的个数。\n样例\r略，请自行前往AtCoder查看。\n分析\r前言\n个人感觉这题其实是这场比赛中最有意思的题。题目不难，但很具有研究意义。\n这里我将从各个角度分析题目，也期待大家在评论区中分享其他方法。 废话不多说，题解开始！\n题目说得太啰嗦，其实不用管什么图论，可以看成是给定$N\\times N$的$01$矩阵$A$，求$A_{i,j}=A_{i,k}=A_{j,k}=1$的$(i,j,k)$的个数。\n再来看数据范围。$N\\le 3000$，则$\\mathcal O(N^3)$的朴素算法时间可达到$T(2.7\\times 10^{10})$，显然无法通过。\n然而，事实并非如此。\n在仔细研究后发现，时间限制为$3\\mathrm{s}$的题目可以使用复杂度稍高的算法。\n但是一般来说，极端情况下超过$T(10^{10})$的算法无法通过。\n因此，也许是数据不够强吧，使用如下的优化可以恰好通过（#32949139 $37764\\mathrm{KB},2755 \\mathrm{ms}$）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) // -Ofast 预编译优化 #include \u0026lt;cstdio\u0026gt; #define maxn 3000 // 数组大小设置正好，减少内存占用 using namespace std; // 题目中正常的邻接矩阵 bool a[maxn][maxn]; // 特殊邻接表存储，减少尝试次数 // 这里不使用vector，会拖慢速度 int G[maxn][maxn], sz[maxn]; inline void print(const long long\u0026amp; x) // 快写-输出优化 { if(x \u0026gt; 9LL) print(x / 10); putchar(x % 10 ^ 48); } int main() { // getchar快读输入优化 int n = 0; char c; while((c = getchar()) != \u0026#39;\\n\u0026#39;) n = (n \u0026lt;\u0026lt; 3) + (n \u0026lt;\u0026lt; 1) + (c ^ 48); for(int i=0; i\u0026lt;n; i++, getchar()) for(int j=0; j\u0026lt;n; j++) if(getchar() == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; j \u0026gt; i) // j \u0026gt; i：只存一半，去掉重复 a[i][j] = 1, G[i][sz[i]++] = j; // 注意答案数据类型使用long long long long ans = 0LL; for(int v=0; v\u0026lt;n; ++v) for(int i=0; i\u0026lt;sz[v]; ++i) // 直接调取邻接表，省去不必要判断 { int u = G[v][i]; for(int j=0; j\u0026lt;sz[u]; ++j) if(a[v][G[u][j]]) ans ++; } print(ans); return 0; } 当然，这种方法并非每道题都能用，因此还是建议大家继续看正解。\n正解还是基于上面的朴素算法，可看作：\n依次遍历$A_{i,j}=1$的$(i,j)$（$i \u003c j$） =\u0026gt; 将答案加上$A[i]$和$A[j]$对应位置上都是$1$的位置个数 输出答案，除以3（去掉每个重复算的三次） 那么别的地方都没办法，只有第二步可以使用bitset的并集(\u0026amp;)操作进行优化。此时时间复杂度为$\\mathcal O(\\frac{n^3}w)$，其中$w=64$。详见代码。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;bitset\u0026gt; #define maxn 3000 using namespace std; bitset\u0026lt;maxn\u0026gt; a[maxn]; int main() { int n = 0; char c; while((c = getchar()) != \u0026#39;\\n\u0026#39;) n = (n \u0026lt;\u0026lt; 3) + (n \u0026lt;\u0026lt; 1) + (c ^ 48); for(int i=0; i\u0026lt;n; i++, getchar()) for(int j=0; j\u0026lt;n; j++) if(getchar() == \u0026#39;1\u0026#39;) a[i].set(j); // a[i][j] = 1 long long ans = 0LL; for(int i=0; i+1\u0026lt;n; i++) for(int j=i+1; j\u0026lt;n; j++) if(a[i][j]) ans += (a[i] \u0026amp; a[j]).count(); // 取交集，数1的个数 printf(\u0026#34;%lld\\n\u0026#34;, ans / 3LL); return 0; } ","date":"2022-07-04T22:15:00+08:00","permalink":"https://goodcoder666.github.io/p/abc258/","title":"AtCoder Beginner Contest 258 A~Ex 题解"},{"content":"A - Last Two Digits\r题目大意\r给定正整数$N$，求$N$的后两位。\n$100\\le N\\le 999$\n输入格式\r$N$\n输出格式\r输出$N$的后两位，注意输出可能有前导0。\n样例\r$N$ 输出 $254$ 54 $101$ 01 分析\r题目已经规定$N$是三位数，因此无需使用整数输入，直接将输入看成字符串，输出后两位即可。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { getchar(); putchar(getchar()); putchar(getchar()); return 0; } B - Practical Computing\r题目大意\r输出$N$个整数序列$A_0,\\dots,A_{N-1}$。它们按如下定义：\n$A_i$的长为$i+1$。 $A_i$的第$j+1$个元素记为$a_{i,j}$（$0\\le j\\le i \u003c N$），即： 当$j=0$或$j=i$时，$a_{i,j}=1$； 否则，$a_{i,j}=a_{i-1,j-1}+a_{i-1,j}$。 $1\\le N\\le 30$\n输入格式\r$N$\n输出格式\r输出$N$行。第$i$行上有$A_{i-1}$中的$i$个数，用空格分隔。\n样例\r样例输入1\r1 3 样例输出1\r1 2 3 1 1 1 1 2 1 样例输入2\r1 10 样例输出2\r1 2 3 4 5 6 7 8 9 10 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 分析\r其实不用读题，看一眼样例，是不是很眼熟？没错，就是著名的杨辉三角。\n不知道也没关系（不过应该也没人不知道），直接按题目要求（$i,j$正序）依次计算即可。时间复杂度$\\mathcal O(n^2)$，空间复杂度$\\mathcal O(n)$或$\\mathcal O(n^2)$。详见代码$1,2$。\n继续考虑，杨辉三角中$a_{i,j}=C_j^i$，所以可以用$\\mathcal O(1)$的空间计算，时间不变，代码待会补。\n代码\r代码$1$（普通方法+无优化+cin/cout，$7\\text{ms}~3604\\text{KB}$）\n时间：$\\mathcal O(n^2)$\n空间：$\\mathcal O(n^2)$\n难度：低 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; int arr[35][35]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { arr[i][0] = 1; arr[i][i] = 1; } for (int i = 2; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt; i; j++) { arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j]; } } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt;= i; j++) { cout \u0026lt;\u0026lt; arr[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } return 0; } 代码$2$（普通方法+滚动表+scanf/printf，$6\\text{ms}~1656\\text{KB}$）\n时间：$\\mathcal O(n^2)$\n空间：$\\mathcal O(n)$\n难度：中低 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;cstdio\u0026gt; using namespace std; int a[35]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); a[0] = 1, puts(\u0026#34;1\u0026#34;); for(int i=1; i\u0026lt;n; i++) { putchar(\u0026#39;1\u0026#39;); for(int j=i-1; j\u0026gt;0; j--) a[j] += a[j - 1]; for(int j=1; j\u0026lt;i; j++) printf(\u0026#34; %d\u0026#34;, a[j]); a[i] = 1, puts(\u0026#34; 1\u0026#34;); } return 0; } C - K Swap\r题目大意\r给定长度为$N$的序列$A=(a_1,a_2,\\dots,a_N)$和整数$K$，你可以重复下列操作任意次：\n选择整数$1\\le i\\le N-K$，交换$a_i$和$a_{i+K}$。 问：是否能通过上述操作将$A$按升序排列？\n$2\\le N\\le 2\\times 10^5$\n$1\\le K\\le N-1$\n$1\\le a_i\\le 10^9$\n输入格式\r$N~K$\n$a_1~\\dots~a_N$\n输出格式\r如果可以达到目标，输出Yes；否则，输出No。\n样例\r样例输入1\r1 2 5 2 3 4 1 3 4 样例输出1\r1 Yes 该样例中，$A=(3,4,1,3,4),K=2$。一种完成任务的操作如下：\n交换$a_1$和$a_3$，此时$A=(1,4,3,3,4)$； 交换$a_2$和$a_4$，此时$A=(1,3,3,4,4)$，排序完成。 样例输入2\r1 2 5 3 3 4 1 3 4 样例输出2\r1 No $K=3$，无法将$A$排序。\n样例输入3\r1 2 7 5 1 2 3 4 5 5 10 样例输出3\r1 Yes 可以不进行操作。\n分析\r题目可以看成：在$a_i,a_{K+i},a_{2K+i},\\dots$（$1\\le i \u003c K$）中的元素是可以两两相邻交换的。那么，根据冒泡排序的原理，这些元素是可以直接排序并放入原位置上的。此时，只需依次对于$i=1,2,\\dots,K-1$的上述序列并排序、放回原位，最终检查是否已被排成升序即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 200005 using namespace std; int a[maxn], b[maxn]; int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d\u0026#34;, a + i); b[i] = a[i]; } sort(b, b + n); for(int i=0; i\u0026lt;k; i++) { multiset\u0026lt;int\u0026gt; s1, s2; for(int j=i; j\u0026lt;n; j+=k) { s1.insert(a[j]); s2.insert(b[j]); } if(s1 != s2) { puts(\u0026#34;No\u0026#34;); return 0; } } puts(\u0026#34;Yes\u0026#34;); return 0; } 特别: 本题涉及到很多数组操作，使用Python代码量非常小（使用数组切片和sorted()），所以也是一道很好的Python数组练习题。因此，这里破例提供Python示例代码：\n1 2 3 4 5 n, k = map(int, input().split()) a = list(map(int, input().split())) for i in range(k): a[i::k] = sorted(a[i::k]) print(\u0026#39;Yes\u0026#39; if a == sorted(a) else \u0026#39;No\u0026#39;) D - Together Square\r题目大意\r给定整数$N$。求正整数对$(i,j)$的个数，满足：\n$1\\le i,j\\le N$ $i\\times j$是一个完全平方数（即$1^2,2^2,3^2,\\dots$） $1\\le N\\le 2\\times 10^5$\n输入格式\r$N$\n输出格式\r输出答案。\n样例\r$N$ 输出 $4$ $6$ $254$ $896$ 分析\r注意$N$较大，所以最容易想到的$\\mathcal O(n^2)$暴力枚举肯定是不行的，然后仔细思考后发现可以枚举整数对$(x,y)$（$1\\le x,y\\le\\lfloor\\sqrt N\\rfloor$），当$x,y$互质时将答案加上$\\frac N {\\max\\{x^2,y^2\\}}$，这样答案正确，建议读者自行思考原因。\n时间复杂度计算：\n循环（次数$\\sqrt N$，枚举$x$） 循环（次数$\\sqrt N$，枚举$y$） gcd最大公约数算法（辗转相除法$\\log\\max\\{x,y\\}\\approx\\log\\sqrt N$，判断互质） 综上，总时间复杂度为$\\mathcal O(\\sqrt N\\times\\sqrt N\\times\\log\\sqrt N)=\\mathcal O(N\\log\\sqrt N)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;cstdio\u0026gt; using namespace std; inline int gcd(int a, int b) { while(b ^= a ^= b ^= a %= b); return a; } int main() { int n = 0; char c; while((c = getchar()) != \u0026#39;\\n\u0026#39;) n = (n \u0026lt;\u0026lt; 3) + (n \u0026lt;\u0026lt; 1) + (c ^ 48); int t = __builtin_sqrt(n); long long ans = 0LL, x; for(int i=1; i\u0026lt;=t; i++) for(int j=i; j\u0026lt;=t; j++) if(gcd(i, j) == 1) { ans += (x = n / (i \u0026gt; j? i * i: j * j)); if(i != j) ans += x; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } E - Small d and k\r题目大意\r给定一个由$N$个点和$M$条边组成的简单无向图。\n对于每个$i=1,2,\\dots,M$，第$i$条边连接顶点$a_i$和$b_i$。\n已知 ==每个顶点的度数不超过3==，回答下列$Q$个查询，第$i$个查询为：\n求与顶点$x_i$距离不超过$k_i$的点的下标之和。 $1\\le N,Q\\le 1.5\\times 10^5$\n$0\\le M\\le \\min\\{\\frac{N(N-1)}2,\\frac32N\\}$\n$1\\le a_i \u003c b_i\\le N$，$(a_i,b_i)$互不相同。\n$1\\le x_i\\le N$，==$0\\le k_i\\le 3$==\n输入格式\r$N~M$\n$a_1~b_1$\n$\\vdots$\n$a_M~b_M$\n$Q$\n$x_1~k_1$\n$\\vdots$\n$x_Q~k_Q$\n输出格式\r输出$Q$行。第$i$行应包含第$i$个查询的答案。\n样例\r样例输入\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 6 5 2 3 3 4 3 5 5 6 2 6 7 1 1 2 2 2 0 2 3 4 1 6 0 4 3 样例输出\r1 2 3 4 5 6 7 1 20 2 20 7 6 20 样例解释：AtCoder 254E - Small d and k #sample\n分析\r注意这题数据范围，这是解体的关键：\n减少算法耗时： $0\\le k\\le 3$ 顶点度数$~\\le3$ 根据乘法原理，一次查询最大符合条件的顶点数为$3^3+1=28$个 防止常数问题： $1\\le N\\le \\textbf{1.5}\\times 10^5$ 时间限制$3.5\\text{s}$ 因此，使用简单的暴力$\\text{BFS}$正好符合题目数据范围。详见代码。\n代码\r注意dis数组的清零操作，无需全部清零，只需把刚刚改过的清零即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define maxn 150005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; int dis[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); G[a].push_back(b); G[b].push_back(a); } int Q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;Q); for(int i=1; i\u0026lt;=n; i++) dis[i] = -1; while(Q--) { int x, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;k); vector\u0026lt;int\u0026gt; ans; queue\u0026lt;int\u0026gt; q; q.push(x); dis[x] = 0; while(!q.empty()) { int v = q.front(); q.pop(); int d = dis[v]; if(d \u0026lt;= k) ans.push_back(v); if(++d \u0026gt; k) continue; for(int u: G[v]) if(dis[u] == -1) { dis[u] = d; q.push(u); } } int res = 0; for(int v: ans) res += v, dis[v] = -1; printf(\u0026#34;%d\\n\u0026#34;, res); } return 0; } ","date":"2022-06-04T22:41:00+08:00","permalink":"https://goodcoder666.github.io/p/abc254/","title":"AtCoder Beginner Contest 254 A~E 题解"},{"content":"A - Median?\r题目大意\r给定正整数$a,b,c$，判断$b$是否为三个数中的中位数（即从小到大排序后是第二个，不是平均数）。\n$1\\le a,b,c\\le 100$\n输入格式\r$a~b~c$\n输出格式\r如果$b$是三个数中的中位数，输出Yes；否则，输出No。\n样例\r$a$ $b$ $c$ 输出 $5$ $3$ $2$ Yes $2$ $5$ $3$ No $100$ $100$ $100$ No 分析\r本来就是A题，其实没什么难的，比赛的时候就是看成平均数WA了..（上面应该讲的够清楚了）\n当然可以直接将三个数排序（简单粗暴），也可以判断$a\\le b\\le c$和$c\\le b\\le a$中是否有至少一个成立。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); puts((a \u0026lt;= b \u0026amp;\u0026amp; b \u0026lt;= c) || (c \u0026lt;= b \u0026amp;\u0026amp; b \u0026lt;= a)? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Distance Between Tokens\r题目大意\r在$H\\times W$的网格上，有恰好两个位置上各有一颗棋子，别的都是空位。\n你可以从任意一个棋子开始，通过上下左右移动，前往另一个棋子的位置。\n求至少要移动多少次？\n输入格式\r先是一行$H,W$，用空格隔开，然后有$H$行，每行是一个长度为$W$的字符串，-表示这个位置是空位，o表示这里有一颗棋子（详见样例）。\n输出格式\r输出一行，即至少要移动的次数。\n样例\r样例输入1\r1 2 3 2 3 --o o-- 样例输出1\r1 3 样例输入2\r1 2 3 4 5 6 5 4 -o-- ---- ---- ---- -o-- 样例输出2\r1 4 分析\r本题不需要$\\text{BFS}$，由于没有障碍物，直接找到两颗棋子，并输出$x_\\text{diff}+y_\\text{diff}$（即$x,y$的坐标差之和）即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { int h = 0, w = 0, x1 = -1, y1 = -1, x2 = -1, y2 = -1; char c; while((c = getchar()) != \u0026#39; \u0026#39;) h = (h \u0026lt;\u0026lt; 3) + (h \u0026lt;\u0026lt; 1) + (c ^ 48); while((c = getchar()) != \u0026#39;\\n\u0026#39;) w = (w \u0026lt;\u0026lt; 3) + (w \u0026lt;\u0026lt; 1) + (c ^ 48); for(; h--; getchar()) for(int i=w; i--; ) if(getchar() == \u0026#39;o\u0026#39;) if(x1 == -1) x1 = h, y1 = i; else { x2 = h, y2 = i; break; } printf(\u0026#34;%d\\n\u0026#34;, x1 - x2 + (y1 \u0026gt; y2? y1 - y2: y2 - y1)); return 0; } C - Max - Min Query\r题目大意\r我们有一个序列$S$，初始为空。\n请处理如下$Q$个操作：\n1 x：将$x$插入至$S$的末尾。 2 x c：从$S$中删除$c$个$x$，如果不够删就直接删完。 3：求$S$中最大值与最小值的差。 $1\\le Q\\le 2\\times 10^5$\n$0\\le x\\le 10^9$\n$1\\le c\\le Q$\n输入格式\r$Q$\n$\\text{query}_1$\n$\\text{query}_2$\n$\\vdots$\n$\\text{query}_Q$\n输出格式\r对于每个操作$3$，输出$S$中最大值与最小值的差。\n分析\r典型STL练习题\n本题可以用multiset或map解决，这里介绍使用map的方法（仅限C++使用）。\nC++中，我们需要用到std::map\u0026lt;int, int\u0026gt;的如下方法：\nmp[x]或int\u0026amp; operator[](int\u0026amp;\u0026amp; key)\n返回key对应的value的引用，如果之前没有用到过则创建并返回$0$。\n时间复杂度：$\\mathcal O(\\log n)$，其中$n$为map中元素总数。 iterator begin()\n返回最小的元素对应的指针，mp.begin()-\u0026gt;first可以获得mp的最小元素\n时间复杂度：$\\mathcal O(1)$ iterator rbegin()\n返回最大的元素对应的指针，mp.rbegin()-\u0026gt;first可以获得mp的最大元素\n时间复杂度：$\\mathcal O(1)$ size_type erase(const int\u0026amp; key)\n将key以及对应的value从map中删除，返回删除的元素个数（$0$或$1$），返回值一般可以忽略。\n时间复杂度：$\\mathcal O(\\log n)$，其中$n$为map中元素总数。 这时，每个查询都可转换为上述操作，详见代码。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; int main() { int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); map\u0026lt;int, int\u0026gt; cnt; while(q--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if(op == 3) printf(\u0026#34;%d\\n\u0026#34;, cnt.rbegin()-\u0026gt;first - cnt.begin()-\u0026gt;first); else if(op == 1) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); cnt[x] ++; } else if(op == 2) { int x, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;m); if(cnt[x] \u0026gt; m) cnt[x] -= m; else cnt.erase(x); } } return 0; } D - FizzBuzz Sum Hard\r题目大意\r输出$1$到$N$之间不是$A$或$B$的倍数的数之和。\n$1\\le N,A,B\\le 10^9$\n输入格式\r$N~A~B$\n输出格式\r输出答案。\n分析\r根据容斥原理，$1$到$N$之间是$A$或$B$的倍数的数之和为：\n$(A$的倍数之和$)+(B$的倍数之和$)-($同时为$A,B$的倍数之和$)$。\n又因为同时为$A,B$的倍数的数是$[A,B]$（最小公倍数）的倍数，所以可转化为$(A$的倍数之和$)-(B$的倍数之和$)+([A,B]$的倍数之和$)$。\n$$\\text{Ans}=f(N)-g(A)-g(B)+g([A,B])$$\n总时间复杂度为求解$[A,B]$的复杂度，即$\\mathcal O(\\log \\max\\{A,B\\})$。\n代码\r这里使用了另一种$g(x,N)$的求法，思路类似。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; using namespace std; using LL = long long; inline LL sum(const LL\u0026amp; x, const LL\u0026amp; n) { LL cnt = n / x; return x * cnt * (cnt + 1LL) \u0026gt;\u0026gt; 1LL; } int main() { int n, a, b; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;a, \u0026amp;b); LL x = b, y = a; while(b ^= a ^= b ^= a %= b); LL t = x / a * y; // t = lcm(a, b) printf(\u0026#34;%lld\\n\u0026#34;, sum(1, n) - sum(x, n) - sum(y, n) + sum(t, n)); return 0; } E - Distance Sequence\r题目大意\r求符合如下条件的$A=(A_1,\\dots,A_N)$的个数，对$998244353$取模：\n$1\\le A_i\\le M$（$1\\le i\\le N$） $|A_i-A_{i+1}|\\ge K$（$1\\le i \u003c N$） $2\\le N\\le 1000$\n$1\\le M\\le 5000$\n$0\\le K \u003c M$\n输入格式\r$N~M~K$\n输出格式\r输出符合条件的序列的个数，对$998244353$取模。\n分析\r$$\\text{dp}(i,j)=(A_i=j\\text{的可能数})$$$$\\text{dp}(i,j)=\\sum_{p=1}^{j-k}\\text{dp}(i-1,p)+\\sum_{p=j+k}^m\\text{dp}(i-1,p)$$\n那么，如果直接暴力循环计算，整个算法的时间复杂度是$\\mathcal O(NM^2)$，显然不能通过。\n但是注意到这里有个求和的操作，显然可以用前缀/后缀和优化，用$\\mathcal O(1)$的时间复杂度求出两个和，因此时间复杂度降到$\\mathcal O(NM)$，可以通过。\n最后一个坑，需要注意特判$K=0$的情况，答案为$M^N\\bmod 998244353$。\n本题到此结束。\n代码\r特判使用快速幂，$\\text{DP}$建议使用滚动表（又称数组重复利用）技巧，优化后实测：\n时间：$49\\mathrm{ms}\\to39\\mathrm{ms}$ 空间：$21220\\mathrm{kb}\\to1664\\mathrm{kb}$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;cstdio\u0026gt; #define maxn 1002 #define maxm 5005 #define MOD 998244353 using namespace std; using LL = long long; int qpow(LL a, LL b) { LL ans = 1LL; while(b \u0026gt; 0) { if(b \u0026amp; 1LL) ans = ans * a % MOD; a = a * a % MOD, b \u0026gt;\u0026gt;= 1LL; } return ans; } inline void mod(int\u0026amp; x) { if(x \u0026gt;= MOD) x -= MOD; } int dp[2][maxm]; int main() { int n, m, k; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); if(k == 0) { printf(\u0026#34;%d\\n\u0026#34;, qpow(m, n)); return 0; } for(int i=1; i\u0026lt;=m; i++) dp[0][i] = 1; for(int i=1; i\u0026lt;n; i++) { int c = i \u0026amp; 1, p = c ^ 1, s = 0; for(int j=k+1; j\u0026lt;=m; j++) mod(s += dp[p][j]); for(int j=1; j\u0026lt;=m; j++) { if(j \u0026gt; k) mod(s += dp[p][j - k]); mod(dp[c][j] = s); if(j + k \u0026lt;= m) { mod(s -= dp[p][j + k]); if(s \u0026lt; 0) s += MOD; } } } int ans = 0, t = n \u0026amp; 1 ^ 1; for(int i=1; i\u0026lt;=m; i++) mod(ans += dp[t][i]); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","date":"2022-05-29T16:07:00+08:00","permalink":"https://goodcoder666.github.io/p/abc253/","title":"AtCoder Beginner Contest 253 A~E 题解"},{"content":" 前言\n这是我第一次写7题（A~G）的ABC题解，若有写得不好或者不到位的地方请多多指教，我将万分感激，感谢大家的支持！ A - ASCII code\r题目大意\r给定正整数$N$，输出ASCII码是$N$的字母。\n$97\\le N\\le 122$\n输入格式\r$N$\n输出格式\r输出ASCII码是$N$的字母。\n分析\r注意a对应$97$，b对应$98$，……，z对应$122$。\n安上小白专属转换教程：\nC 1 2 int n = 97; putchar(n); /* 输出：a */ putchar函数自动转换为字符，也可以使用printf(\u0026quot;%c\u0026quot;, n)效果相同 C++ 1 2 int n = 97; cout \u0026lt;\u0026lt; char(n) \u0026lt;\u0026lt; endl; // 输出：a 直接cout \u0026lt;\u0026lt; n会输出97，需要用char转换为字符 Python 1 2 n = 97 print(chr(n)) # 输出：a 同样也不能直接输出，需要用chr转换 Java 1 2 3 int n = 97; char c = (char) n; System.out.print(c); 与C++、Python类似，需要转换 JavaScript 1 2 3 var n = 97; var c = String.fromCharCode(n); console.log(c); // 输出：a 同样使用接口转化，需调用String.fromCharCode 再不懂你试试……\n代码\r太水，直接走一发py（现场25秒AC）\n1 print(chr(int(input()))) B - Takahashi\u0026rsquo;s Failure\r题目大意\rTakahashi的房子里有$N$个食物。第$i$个食物的美味度是$A_i$。\n其中，他不喜欢$K$个食物：$B_1,B_2,\\dots,B_K$。\n已知Takahashi会从$N$个食物中随机选取一个美味度最大的食物，并把它吃掉。\nTakahashi是否有可能迟到不喜欢的食物？\n$1\\le K\\le N\\le 100$\n$1\\le A_i\\le 100$\n$1\\le B_i\\le N$\n输入格式\r$N~K$\n$A_1~\\dots~A_N$\n$B_1~\\dots~B_K$\n输出格式\r如果有可能，输出Yes；否则，输出No。\n分析\r只要有不喜欢的食物美味度最高就有可能，否则不可能。详见代码。\n代码\r还是水，注意如果是$\\text{0-indexed}$的话$B_i$要减$1$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;cstdio\u0026gt; using namespace std; int a[105]; int main() { int n, k, mx = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d\u0026#34;, a + i); if(a[i] \u0026gt; mx) mx = a[i]; } while(k--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if(a[--n] == mx) { puts(\u0026#34;Yes\u0026#34;); return 0; } } puts(\u0026#34;No\u0026#34;); return 0; } C - Slot Strategy\r题目大意\r略，请自行前往AtCoder查看。\n$2\\le N\\le 100$\n输入格式\r$N$\n$S_1$\n$\\vdots$\n$S_N$\n输出格式\r输出答案。\n分析\r令$\\text{cnt}[i][j]=(S_k[j]=i$的个数$)$，对最终变成$0$-$9$分别计算代价即可。详见代码。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;cstdio\u0026gt; using namespace std; int cnt[10][10]; // cnt[i][j] = number of (s[j]=i) int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { char s[15]; scanf(\u0026#34;%s\u0026#34;, s); for(int j=0; j\u0026lt;10; j++) cnt[s[j] ^ 48][j] ++; } int ans = 1000; for(int i=0; i\u0026lt;10; i++) { int cur = 0; for(int j=0; j\u0026lt;10; j++) { int c = j + (cnt[i][j] - 1) * 10; if(c \u0026gt; cur) cur = c; } if(cur \u0026lt; ans) ans = cur; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Distinct Trio\r题目大意\r给定长为$N$的整数序列$A=(A_1,\\dots,A_N)$。\n求符合以下条件的整数对$(i,j,k)$的个数：\n$1\\le i \u003c j \u003c k\\le N$ $A_i\\ne A_j\\ne A_k$ $3\\le N\\le 2\\times 10^5$\n$1\\le A_i\\le 2\\times 10^5$\n输入格式\r$N$\n$A_1~\\dots~A_N$\n输出格式\r输出一行，即符合条件的整数对$(i,j,k)$的个数。\n分析\r本题主要有两种思路：\n逆向思维，用总数-不符合条件的； 将题目转化为求$A_i \u003c A_j \u003c A_k$的$(i,j,k)$的个数。 这里介绍第一种方法（第二种方法较为简单，不详细说明）。\n首先易得，总共的$1\\le i \u003c j \u003c k\\le N$有$C_n^3$种取法。\n然后考虑$A_i,A_j,A_k$中有重复的个数：\n对于$A$中每个数$x$，我们记录$\\text{cnt}_x=A$中$x$出现的次数； 然后，如果$\\text{cnt}_x\\ge 2$，则将答案减去$C_{\\text{cnt}_x}^2\\times(N-\\text{cnt}_x)$，即$x,x,y$格式出现的次数； 又如果$\\text{cnt}_x\\ge 3$，将答案减去$C_{\\text{cnt}_x}^3$，即$x,x,x$的次数。 总时间复杂度为$\\mathcal O(N+\\max_A-\\min_A)$，空间复杂度为$\\mathcal O(\\max_A-\\min_A)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; using LL = long long; int cnt[maxn]; inline LL C2(int n) { return n * (n - 1LL) \u0026gt;\u0026gt; 1LL; } inline LL C3(int n) { return C2(n) * (n - 2LL) / 3LL; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); cnt[a] ++; } LL ans = C3(n); for(int i=1; i\u0026lt;maxn; i++) if(cnt[i] \u0026gt; 1) { ans -= C2(cnt[i]) * (n - cnt[i]); if(cnt[i] \u0026gt; 2) ans -= C3(cnt[i]); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } E - Road Reduction\r题目大意\r给定一张由$N$个点和$M$条边组成的简单无向图。\n第$i$条边长度为$C_i$，同时连接点$A_i$和$B_i$。\n求任意一颗生成树，使得从点$1$到其他所有点的距离之和最小。\n$2\\le N\\le 2\\times 10^5$\n$N-1\\le M\\le 2\\times 10^5$\n$1\\le A_i \u003c B_i\\le N$\n$(A_i,B_i)\\ne(A_j,B_j)$（$i\\ne j$）\n$1\\le C_i\\le 10^9$\n输入格式\r$N~M$\n$A_1~B_1~C_1$\n$\\vdots$\n$A_M~B_M~C_M$\n输出格式\r按任意顺序输出留下来的$N-1$条边的下标，用空格隔开。\n分析\r显然，在生成树中，点$1$到任意点的距离肯定不少于在原图中到这个点的距离。\n因此，如果两个距离相等，显然就是最优解。\n此时可以证明，肯定有这样的解。使用Dijkstra算法求最短路径的同时，记录到每个点之前的最后一条路即可。\n代码\rDijkstra的两种经典实现方式，$\\mathcal O(N\\log N+M\\log N)$\npriority_queue优先队列（$182\\text{ms}$） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define maxn 200005 #define INF 9223372036854775807LL using namespace std; using LL = long long; using pli = pair\u0026lt;LL, int\u0026gt;; struct Edge { int v, id; LL d; inline Edge(int u, int l, int i): v(u), d(l), id(i) {} }; vector\u0026lt;Edge\u0026gt; G[maxn]; LL dis[maxn]; int ans[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=1; i\u0026lt;=m; i++) { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); G[--a].emplace_back(--b, c, i); G[b].emplace_back(a, c, i); } priority_queue\u0026lt;pli, vector\u0026lt;pli\u0026gt;, greater\u0026lt;pli\u0026gt;\u0026gt; q; for(int i=1; i\u0026lt;n; i++) dis[i] = INF; q.emplace(0LL, 0); while(!q.empty()) { auto [d, v] = q.top(); q.pop(); if(dis[v] == d) for(const Edge\u0026amp; e: G[v]) { LL nd = d + e.d; if(nd \u0026lt; dis[e.v]) q.emplace(dis[e.v] = nd, e.v), ans[e.v] = e.id; } } for(int i=1; i\u0026lt;n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); return 0; } set集合（$202\\text{ms}$） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 200005 #define INF 9223372036854775807LL using namespace std; using LL = long long; using pli = pair\u0026lt;LL, int\u0026gt;; struct Edge { int v, id; LL d; inline Edge(int u, int l, int i): v(u), d(l), id(i) {} }; vector\u0026lt;Edge\u0026gt; G[maxn]; LL dis[maxn]; int ans[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=1; i\u0026lt;=m; i++) { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); G[--a].emplace_back(--b, c, i); G[b].emplace_back(a, c, i); } set\u0026lt;pli\u0026gt; s; // \u0026lt;distance, vertex\u0026gt; for(int i=1; i\u0026lt;n; i++) dis[i] = INF; s.emplace(0LL, 0); while(!s.empty()) { auto [d, v] = *s.begin(); s.erase(s.begin()); for(const Edge\u0026amp; e: G[v]) { LL nd = d + e.d; if(nd \u0026lt; dis[e.v]) { if(dis[e.v] \u0026lt; INF) s.erase(pli(dis[e.v], e.v)); s.emplace(dis[e.v] = nd, e.v); ans[e.v] = e.id; } } } for(int i=1; i\u0026lt;n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); return 0; } 注意使用long long。\nF - Bread\r题目大意\r本题翻译已经过简化，部分表示与原题不同，仅供参考，请以原题为准。\n有一个的整数序列$S$，初始只有一个元素$L$，我们可以执行如下操作无限次：\n从$S$中删去任意元素$k$（$k \u003e 1$），同时选取整数$x$（$1\\le x\\le k-1$），将$x$和$k-x$放入$S$。此操作的代价为$k$。 求最小的代价，使得$A$在$S$中，即$A$中每个元素的出现次数$~\\le S$中对应元素的出现次数。\n$2\\le N\\le 2\\times 10^5$\n$1\\le N\\le 10^9$\n$A_1+A_2+\\dots+A_N\\le L\\le 10^{15}$\n输入格式\r$N~L$\n$A_1~\\dots~A_N$\n输出格式\r输出最小的代价。\n分析\r本题考虑逆向思维，仔细思考后发现题目可以如下转化：\n令$S=(A_1,\\dots,A_N,L-\\sum A)$（$L=\\sum A$时不千万不要加上最后一个元素） 每次操作将$A$中任意两个元素合并，它们的和即为合并后新的元素，也是本次操作的代价 最后发现全部合并完后$S$中正好剩下一个$L$，此时操作结束，所有代价和即为方案的最终代价。 此时，显然每次合并最小的两个数即为最优方案，因此可以使用优先队列实现，总时间复杂度为$\\mathcal O(N\\log N)$。\n代码\r注意使用long long。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; using LL = long long; int main() { int n; LL l; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;l); priority_queue\u0026lt;LL, vector\u0026lt;LL\u0026gt;, greater\u0026lt;LL\u0026gt;\u0026gt; q; for(int i=0; i\u0026lt;n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); q.push(x); l -= x; } if(l \u0026gt; 0) q.push(l); LL ans = 0LL; while(q.size() \u0026gt; 1) { LL x = q.top(); q.pop(); x += q.top(); q.pop(); ans += x; q.push(x); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } G - Pre-Order\r题目大意\r有一颗由$N$个节点$1,2,\\dots,N$组成的树，它的根节点为$1$。\n它的先序遍历序列是$(P_1,P_2,\\dots,P_N)$。\n每次搜索时，我们都会优先前往编号小的节点。\n有多少种不同的树，使其符合上述条件？对$998244353$取模。\n$2\\le N\\le 500$\n$1\\le P_i\\le N$\n$P_1=1$\n$P_1\\ne P_2\\ne\\dots\\ne P_N$\n输入格式\r$N$\n$P_1~\\dots~P_N$\n输出格式\r输出答案，对$998244353$取模。\n分析\r我们先将$P$变为$\\text{0-indexed}$，即原来的$(P_1,P_2,\\dots,P_N)$分别对应$(A_0,A_1,\\dots,A_{N-1})$。\n此时，不妨考虑区间$\\text{dp}$的思想，设$\\mathrm{dp}(l,r)=~($一棵树已经去掉根节点的先序遍历为$A_l,A_{l+1},\\dots,A_{r-1}$的可能数$)$，则$\\mathrm{dp}(1,N)$即为所求。\n下面考虑$\\mathrm{dp}(l,r)$的动态转移方程。\n先考虑$A_l$为$A_{l+1},\\dots,A_{r-1}$的祖宗的情况，如图：\n易得，此时$\\mathrm{dp}(l,r)$初始化为$\\mathrm{dp}(l+1,r)$。\n再考虑区分左右子树，对于每个$k$（$l \u003c k \u003c r$），将$A_l,\\dots,A_{k-1}$当作左子树（可能数为$\\mathrm{dp}(l+1,k)$），再将$A_k,\\dots,A_{r-1}$当作右子树（可能数为$\\mathrm{dp}(k,r)$），此时如果$A_l \u003c A_k$则符合题意，将$\\mathrm{dp}(l,r)$加上$\\mathrm{dp}(l+1,k)\\times \\mathrm{dp}(k,r)$即可。 至此，本题已结束，时间复杂度为$\\mathcal O(N^3)$。\n代码\r注意事项：\n乘法操作需要转为long long再取模。 答案为$\\mathrm{dp}(1,N)$，不是$\\mathrm{dp}(0,N)$。 注意区间$\\text{dp}$计算顺序，参考代码提供两种写法（先枚举$l$和先枚举长度）。 写法一（先枚举$l$，$59\\text{ms}$） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; #define MOD 998244353 #define maxn 505 using namespace std; using LL = long long; int p[maxn], dp[maxn][maxn]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, p + i); for(int l=n; l\u0026gt;0; l--) { dp[l][l] = 1; for(int r=l+1; r\u0026lt;=n; r++) { dp[l][r] = dp[l + 1][r]; for(int k=l+1; k\u0026lt;r; k++) if(p[l] \u0026lt; p[k] \u0026amp;\u0026amp; (dp[l][r] += LL(dp[l + 1][k]) * dp[k][r] % MOD) \u0026gt;= MOD) dp[l][r] -= MOD; } } printf(\u0026#34;%d\\n\u0026#34;, dp[1][n]); return 0; } 写法二（先枚举长度，$66\\text{ms}$） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; #define MOD 998244353 #define maxn 505 using namespace std; using LL = long long; int p[maxn], dp[maxn][maxn]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, p + i); for(int i=1; i\u0026lt;=n; i++) dp[i][i] = 1; for(int d=1; d\u0026lt;=n; d++) for(int l=1, r=d+1; r\u0026lt;=n; l++, r++) { dp[l][r] = dp[l + 1][r]; for(int k=l+1; k\u0026lt;r; k++) if(p[l] \u0026lt; p[k] \u0026amp;\u0026amp; (dp[l][r] += LL(dp[l + 1][k]) * dp[k][r] % MOD) \u0026gt;= MOD) dp[l][r] -= MOD; } printf(\u0026#34;%d\\n\u0026#34;, dp[1][n]); return 0; } ","date":"2022-05-22T11:31:00+08:00","permalink":"https://goodcoder666.github.io/p/abc252/","title":"AtCoder Beginner Contest 252 A~G 题解"},{"content":"C - Adjacent Swaps\r题目大意\r$N$个球从左到右排成一列。开始时，从左往右的第$i$个球上写着数字$i$。\n请执行$Q$个操作，第$i$个操作如下：\n令$j=~N$个球中写着数字$x_i$的球的位置 如果$j=N$，将其与第$j-1$个球交换；否则，与第$j+1$个球交换。 求所有操作后的球上分别写的数字。详见输出格式。\n$2\\le N\\le 2\\times 10^5$\n$1\\le Q\\le 2\\times 10^5$\n$1\\le x_i\\le N$\n输入格式\r$N~Q$\n$x_1$\n$\\vdots$\n$x_Q$\n输出格式\r令$a_i=N$个球中从左往右的第$i$个在所有操作结束后写的数，则按如下格式输出：\n$a_1~a_2~\\dots~a_n$\n即将$a_1,\\dots,a_n$按顺序输出到一行，用空格隔开。\n样例\r略，请自行前往AtCoder查看。\n分析\r根据数据范围可得，本题只能使用时间复杂度不超过$\\mathcal O(N+Q\\log n)$的算法。\n因此，暴力模拟，即查找每个球对应的位置$j$（$\\mathcal O(NQ)$）肯定是行不通的。\n但是很容易想到可以设置索引数组$p$，使当$a_i=x$时，$p_x=i$。\n这样，对于每一个操作，只需$\\mathcal O(1)$的时间复杂度就能找到$x_i$出现的位置。\n交换时注意同时交换一下$a$和$p$中的元素即可。总时间复杂度$\\mathcal O(N+Q)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; inline void swap(int\u0026amp; x, int\u0026amp; y) { x ^= y ^= x ^= y; } int pos[maxn], ans[maxn]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=1; i\u0026lt;=n; i++) ans[i] = pos[i] = i; while(q--) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); int p1 = pos[x]; int p2 = p1 == n? p1 - 1: p1 + 1; swap(pos[x], pos[ans[p2]]); swap(ans[p1], ans[p2]); } for(int i=1; i\u0026lt;=n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); return 0; } D - 250-like Number\r题目大意\r当一个正整数$k$满足以下条件时，我们称其为“与$250$相似的”：\n$k=p\\times q^3$，其中$p,q$均为质数，且$p \u003c q$。 求不超过$N$的“与$250$相似的”$k$的个数。\n$1\\le N\\le 10^{18}$\n输入格式\r$N$\n输出格式\r将答案输出为一个整数。\n样例\r$N$ 输出 $250$ $2$ $1$ $0$ $123456789012345$ $226863$ 分析\r看到数据范围后我们发现$N$太大，不能盲目下手。\n由$k=p\\times q^3,k\\le N$可知，$p\\times q^3\\le N\\le 10^{18}$。\n又因为$p,q$是质数，且$p \u003c q$可得，$2\\le p \u003c q$。\n因此，当$p$最小时$q$最大，所以$q\\le \\sqrt[3]{\\frac {N=10^{18}} {p=2}}\\approx794000$。\n这时，可以想到筛出质数表，并对于每个质数$p$计算最大的$q$，此时质数$p \u003c x\\le q$都能作为$q$，因此将答案加上$p \u003c x\\le q$的质数数量即可。当$p\\ge q$时，退出循环，输出结果即可。\n计算$q$时可以使用二分查找或者双指针算法快速处理。\n总时间复杂度大约在$\\mathcal O(n^{\\frac 7 {22}})$。\n代码\r本代码使用双指针实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; #define maxp 794000 using namespace std; using LL = long long; bool bad[maxp]; vector\u0026lt;int\u0026gt; primes; inline LL pow3(LL x) { return x * x * x; } int main() { bad[0] = bad[1] = true; for(int i=2; i\u0026lt;maxp; i++) if(!bad[i]) { primes.push_back(i); for(int j=i\u0026lt;\u0026lt;1; j\u0026lt;maxp; j+=i) bad[j] = true; } LL n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); LL ans = 0LL; for(int i=0, j=primes.size()-1; i\u0026lt;j; i++) { while(j \u0026gt;= 0 \u0026amp;\u0026amp; primes[i] * pow3(primes[j]) \u0026gt; n) j --; if(i \u0026gt;= j) break; ans += j - i; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } E - Prefix Equality\r题目大意\r给定长度为$N$的正整数序列$A=(A_1,\\dots,A_N)$和$B=(B_1,\\dots,B_N)$。\n对于每个$1\\le i\\le Q$，给定两个正整数$x_i,y_i$，回答如下格式的查询：\n判断集合$\\{A_1,\\dots,A_{x_i}\\}$和$\\{B_1,\\dots,B_{y_i}\\}$是否相等。 集合可以说成是序列排序并去重的结果，如序列$(9,3,5,3,4)$对应的集合是$\\{3,4,5,9\\}$。\n$1\\le N,Q\\le 2\\times 10^5$\n$1\\le A_i\\le B_i\\le 10^9$\n$1\\le x_i,y_i\\le N$\n输入格式\r$N$\n$A_1~\\dots~A_N$\n$B_1~\\dots~B_N$\n$Q$\n$x_1~y_1$\n$\\vdots$\n$x_Q~y_Q$\n样例\r样例输入\r1 2 3 4 5 6 7 8 9 10 11 5 1 2 3 4 5 1 2 2 4 3 7 1 1 2 2 2 3 3 3 4 4 4 5 5 5 样例输出\r1 2 3 4 5 6 7 Yes Yes Yes No No Yes No 分析\r$$\rP_A(i)=\\sum\\{A_1,\\dots,A_i\\}\\\\\rP_B(i)=\\sum\\{B_1,\\dots,B_i\\}\r$$\n此时，只需判断$P_A(x_i)$和$P_B(y_i)$是否相等即可。时间复杂度为$\\mathcal O(N+Q)$或$\\mathcal O(Q+N\\log N)$。\n构造hack数据也很简单，只需部分前缀和相等即可，如：\n1 2 3 4 5 5 1 3 5 6 7 3 2 4 1 5 1 3 3 这样，因为$1+3+5=3+2+4=9$，所以这样的程序会认为这是相等的序列，从而输出Yes，但显然$\\{1,3,5\\}\\ne\\{3,2,4\\}$，因此答案为No，程序错误。\n$$\rH(x)=x(x+A)(x+B)\\bmod P\r$$\n其中$A,B,P$一般取质数，$H(x)$即为$x$对应的哈希值。（对$P$取模是为了防止哈希值太大导致溢出）\n显然，这样有一个很小的概率会产生哈希冲突（即不同的数得到相同的哈希值），但因为$A,B,P$的取值太多，评测机没法针对性的hack，所以正常情况下都能通过（CF的Hack机制除外）。如果真担心有问题，可以采取双哈希，即对于一个$x$，用两个不同的哈希函数计算哈希值，这样就几乎不可能出现哈希冲突了。\n$$\rP_A(i)=\\sum\\{H(A_1),\\dots,H(A_i)\\}\\bmod P\\\\\rP_B(i)=\\sum\\{H(B_1),\\dots,H(B_i)\\}\\bmod P\r$$\n还是按原来的思路，判断前缀和是否相等即可。\n总时间复杂度为$\\mathcal O(n)$（unordered_set/HashSet）或$\\mathcal O(n\\log n)$（set/TreeSet）。\n代码\r这里还是要提一点，就是使用哈希时有一个小技巧，即直接取$P=2^{32}-1$（unsigned int）或者$P=2^{64}-1$（unsigned long long），使整数自然溢出，省去了麻烦又耗时间的取模步骤。CodeForces上还是建议取较大的质数（常用的有$10^9+7,998244353$）作为$P$，以免被hack导致丢分。\n这里我用的哈希函数为$H(x)=x(x+93)(x+117)\\bmod(2^{32}-1)$，即$A=93,B=117,P=2^{32}-1$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;unordered_set\u0026gt; #define maxn 200005 using namespace std; inline int read() { char c; while((c = getchar()) \u0026lt; \u0026#39;0\u0026#39; || c \u0026gt; \u0026#39;9\u0026#39;); int res = c ^ 48; while((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) res = (res \u0026lt;\u0026lt; 3) + (res \u0026lt;\u0026lt; 1) + (c ^ 48); return res; } unsigned suma[maxn], sumb[maxn]; inline void hread(unsigned* psum, int n) { unordered_set\u0026lt;int\u0026gt; s; for(int i=1, x; i\u0026lt;=n; i++) { psum[i] = psum[i - 1]; if(s.insert(x = read()).second) psum[i] += x * unsigned(x + 93) * unsigned(x + 117); } } int main() { int n = read(); hread(suma, n); hread(sumb, n); for(int q=read(); q--;) puts(suma[read()] == sumb[read()]? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } ","date":"2022-05-11T07:45:00+08:00","permalink":"https://goodcoder666.github.io/p/abc250/","title":"AtCoder Beginner Contest 250 C~E 题解"},{"content":"C - Dice Sum\r题目大意\r有多少个整数序列$A=(A_1,\\dots,A_N)$符合如下条件：\n$1\\le A_i\\le M$ $\\sum\\limits_{i=1}^NA_i\\le K$ 输出答案，对$998244353$取模。\n$1\\le N,M\\le 50$\n$N\\le K\\le NM$\n输入格式\r$N~M~K$\n输出格式\r输出答案，对$998244353$取模。\n分析\r艹C题又要dp\n考虑$\\text{DP}$思想，令$\\text{dp}(i,j):=A$的前$i$个元素中和为$j$的总可能数（$1\\le A_x\\le M$），则可得伪代码：\n1 2 3 4 5 6 dp[0][0] = 1 for i = 0 to N-1 // 逐个位置考虑 for j = 0 to K-1 // 考虑所有和的情况，无需考虑K for k = 1 to M // 1-M的每个选择 if j + k \u0026lt;= K: // 限制条件 dp[i + 1][j + k] += dp[i][j] // 更新dp[i+1] 时间复杂度为$\\mathcal O(NMK)$，可以通过。\n其实还可以利用前缀和优化。\n不难发现$\\mathrm{dp}(i,j)=\\displaystyle\\sum_{k=L}^R\\text{dp}(i-1,k)$，\n其中$L\\le R$，具体的值请自行推导。\n因此，我们可以记录$\\mathrm{dp}[i-1]$的前缀和$\\mathrm{pre}$：\n$\\mathrm{pre}_j=\\displaystyle\\sum_{k=1}^j\\mathrm{dp}(i-1,k)$ 则$\\mathrm{dp}(i,j)=\\mathrm{pre}_R-\\mathrm{pre}_{L-1}$。\n因此，时间复杂度为$\\mathcal O(NK)$。\n强烈建议读者独立推导并实现该方法。 前缀和优化$\\text{DP}$的算法在E、F题中很常见。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; #define MOD 998244353 #define maxn 200005 using namespace std; inline void mod(int\u0026amp; x) { if(x \u0026gt;= MOD) x -= MOD; } int dp[2][maxn]; int main() { int n, m, k; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); dp[0][0] = 1; for(int i=0; i\u0026lt;n; i++) { int c = i \u0026amp; 1, p = c ^ 1; for(int j=0; j\u0026lt;=k; j++) dp[p][j] = 0; for(int j=0; j\u0026lt;k; j++) for(int d=1; d\u0026lt;=m \u0026amp;\u0026amp; d\u0026lt;=k-j; d++) mod(dp[p][j + d] += dp[c][j]); } int ans = 0; for(int i=1; i\u0026lt;=k; i++) mod(ans += dp[n \u0026amp; 1][i]); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Range Count Query\r题目大意\r给定整数序列$A=(A_1,\\dots,A_N)$。\n有$Q$个查询。每个查询的格式如下：\n给定三个整数$L,R,X$，求$A_L,\\dots,A_R$中$X$的出现次数。 $1\\le A_i,X\\le N\\le 2\\times10^5$\n$1\\le L\\le R\\le N$\n输入格式\r$N$\n$A_1~\\dots~A_N$\n$Q$\n$L_1~R_1~X_1$\n$\\vdots$\n$L_Q~R_Q~X_Q$\n输出格式\r输出$Q$行，第$i$行是第$i$个查询的答案。\n分析\r题目换句话说就是：求$X$出现的位置中，在$[L,R]$区间内的有多少个？\n因此，我们很容易想到先预处理$1,\\dots,N$中每个数出现的位置，存入vector，查询时二分即可。\n代码\r注意二分边界。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 200005 using namespace std; vector\u0026lt;int\u0026gt; pos[maxn]; int main() { int n, q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); pos[a].push_back(i); } scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while(q--) { int l, r, x; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;x); printf(\u0026#34;%d\\n\u0026#34;, int( lower_bound(pos[x].begin(), pos[x].end(), r) - lower_bound(pos[x].begin(), pos[x].end(), --l) )); } return 0; } ","date":"2022-04-17T15:45:00+08:00","permalink":"https://goodcoder666.github.io/p/abc248/","title":"UNIQUE VISION Programming Contest 2022（AtCoder Beginner Contest 248）C~D 题解"},{"content":"注：本文原发表于 CSDN，现已停止更新。原文如下：\nAtCoder题解集锦\r自己从全网整理的一些优质 AtCoder 题解，目前只有 ABC（AtCoder Beginner Contest）的 C~F。不定期更新。\n如您有更多需求，欢迎私信我或在评论区留言！\n$\\rarr$ 题解列表传送门\n用法\r表格查找\n找到对应比赛的行 找到对应题目的列 该位置即为对应的题解 题号查找\n在浏览器中按下搜索快捷键Ctrl+F，调出搜索窗口。 输入对应的题号，如 244F 找到对应题解 标题查找\n在浏览器中按下搜索快捷键Ctrl+F，调出搜索窗口。 输入题目标题，如 Shortest Good Path 找到对应题解 题解筛选规则：\n优先选择中文题解 若没有较好的中文题解，选择AtCoder官方题解 若赛后几天暂时没有题解，选取优质的提交记录作为链接 题目列表\r按比赛时间升序排列，从ABC195开始。\n比赛 C D E F ABC195 195C - Comma 195D - Shipping Center 195E - Lucky 7 Battle 195F - Coprime Present ABC196 196C - Doubled 196D - Hanjo 196E - Filters 196F - Substring 2 ABC197 197C - ORXOR 197D - Opposite 197E - Traveler 197F - Construct a Palindrome ABC198 198C - Compass Walking 198D - Send More Money 198E - Unique Color 198F - Cube ABC199 199C - IPFL 199D - RGB Coloring 2 199E - Permutation 199F - Graph Smoothing ABC200 200C - Ringo\u0026rsquo;s Favorite Numbers 2 200D - Happy Birthday! 2 200E - Patisserie ABC 2 200F - Minflip Summation ABC201 201C - Secret Number 201D - Game in Momotetsu World 201E - Xor Distances 201F - Insertion Sort ABC202 202C - Made Up 202D - aab aba baa 202E - Count Descendants 202F - Integer Convex Hull ABC203 203C - Friends and Travel costs 203D - Pond 203E - White Pawn 203F - Weed ABC204 204C - Tour 204D - Cooking 204E - Rush Hour 2 204F - Hanjo 2 ABC205 205C - POW 205D - Kth Excluded 205E - White and Black Balls 205F - Grid and Tokens ABC206 206C - Swappable 206D - KAIBUNsyo 206E - Divide Both 206F - Interval Game 2 ABC207 207C - Many Segments 207D - Congruence Points 207E - Mod i 207F - Tree Patrolling ABC208 208C - Fair Candy Distribution 208D - Shortest Path Queries 2 208E - Digit Products 208F - Cumulative Sum ABC209 209C - Not Equal 209D - Collision 209E - Shiritori 209F - Deforestation ABC210 210C - Colorful Candies 210D - National Railway 210E - Ring MST 210F - Coprime Solitaire ABC211 211C - chokudai 211D - Number of Shortest paths 211E - Red Polyomino 211F - Rectilinear Polygons ABC212 212C - Min Difference 212D - Querying Multiset 212E - Safety Journey 212F - Greedy Takahashi ABC213 213C - Reorder Cards 213D - Takahashi Tour 213E - Stronger Takahashi 213F - Common Prefixes ABC214 214C - Distribution 214D - Sum of Maximum Weights 214E - Packing Under Range Regulations 214F - Substrings ABC215 215C - One More aab aba baa 215D - Coprime 2 215E - Chain Contestant 215F - Dist Max 2 ABC216 216C - Many Balls 216D - Pair of Balls 216E - Amusement Park 216F - Max Sum Counting ABC217 217C - Inverse of Permutation 217D - Cutting Woods 217E - Sorting Queries 217F - Make Pair ABC218 218C - Shapes 218D - Rectangles 218E - Destruction 218F - Blocked Roads ABC219 219C - Neo-lexicographic Ordering 219D - Strange Lunchbox 219E - Moat 219F - Cleaning Robot ABC220 220C - Long Sequence 220D - FG operation 220E - Distance on Large Perfect Binary Tree 220F - Distance Sums 2 ABC221 221C - Select Mul 221D - Online games 221E - LEQ 221F - Diameter set ABC222 222C - Swiss-System Tournament 222D - Between Two Arrays 222E - Red and Blue Tree 222F - Expensive Expense ABC223 223C - Doukasen 223D - Restricted Permutation 223E - Placing Rectangles 223F - Parenthesis Checking ABC224 224C - Triangle? 224D - 8 Puzzle on Graph 224E - Integers on Grid 224F - Problem where +s Separate Digits ABC225 225C - Calendar Validator 225D - Play Train 225E - フ/7 225F - String Cards ABC226 226C - Martial artist 226D - Teleportation 226E - Just one 226F - Score of Permutations ABC227 227C - ABC conjecture 227D - Project Planning 227E - Swap 227F - Treasure Hunting ABC228 228C - Final Day 228D - Linear Probing 228E - Integer Sequence Fair 228F - Stamp Game ABC229 229C - Cheese 229D - Longest X 229E - Graph Destruction 229F - Make Bipartite ABC230 230C - X drawing 230D - Destroyer Takahashi 230E - Fraction Floor Sum 230F - Predilection ABC231 231C - Counting 2 231D - Neighbors 231E - Minimal payments 231F - Jealous Two ABC232 232C - Graph Isomorphism 232D - Weak Takahashi 232E - Rook Path 232F - Simple Operations on Sequence ABC233 233C - Product 233D - Count Interval 233E - Σ[k=0..10^100]floor(X／10^k) 233F - Swap and Sort ABC234 234C - Happy New Year! 234D - Prefix K-th Max 234E - Arithmetic Number 234F - Reordering ABC235 235C - The Kth Time Query 235D - Multiply and Rotate 235E - MST + 1 235F - Variety of Digits ABC236 236C - Route Map 236D - Dance 236E - Average and Median 236F - Spices ABC237 237C - kasaka 237D - LR insertion 237E - Skiing 237F - |LIS| = 3 ABC238 238C - digitnum 238D - AND and SUM 238E - Range Sums 238F - Two Exams ABC239 239C - Knight Fork 239D - Prime Sum Game 239E - Subtree K-th Max 239F - Construct Highway ABC240 240C - Jumping Takahashi 240D - Strange Balls 240E - Ranges on Tree 240F - Sum Sum Max ABC241 241C - Connect 6 241D - Sequence Query 241E - Putting Candies 241F - Skate ABC242 242C - 1111gal password 242D - ABC Transform 242E - (∀x∀) 242F - Black and White Rooks ABC243 243C - Collision 2 243D - Moves on Binary Tree 243E - Edge Deletion 243F - Lottery ABC244 244C - Yamanote Line Game 244D - Swap Hats 244E - King Bombee 244F - Shortest Good Path ABC245 245C - Choose Elements 245D - Polynomial division 245E - Wrapping Chocolate 245F - Endless Walk ABC246 246C - Coupon 246D - 2-variable Function 246E - Bishop 2 246F - typewriter ABC247 247C - 1 2 1 3 1 2 1 247D - Cylinder 247E - Max Min 247F - Cards ABC248 248C - Dice Sum 248D - Range Count Query 248E - K-colinear Line 248F - Keep Connect ABC249 249C - Just K 249D - Index Trio 249E - RLE 249F - Ignore Operations ABC250 250C - Adjacent Swaps 250D - 250-like Number 250E - Prefix Equality 250F - One Fourth ABC251 251C - Poem Online Judge 251D - At Most 3 (Contestant ver.) 251E - Takahashi and Animals 251F - Two Spanning Trees ABC252 252C - Slot Strategy 252D - Distinct Trio 252E - Road Reduction 252F - Bread ABC253 253C - Max - Min Query 253D - FizzBuzz Sum Hard 253E - Distance Sequence 253F - Operations on a Matrix ABC254 254C - K Swap 254D - Together Square 254E - Small d and k 254F - Rectangle GCD ABC255 255C - ±1 Operation 1 255D - ±1 Operation 2 255E - Lucky Numbers 255F - Pre-order and In-order ABC256 256C - Filling 3x3 array 256D - Union of Interval 256E - Takahashi\u0026rsquo;s Anguish 256F - Cumulative Cumulative Cumulative Sum ABC257 257C - Robot Takahashi 257D - Jumping Takahashi 2 257E - Addition and Multiplication 2 257F - Teleporter Setting ABC258 258C - Rotation 258D - Trophy 258E - Packing Potatoes 258F - Main Street ABC259 259C - XX to XXX 259D - Circumferences 259E - LCM on Whiteboard 259F - Select Edges ABC260 260C - Changing Jewels 260D - Draw Your Cards 260E - At Least One 260F - Find 4-cycle ABC261 261C - NewFolder(1) 261D - Flipping and Bonus 261E - Many Operations 261F - Sorting Color Balls ABC262 262C - Min Max Pair 262D - I Hate Non-integer Number 262E - Red and Blue Graph 262F - Erase and Rotate ABC263 263C - Monotonically Increasing 263D - Left Right Operation 263E - Sugoroku 3 263F - Tournament ABC264 264C - Matrix Reducing 264D - \u0026quot;redocta\u0026quot;.swap(i,i+1) 264E - Blackout 2 264F - Monochromatic Path ABC265 265C - Belt Conveyor 265D - Iroha and Haiku (New ABC Edition) 265E - Warp 265F - Manhattan Cafe ABC266 266C - Convex Quadrilateral 266D - Snuke Panic (1D) 266E - Throwing the Die 266F - Well-defined Path Queries on a Namori ABC267 267C - Index × A(Continuous ver.) 267D - Index × A(Not Continuous ver.) 267E - Erasing Vertices 2 267F - Exactly K Steps ABC268 268C - Chinese Restaurant 268D - Unique Username 268E - Chinese Restaurant (Three-Star Version) 268F - Best Concatenation ABC269 269C - Submask 269D - Do use hexagon grid 269E - Last Rook 269F - Numbered Checker ABC270 270C - Simple path 270D - Stones 270E - Apple Baskets on Circle 270F - Transportation ABC271 271C - Manga 271D - Flip and Adjust 271E - Subsequence Path 271F - XOR on Grid Path ABC272 272C - Max Even 272D - Root M Leaper 272E - Add and Mex 272F - Two Strings ABC273 273C - (K+1)-th Largest Number 273D - LRUD Instructions 273E - Notebook 273F - Hammer 2 ABC274 274C - Ameba 274D - Robot Arms 2 274E - Booster 274F - Fishing ABC275 275C - Counting Squares 275D - Yet Another Recursive Function 275E - Sugoroku 4 275F - Erase Subarrays ABC276 276C - Previous Permutation 276D - Divide by 2 or 3 276E - Round Trip 276F - Double Chance ABC277 277C - Ladder Takahashi 277D - Takahashi's Solitaire 277E - Crystal Switches 277F - Sorting a Matrix ABC278 278C - FF 278D - All Assign Point Add 278E - Grid Filling 278F - Shiritori ABC279 279C - RANDOM 279D - Freefall 279E - Cheating Amidakuji 279F - BOX ABC280 280C - Extra Character 280D - Factorial and Multiple 280E - Critical Hit 280F - Pay or Receive ABC281 281C - Circular Playlist 281D - Max Multiple 281E - Least Elements 281F - Xor Minimization ABC282 282C - String Delimiter 282D - Make Bipartite 2 282E - Choose Two and Eat One 282F - Union of Two Sets ABC283 283C - Cash Register 283D - Scope 283E - Don't Isolate Elements 283F - Permutation Distance ABC284 284C - Count Connected Components 284D - Happy New Year 2023 284E - Count Simple Paths 284F - ABCBAC ABC285 285C - abc285_brutmhyhiizp 285D - Change Usernames 285E - Work or Rest 285F - Substring of Sorted String ABC286 286C - Rotate and Palindrome 286D - Money in Hand 286E - Souvenir 286F - Guess The Number 2 ABC287 287C - Path Graph? 287D - Match or Not 287E - Karuta 287F - Components ABC288 288C - Don’t be cycle 288D - Range Add Query 288E - Wish List 288F - Integer Division ABC289 289C - Coverage 289D - Step Up Robot 289E - Swap Places 289F - Teleporter Takahashi ABC290 290C - Max MEX 290D - Marking 290E - Make it Palindrome 290F - Maximum Diameter ABC291 291C - LRUD Instructions 2 291D - Flip Cards 291E - Find Permutation 291F - Teleporter and Closed off ABC292 292C - Four Variables 292D - Unicyclic Components 292E - Transitivity 292F - Regular Triangle Inside a Rectangle ABC293 293C - Make Takahashi Happy 293D - Tying Rope 293E - Geometric Progression 293F - Zero or One ABC294 294C - Merge Sequences 294D - Bank 294E - 2xN Grid 294F - Sugar Water 2 ABC295 295C - Socks 295D - Three Days Ago 295E - Kth Number 295F - substr = S ABC296 296C - Gap Existence 296D - M\u0026lt;=ab 296E - Transition Game 296F - Simultaneous Swap ABC297 297C - PC on the Table 297D - Count Subtractions 297E - Kth Takoyaki Set 297F - Minimum Bounding Box 2 ABC298 298C - Cards Query Problem 298D - Writing a Numeral 298E - Unfair Sugoroku 298F - Rook Score ABC299 299C - Dango 299D - Find by Query 299E - Nearest Black Vertex 299F - Square Subsequence ABC300 300C - Cross 300D - AABCC 300E - Dice Product 3 300F - More Holidays ABC301 301C - AtCoder Cards 301D - Bitmask 301E - Pac-Takahashi 301F - Anti-DDoS ABC302 302C - Almost Equal 302D - Impartial Gift 302E - Isolation 302F - Merge Set ABC303 303C - Dash 303D - Shift vs. CapsLock 303E - A Gift From the Stars 303F - Damage over Time ABC304 304C - Virus 304D - A Piece of Cake 304E - Good Graph 304F - Shift Table ABC305 305C - Snuke the Cookie Picker 305D - Sleep Log 305E - Art Gallery on Graph 305F - Dungeon Explore ABC306 306C - Centers 306D - Poisonous Full-Course 306E - Best Performances 306F - Merge Sets ABC307 307C - Ideal Sheet 307D - Mismatched Parentheses 307E - Distinct Adjacent 307F - Virus 2 ABC308 308C - Standings 308D - Snuke Maze 308E - MEX 308F - Vouchers ABC309 309C - Medicine 309D - Add One Edge 309E - Family and Insurance 309F - Box in Box ABC310 310C - Reversible 310D - Peaceful Teams 310E - NAND repeatedly 310F - Make 10 Again ABC311 311C - Find it! 311D - Grid Ice Floor 311E - Defect-free Squares 311F - Yet Another Grid Task ABC312 312C - Invisible Hand 312D - Count Bracket Sequences 312E - Tangency of Cuboids 312F - Cans and Openers ABC313 313C - Approximate Equalization 2 313D - Odd or Even 313E - Duplicate 313F - Flip Machines ABC314 314C - Rotate Colored Subsequence 314D - LOWER 314E - Roulettes 314F - A Certain Game ABC315 315C - Flavors 315D - Magical Cookies 315E - Prerequisites 315F - Shortcuts ABC317 317C - Remembering the Days 317D - President 317E - Avoid Eye Contact 317F - Nim ABC318 318C - Blue Spring 318D - General Weighted Max Matching 318E - Sandwiches 318F - Octopus ABC319 319C - False Hope 319D - Minimum Width 319E - Bus Stops 319F - Fighter Takahashi ABC320 320C - Slot Strategy 2 (Easy) 320D - Relative Position 320E - Somen Nagashi 320F - Fuel Round Trip ABC321 321C - 321-like Searcher 321D - Set Menu 321E - Complete Binary Tree 321F - #(subset sum = K) with Add and Erase ABC322 322C - Festival 322D - Polyomino 322E - Product Development 322F - Vacation Query ABC323 323C - World Tour Finals 323D - Merge Slimes 323E - Playlist 323F - Push and Carry ABC324 324C - Error Correction 324D - Square Permutation 324E - Joint Two Strings 324F - Beautiful Path ABC325 325C - Sensors 325D - Printing Machine 325E - Our clients, please wait a moment 325F - Sensor Optimization Dilemma ABC326 326C - Peak 326D - ABC Puzzle 326E - Revenge of \u0026quot;The Salary of AtCoder Inc.\u0026quot; 326F - Robot Rotation ABC327 327C - Number Place 327D - Good Tuple Problem 327E - Maximize Rating 327F - Apples ABC328 328C - Consecutive 328D - Take ABC 328E - Modulo MST 328F - Good Set Query ABC329 329C - Count xxx 329D - Election Quick Report 329E - Stamp 329F - Colored Ball ABC330 330C - Minimize Abs 2 330D - Counting Ls 330E - Mex and Update 330F - Minimize Bounding Square ABC331 331C - Sum of Numbers Greater Than Me 331D - Tile Pattern 331E - Set Meal 331F - Palindrome Query 更新日志\r日期 更新内容 2022/06/16 增加更新日志；更新 ABC254-255 题解 .. .. 2022/09/16 更新 ABC266-268 题解 2022/10/11 更新 ABC269-272 题解 2022/11/6 更新 ABC273-276 题解 2022/12/31 更新 ABC277-283 题解 2023/01/24 更新 ABC283-286 题解 2023/04/19 更新 ABC287-298 题解 2023/11/01 更新 ABC299-326 题解；优化格式 2023/12/02 更新 ABC327-331 题解 注：本人老是在比赛后忘（lan）记（de）更新，欢迎大家私信提醒我，谢谢！\n","date":"2022-04-15T22:27:00+08:00","permalink":"https://goodcoder666.github.io/p/atcoder-all/","title":"AtCoder题解集锦"},{"content":"ARC138 B - 01 Generation\r思路\r考虑逆向思维，很容易想到可以优先从后面删掉0（操作B的逆向操作），然后如果前面是0则删掉它并将序列翻转（操作A的逆向操作），一直重复这两个步骤直到字符串为空。如果中途无法操作，输出No，否则输出Yes。\n下面我们来证明这个方法的正确性：\n首先，假设有一个序列$A$按照上述方法输出No，但正确答案为Yes； 则一定在某一步（可能是第一步）只能先倒推操作A，而不是操作B，设这一步执行前的序列为$S$； 此时，令$N=|S|$，则$S_1=S_N=0$； 如果先倒推操作A，得到$(S_2,S_3,\\dots,S_{N-1},1)$ 如果先倒推操作B，得到$(S_1,S_2,\\dots,S_{N-1})$ 对比两个序列，发现先倒推操作B不会影响后续倒推A的结果，因此，序列$S$不存在。 结论：做法正确。 代码\r代码实现时，没有必要真正翻转序列，只需记录当前翻转的状态（$0$或$1$），记为$\\text{flipped}$，则实际的$A_i=A_i'\\oplus\\text{flipped}$（其中$A_i'$为输入的$A$，$\\oplus$表示异或/XOR操作）。\n删除时可以使用deque或者数组$l,r$端点记录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; bool a[maxn]; int main() { int n = 0; char c; while((c = getchar()) != \u0026#39;\\n\u0026#39;) n = (n \u0026lt;\u0026lt; 3) + (n \u0026lt;\u0026lt; 1) + (c ^ 48); for(int i=0; i\u0026lt;n; i++, getchar()) a[i] = getchar() ^ 48; bool flipped = false; for(int l=0, r=n-1; a[l]==flipped; flipped^=1, l++) while(!a[r] ^ flipped) if(l \u0026gt; --r) return puts(\u0026#34;Yes\u0026#34;), 0; puts(\u0026#34;No\u0026#34;); return 0; } ","date":"2022-04-14T22:37:00+08:00","permalink":"https://goodcoder666.github.io/p/arc138_b/","title":"ARC138 B - 01 Generation 题解"},{"content":"A - Good morning\r题目大意\r在同一天里，Takahashi在$A$时$B$分起床，Aoki在$C$时$D$分$1$秒起床，请问谁起床更早？\n$0\\le A,C \u003c 24$\n$0\\le B,D \u003c 60$\n输入格式\r$A~B~C~D$\n输出格式\r输出起得更早的人的名字（Takahashi或Aoki）。\n样例\r$A$ $B$ $C$ $D$ 输出 $7$ $0$ $6$ $30$ Aoki $7$ $30$ $7$ $30$ Takahashi $0$ $0$ $23$ $59$ Takahashi 分析\r思路很明显，直接判断$(A,B)\\le(C,D)$是否成立即可。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c, d; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); puts((a == c? b \u0026lt;= d: a \u0026lt; c)? \u0026#34;Takahashi\u0026#34;: \u0026#34;Aoki\u0026#34;); return 0; } B - Mex\r题目大意\r给定整数序列$A=(A_1,\\dots,A_N)$。求最小的不在$A$中的自然数。\n$1\\le N\\le 2000$\n$0\\le A_i\\le 2000$\n输入格式\r$N$\n$A_1~\\dots~A_N$\n输出格式\r输出一行，即最小的不在$A$中的自然数。\n样例\r略，请自行前往AtCoder查看\n分析\r由于题面中有限制$0\\le A_i\\le 2000$，所以我们直接开一个数组记录$[0,2001]$中每个数是否出现过即可。\n本题方法很多，这里介绍的是最快的算法，时间复杂度$\\mathcal O(N)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; using namespace std; bool used[2005]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while(n--) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); used[a] = true; } int i = -1; while(used[++i]); printf(\u0026#34;%d\\n\u0026#34;, i); return 0; } C - Choose Elements\r题目大意\r给定两个长度为$N$的整数序列$A=(A_1,\\dots,A_N)$和$B=(B_1,\\dots,B_N)$。\n问是否存在序列$X=(X_1,\\dots,X_N)$，满足如下条件：\n$X_i=A_i$或$X_i=B_i$ $|X_i-X_{i+1}|\\le K$，其中$1\\le i \u003c N$ $1\\le N\\le 2\\times 10^5$\n$1\\le K\\le 10^9$\n$1\\le A_i,B_i\\le 10^9$\n输入格式\r$N~K$\n$A_1~\\dots~A_N$\n$B_1~\\dots~B_N$\n输出格式\r如果存在符合全部条件的$X$，输出Yes；否则，输出No。\n样例\r略，请自行前往AtCoder查看\n分析\r好家伙，C题都要用dp……\n本题普通的方法貌似不太好做，因此我们考虑$\\text{DP}$。\n令$f(i)=X_i$选择能否等于$A_i$，$g(i)=X_i$能否等于$B_i$。\n然后状态转移方程就简单了，详见代码。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; int a[maxn], b[maxn]; bool f[maxn], g[maxn]; int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, b + i); f[0] = g[0] = true; #define set(x, y, z) x |= y - z \u0026lt;= k \u0026amp;\u0026amp; z - y \u0026lt;= k for(int i=1; i\u0026lt;n; i++) { if(f[i - 1]) set(f[i], a[i - 1], a[i]), set(g[i], a[i - 1], b[i]); if(g[i - 1]) set(f[i], b[i - 1], a[i]), set(g[i], b[i - 1], b[i]); } puts(f[n - 1] || g[n - 1]? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } ==注：本题还有一种很奇怪的解法，就是直接判断相邻的四种连接方式是否有至少一种能连通，比如#30453703，如果有大佬能证明这种方法的正确性，欢迎在评论区留言告诉我，谢谢！==\nD - Polynomial division\r题目大意\r$$\rA(x)=\\sum_{i=0}^N A_iX^i\\\\\rB(x)=\\sum_{i=0}^M B_iX^i\\\\\rC(x)=\\sum_{i=0}^{N+M} B_iX^i\r$$\n已知$A_0,\\dots,A_N$和$C_0,\\dots,C_N$且$A(x)\\times B(x)=C(x)$（$x\\in R$），求$B_0,\\dots,B_M$。\n换句话说，给定多项式$A$和$C$每一项的系数，求多项式$B=\\frac C A$。\n$1\\le N,M \u003c 100$\n$|A_i|\\le 100$\n$|C_i|\\le 10^6$\n$A_N\\ne0,C_{N+M}\\ne0$\n题目保证存在合法的$(B_0,\\dots,B_M)$。\n输入格式\r$N~M$\n$A_0~\\dots~A_N$\n$C_0~\\dots~C_{N+M}$\n输出格式\r输出$B_0,\\dots,B_M$，用空格分隔。\n样例\r略，请自行前往AtCoder查看\n分析\r本题可以直接模拟多项式的大除法运算，运算时只需记录系数即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #define maxn 105 using namespace std; int a[maxn], b[maxn], c[maxn \u0026lt;\u0026lt; 1]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;=n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); for(int i=0; i\u0026lt;=n+m; i++) scanf(\u0026#34;%d\u0026#34;, c + i); for(int i=m; i\u0026gt;=0; i--) // NOTE: 必须倒推！ { b[i] = c[n + i] / a[n]; for(int j=0; j\u0026lt;=n; j++) c[i + j] -= a[j] * b[i]; } for(int i=0; i\u0026lt;=m; i++) printf(\u0026#34;%d \u0026#34;, b[i]); return 0; } E - Wrapping Chocolate\r题目大意\r我们有$N$块巧克力和$M$个盒子。第$i$块巧克力长$A_i$厘米，宽$B_i$厘米；第$i$个盒子长$C_i$厘米，宽$D_i$厘米。\n问是否能把巧克力分别装在盒子里，使其满足如下条件：\n每个盒子里只能有一块巧克力。 当我们将第$i$块巧克力放入第$j$个盒子里时，$A_i\\le C_j$和$B_i\\le D_j$必须都成立。 $1\\le N\\le M\\le 2\\times10^5$\n$1\\le A_i,B_i,C_i,D_i\\le 10^9$\n输入格式\r$N~M$\n$A_1~\\dots~A_N$\n$B_1~\\dots~B_N$\n$C_1~\\dots~C_N$\n$D_1~\\dots~D_N$\n输出格式\r如果有合法的方法，输出Yes；否则，输出No。\n分析\r本题可以考虑如下贪心算法：\n将所有的巧克力和盒子放入一个数组，按长度（$A_i$或$C_i$）的降序排序，长度相等的把盒子排在前面。 准备好一个空序列$S=()$，按如下规则遍历每个元素： 如果当前遍历的是一个盒子$(C_i,D_i)$：\n将$D_i$加入$S$。 如果当前遍历的是一块巧克力$(A_i,B_i)$：\n从$S$中删除不超过$B_i$的最小元素，如果没有元素可删除，输出No。 如果顺利地遍历了所有元素，输出Yes；否则，输出No。 本算法的时间复杂度是$\\mathcal O(MN)$，但经过multiset优化后可降为$\\mathcal O((M+N)\\log(M+N)$，具体实现详见代码。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; struct Item { int w, h; bool type; inline bool operator \u0026lt;(const Item\u0026amp; i2) const { return w == i2.w? type \u0026gt; i2.type: w \u0026gt; i2.w; // ^^^^^^^^^^^^^^ // 注意sort必须有严格顺序，一开始我这里写成了type==1导致RE，详见： // https://atcoder.jp/contests/abc245/submissions/30526563 } } v[400005]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); // Chocolate for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;v[i].w); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;v[i].h); // Box m += n; for(int i=n; i\u0026lt;m; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;v[i].w); for(int i=n; i\u0026lt;m; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;v[i].h); for(int i=n; i\u0026lt;m; i++) v[i].type = 1; // Algorithm sort(v, v + m); multiset\u0026lt;int\u0026gt; s; for(int i=0; i\u0026lt;m; i++) { const Item\u0026amp; it = v[i]; if(it.type) s.insert(it.h); // Box else { auto itr = s.lower_bound(it.h); if(itr == s.end()) { puts(\u0026#34;No\u0026#34;); return 0; } s.erase(itr); } } puts(\u0026#34;Yes\u0026#34;); return 0; } ","date":"2022-03-28T21:00:00+08:00","permalink":"https://goodcoder666.github.io/p/abc245/","title":"AtCoder Beginner Contest 245 A~E 题解"},{"content":"D - Swap Hats\r题目大意\r有$3$个Takahashi，他们帽子的颜色分别为$S_1,S_2,S_3$。\n我们现在想通过正好$10^{18}$次操作，使得$S_i=T_i$。\n每次操作如下：\n选择$(i,j)$，交换$S_i$和$S_j$。 试问能否达成目标？\n输入格式\r$S_1~S_2~S_3$\n$T_1~T_2~T_3$\n输出格式\r如果能达成目标，输出Yes；否则，输出No。\n样例\r样例输入\r1 2 R G B R G B 样例输出\r1 Yes 分析\r本题情况不多，可以手动枚举所有可能的情况，最终发现所有$S_i=T_i$或者所有$S_i\\ne T_i$时输出Yes，否则输出No。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char a, b, c, d, e, f; scanf(\u0026#34;%c %c %c %c %c %c\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d, \u0026amp;e, \u0026amp;f); puts(((a == d) + (b == e) + (c == f)) == 1? \u0026#34;No\u0026#34;: \u0026#34;Yes\u0026#34;); return 0; } E - King Bombee\r题目大意\r给定由$N$个点、$M$条边组成的简单无向图。第$i$条边连接顶点$U_i$和$V_i$。\n求图中从$S$到$T$、长度为$K$且经过顶点$X$偶数次的路径的数量，==对$998244353$取模==。\n$2\\le N\\le 2000$\n$1\\le M\\le 2000$\n$1\\le K\\le 2000$\n$1\\le S,T,X\\le N$\n$X\\ne S,X\\ne T$\n$1\\le U_i \u003c V_i\\le N$\n$(U_i,V_i)\\ne(U_j,V_j)$（$i\\ne j$）\n输入格式\r$N~M~K~S~T~X$\n$U_1~V_1$\n$\\vdots$\n$U_N~V_N$\n输出格式\r输出图中从$S$到$T$、长度为$K$且经过顶点$X$偶数次的路径的数量，==对$998244353$取模==。\n样例\r样例输入1\r1 2 3 4 5 4 4 4 1 3 2 1 2 2 3 3 4 1 4 样例输出1\r1 4 有$4$条符合条件的路径：\n$1\\to2\\to1\\to2\\to3$ $1\\to2\\to3\\to2\\to3$ $1\\to4\\to1\\to4\\to3$ $1\\to4\\to3\\to4\\to3$ 注意$X=2$必须出现偶数次。\n样例输入2\r1 2 3 4 5 6 6 5 10 1 2 3 2 3 2 4 4 6 3 6 1 5 样例输出2\r1 0 这张图没有连通。\n样例输入3\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 10 15 20 4 4 6 2 6 2 7 5 7 4 5 2 4 3 7 1 7 1 4 2 9 5 10 1 3 7 8 7 9 1 6 1 2 样例输出3\r1 952504739 注意==对$998244353$取模==。\n分析\r$$\\mathrm{dp}(i,j)=\\sum_{k=1}^{|G_j|} \\mathrm{dp}(i-1,{G_j}_k)$$\n再考虑$X$必须是偶数的情况，令$\\mathrm{dp}(i,j,k)=~$第$i$步走到$j$且$X$的出现次数除以$2$的余数为$k$的情况，则每次额外判断${G_j}_k$是否等于$X$即可。\n$\\mathrm{DP}$状态转移方程详见代码。\n代码\r注意：代码中运用了滚动表的优化，可以节省空间，当然也可以使用普通写法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 2005 #define MOD 998244353 using namespace std; inline void mod(int\u0026amp; x) { if(x \u0026gt;= MOD) x -= MOD; } vector\u0026lt;int\u0026gt; G[maxn]; int dp[2][maxn][2]; int main() { int n, m, k, s, t, x; scanf(\u0026#34;%d%d%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k, \u0026amp;s, \u0026amp;t, \u0026amp;x); x --; while(m--) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[--u].push_back(--v); G[v].push_back(u); } dp[0][--s][0] = 1; for(int i=1; i\u0026lt;=k; i++) { bool c = i \u0026amp; 1, p = i \u0026amp; 1 ^ 1; for(int v=0; v\u0026lt;n; v++) { dp[c][v][0] = dp[c][v][1] = 0; for(int u: G[v]) mod(dp[c][v][0] += dp[p][u][u == x]), mod(dp[c][v][1] += dp[p][u][u != x]); } } printf(\u0026#34;%d\\n\u0026#34;, dp[k \u0026amp; 1][--t][0]); return 0; } F - Shortest Good Path\r分析\r令$\\mathrm{dis}[S][j]=~$于点$j$结束的good path with respest to S的最短长度，跑一遍$\\text{BFS}$即可。具体实现时可将$S$按位压缩为二进制，加快运算速度。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define INF 2147483647 #define maxn 17 using namespace std; using ULL = unsigned long long; int dis[1 \u0026lt;\u0026lt; maxn][maxn]; vector\u0026lt;int\u0026gt; G[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[--u].push_back(--v); G[v].push_back(u); } queue\u0026lt;ULL\u0026gt; q; for(int i=0; i\u0026lt;n; i++) dis[1 \u0026lt;\u0026lt; i][i] = 1, q.push(1ULL\u0026lt;\u0026lt;i+32^i); while(!q.empty()) { ULL pkg = q.front(); q.pop(); int st = pkg \u0026gt;\u0026gt; 32ULL, v = pkg \u0026amp; 0x7fffffff; int nd = dis[st][v] + 1; for(int u: G[v]) { int nst = st ^ (1 \u0026lt;\u0026lt; u); if(dis[nst][u] == 0) { dis[nst][u] = nd; q.push(ULL(nst) \u0026lt;\u0026lt; 32ULL ^ u); } } } long long ans = 0LL; for(int i=1, lim=1\u0026lt;\u0026lt;n; i\u0026lt;lim; i++) { int cur = INF; for(int j=0; j\u0026lt;n; j++) if(dis[i][j] \u0026gt; 0 \u0026amp;\u0026amp; dis[i][j] \u0026lt; cur) cur = dis[i][j]; ans += cur; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2022-03-20T21:49:00+08:00","permalink":"https://goodcoder666.github.io/p/abc244/","title":"AtCoder Beginner Contest 244 D~F 题解"},{"content":"前言\r最近突然想知道自己总共写了多少行代码，于是做了这样一个小工具……\n准备工作\r先考虑一下希望得到的效果：\nLanguage（语言） Lines（代码行数） Size（代码文件总大小） Files（代码文件总数） A 12345 300 KB 193 B 2345 165 KB 98 如上，程序输出一个表格，将代码行数作为关键字排序。 代码框架： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # -*- encoding: utf-8 -*- import ... # 代码行数计数类 class CodeLinesCounter(object): SIZES = [(\u0026#39;B\u0026#39;, 1), (\u0026#39;KB\u0026#39;, 1024), (\u0026#39;MB\u0026#39;, 1024**2), (\u0026#39;GB\u0026#39;, 1024**3), (\u0026#39;TB\u0026#39;, 1024**4)] def __init__(self, languages): self._languages = languages # 语言（dict,{文件后缀名：语言}） self._codelines = {suffix: (0, 0, 0) for suffix in languages} # 统计结果，{后缀名：(行数，大小，文件数)} self._successful = self._error = 0 # 记录成功、失败文件个数 # @param directory: 要扫描的目录 # @param log: 是否打印日志 def scan(self, directory, log=False): if log: print(\u0026#39;Scanning\u0026#39;, directory) pass def report(self): # 输出结果 pass counter = CodeLinesCounter(languages={\u0026#39;py\u0026#39;: \u0026#39;Python\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;cpp\u0026#39;: \u0026#39;C++\u0026#39;, \u0026#39;java\u0026#39;: \u0026#39;Java\u0026#39;, \u0026#39;js\u0026#39;: \u0026#39;JavaScript\u0026#39;, \u0026#39;html\u0026#39;: \u0026#39;HTML\u0026#39;, \u0026#39;css\u0026#39;: \u0026#39;CSS\u0026#39;, \u0026#39;txt\u0026#39;: \u0026#39;Plain text\u0026#39;}) # 创建CodeLinesCounter实例 counter.scan(\u0026#39;E:/\u0026#39;) # 扫描E盘（注意不能用\u0026#39;E:\u0026#39;） counter.report() # 输出结果 完成，下面正式进入==主要部分==\n统计\r文件扫描\r首先，我们需要获取根目录下的文件列表。这可以用os.walk实现：\nos.walk(rootdir)返回一个游走器（可迭代），包含根目录下每个子目录的文件及目录列表。我们来看一个例子：\n有一文件夹Folder如下：\n1 2 3 4 5 6 7 8 Folder | file1 | Folder1 | file2 | file3 | Folder2 | file4 | Folder3 运行如下代码：\n1 2 3 4 import os for root, dirs, files in os.walk(\u0026#39;Folder\u0026#39;): print(root, dirs, files) 则输出如下：\n1 2 3 4 Folder\t[\u0026#39;Folder1\u0026#39;, \u0026#39;Folder2\u0026#39;]\t[\u0026#39;file1\u0026#39;] Folder\\Folder1\t[]\t[\u0026#39;file2\u0026#39;, \u0026#39;file3\u0026#39;] Folder\\Folder2\t[\u0026#39;Folder3\u0026#39;]\t[\u0026#39;file4\u0026#39;] Folder\\Folder2\\Folder3\t[]\t[] 其中第一项是当前的根目录，第二项为目录下的目录列表，第三项则为当前的文件列表。\n因此，我们可以编写如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # -*- encoding: utf-8 -*- from os.path import join, getsize, abspath from os import walk class CodeLinesCounter(object): SIZES = [(\u0026#39;B\u0026#39;, 1), (\u0026#39;KB\u0026#39;, 1024), (\u0026#39;MB\u0026#39;, 1024**2), (\u0026#39;GB\u0026#39;, 1024**3), (\u0026#39;TB\u0026#39;, 1024**4)] def __init__(self, languages): self._languages = languages self._results = {suffix: (0, 0, 0) for suffix in languages} self._successful = self._error = 0 def scan(self, directory, log=False): if log: print(\u0026#39;Scanning\u0026#39;, directory) try: for root, _, files in walk(abspath(directory)): for filename in files: suffix = filename[filename.rfind(\u0026#39;.\u0026#39;) + 1:] filename = join(root, filename) if suffix in self._results: lines, size, numFiles = self._results[suffix] lines += 1 # 暂不统计，先按一行计算 numFiles += 1 size += getsize(filename) # getsize返回文件大小（字节） self._results[suffix] = (lines, size, numFiles) if log: print(filename) except KeyboardInterrupt: print(\u0026#39;\\nUser stopped operation\u0026#39;) else: if log: print(\u0026#39;Scan finished\u0026#39;) def report(self): print(\u0026#39;Language\\tLines\\tSize\\tFiles\u0026#39;) for suffix, (lines, size, files) in sorted(self._results.items(), key=lambda x: x[1], reverse=True): print(self._languages[suffix], lines, self.__format_size(size), files, sep=\u0026#39;\\t\u0026#39;) # 单位转换 def __format_size(self, bytes): for suffix, size in self.SIZES: if bytes \u0026lt; size * 1024: return \u0026#39;%.2f %s\u0026#39; % (bytes / size, suffix) return \u0026#39;%.2f %s\u0026#39; % (bytes / self.SIZES[-1][1], 2, self.SIZES[-1][0]) counter = CodeLinesCounter(languages={\u0026#39;py\u0026#39;: \u0026#39;Python\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;cpp\u0026#39;: \u0026#39;C++\u0026#39;, \u0026#39;java\u0026#39;: \u0026#39;Java\u0026#39;, \u0026#39;js\u0026#39;: \u0026#39;JavaScript\u0026#39;, \u0026#39;html\u0026#39;: \u0026#39;HTML\u0026#39;, \u0026#39;css\u0026#39;: \u0026#39;CSS\u0026#39;, \u0026#39;txt\u0026#39;: \u0026#39;Plain text\u0026#39;}) counter.scan(\u0026#39;E:/\u0026#39;) counter.report() 运行结果应类似于下面这样（手动整理了一下）：\n1 2 3 4 5 6 7 8 9 Language Lines Size Files C++ 667 671.51 KB 667 Python 317 981.01 KB 317 HTML 38 466.52 KB 38 Plain text 34 90.69 KB 34 JavaScript 19 1.43 MB\t19 CSS 9 341.04 KB 9 C 2 20.45 KB 2 Java 1 676.00 B 1 好，下面来到行数统计部分（表格输出后面会介绍）。\n行数统计\r众所周知，空行不应该算在代码行数中。因此，统计时需忽略空行。先写上如下代码（替换掉刚才的23行）：\n1 2 3 4 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: # utf-8编码打开文件 for line in f: if line and not line.isspace(): # 去掉空行 lines += 1 但是，正当我们兴致勃勃地运行时——\n1 2 3 4 5 Traceback (most recent call last): ... File \u0026#34;...\\lib\\codecs.py\u0026#34;, line 322, in decode (result, consumed) = self._buffer_decode(data, self.errors, final) UnicodeDecodeError: \u0026#39;utf-8\u0026#39; codec can\u0026#39;t decode byte 0xb5 in position 355: invalid start byte 程序报错UnicodeDecodeError，分析后发现原因是部分文件使用了GBK编码，而utf-8编码无法正确打开，因此造成错误。\n我们再次改进程序，使其尝试两种编码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 try: ln = 0 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: for line in f: if line and not line.isspace(): ln += 1 except UnicodeDecodeError: # 尝试使用GBK编码打开 try: ln = 0 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;gbk\u0026#39;) as f: for line in f: if line and not line.isspace(): ln += 1 except: print(filename, \u0026#39;[Error: unknown encoding]\u0026#39;) self._error += 1 else: lines += ln except Exception as e: print(filename, \u0026#39;[Unknown error: %s]\u0026#39; % e) self._error += 1 continue lines += ln if log: print(f\u0026#39;{filename} [{ln}]\u0026#39;) self._successful += 1 这次，我们得到了正确的结果：\n1 2 3 4 5 6 7 8 9 Language Lines Size Files C++ 35595 671.51 KB 667 JavaScript 24485 1.43 MB 19 Python 24130 982.16 KB 317 CSS 8203 341.04 KB 9 HTML 6138 466.52 KB 38 Plain text 741 90.69 KB 34 C 557 20.45 KB 2 Java 29 676.00 B 1 现在仅剩最后一步了——制表。\n制表\rpython输出表格可以使用PrettyTable库。具体用法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 # -*- encoding: utf-8 -*- from os.path import join, getsize, abspath from os import walk from prettytable import PrettyTable class CodeLinesCounter(object): SIZES = [(\u0026#39;B\u0026#39;, 1), (\u0026#39;KB\u0026#39;, 1024), (\u0026#39;MB\u0026#39;, 1024**2), (\u0026#39;GB\u0026#39;, 1024**3), (\u0026#39;TB\u0026#39;, 1024**4)] def __init__(self, languages): self._languages = languages self._results = {suffix: (0, 0, 0) for suffix in languages} self._successful = self._error = 0 def scan(self, directory, log=False): if log: print(\u0026#39;Scanning\u0026#39;, directory) try: for root, _, files in walk(abspath(directory)): for filename in files: suffix = filename[filename.rfind(\u0026#39;.\u0026#39;) + 1:] filename = join(root, filename) if suffix in self._results: lines, size, numFiles = self._results[suffix] numFiles += 1 size += getsize(filename) try: ln = 0 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: for line in f: if line and not line.isspace(): ln += 1 except UnicodeDecodeError: # Try \u0026#39;gbk\u0026#39; encoding try: ln = 0 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;gbk\u0026#39;) as f: for line in f: if line and not line.isspace(): ln += 1 except: print(filename, \u0026#39;[Error: unknown encoding]\u0026#39;) self._error += 1 else: lines += ln except Exception as e: print(filename, \u0026#39;[Unknown error: %s]\u0026#39; % e) self._error += 1 continue lines += ln if log: print(f\u0026#39;{filename} [{ln}]\u0026#39;) self._successful += 1 self._results[suffix] = (lines, size, numFiles) elif log: print(filename, \u0026#39;[None]\u0026#39;) except KeyboardInterrupt: print(\u0026#39;\\nUser stopped operation\u0026#39;) else: if log: print(\u0026#39;Scan finished\u0026#39;) def report(self): table = PrettyTable([\u0026#39;Language\u0026#39;, \u0026#39;Lines\u0026#39;, \u0026#39;Size\u0026#39;, \u0026#39;Files\u0026#39;], title=f\u0026#39;Scan result (OK {self._successful}, Error {self._error})\u0026#39;) # 创建PrettyTable实例，添加标题 for suffix, (lines, size, files) in sorted(self._results.items(), key=lambda x: x[1], reverse=True): table.add_row([self._languages[suffix], lines, self.__format_size(size), files]) # 添加行 print(table) # 输出 def __format_size(self, bytes): for suffix, size in self.SIZES: if bytes \u0026lt; size * 1024: return \u0026#39;%.2f %s\u0026#39; % (bytes / size, suffix) return \u0026#39;%.2f %s\u0026#39; % (bytes / self.SIZES[-1][1], 2, self.SIZES[-1][0]) counter = CodeLinesCounter(languages={\u0026#39;py\u0026#39;: \u0026#39;Python\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;cpp\u0026#39;: \u0026#39;C++\u0026#39;, \u0026#39;java\u0026#39;: \u0026#39;Java\u0026#39;, \u0026#39;js\u0026#39;: \u0026#39;JavaScript\u0026#39;, \u0026#39;html\u0026#39;: \u0026#39;HTML\u0026#39;, \u0026#39;css\u0026#39;: \u0026#39;CSS\u0026#39;, \u0026#39;txt\u0026#39;: \u0026#39;Plain text\u0026#39;}) counter.scan(\u0026#39;E:/\u0026#39;) counter.report() 运行结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 +----------------------------------------+ | Scan result (OK 1087, Error 0) | +------------+-------+-----------+-------+ | Language | Lines | Size | Files | +------------+-------+-----------+-------+ | C++ | 35595 | 671.51 KB | 667 | | JavaScript | 24485 | 1.43 MB | 19 | | Python | 24130 | 982.16 KB | 317 | | CSS | 8203 | 341.04 KB | 9 | | HTML | 6138 | 466.52 KB | 38 | | Plain text | 741 | 90.69 KB | 34 | | C | 557 | 20.45 KB | 2 | | Java | 29 | 676.00 B | 1 | +------------+-------+-----------+-------+ 总结\r最终代码（无注释）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 # -*- encoding: utf-8 -*- from os.path import join, getsize, abspath from os import walk from prettytable import PrettyTable class CodeLinesCounter(object): SIZES = [(\u0026#39;B\u0026#39;, 1), (\u0026#39;KB\u0026#39;, 1024), (\u0026#39;MB\u0026#39;, 1024**2), (\u0026#39;GB\u0026#39;, 1024**3), (\u0026#39;TB\u0026#39;, 1024**4)] def __init__(self, languages): self._languages = languages self._results = {suffix: (0, 0, 0) for suffix in languages} self._successful = self._error = 0 def scan(self, directory, log=False): if log: print(\u0026#39;Scanning\u0026#39;, directory) try: for root, _, files in walk(abspath(directory)): for filename in files: suffix = filename[filename.rfind(\u0026#39;.\u0026#39;) + 1:] filename = join(root, filename) if suffix in self._results: lines, size, numFiles = self._results[suffix] numFiles += 1 size += getsize(filename) try: ln = 0 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: for line in f: if line and not line.isspace(): ln += 1 except UnicodeDecodeError: # Try \u0026#39;gbk\u0026#39; encoding try: ln = 0 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;gbk\u0026#39;) as f: for line in f: if line and not line.isspace(): ln += 1 except: print(filename, \u0026#39;[Error: unknown encoding]\u0026#39;) self._error += 1 else: lines += ln except Exception as e: print(filename, \u0026#39;[Unknown error: %s]\u0026#39; % e) self._error += 1 continue lines += ln if log: print(f\u0026#39;{filename} [{ln}]\u0026#39;) self._successful += 1 self._results[suffix] = (lines, size, numFiles) elif log: print(filename, \u0026#39;[None]\u0026#39;) except KeyboardInterrupt: print(\u0026#39;\\nUser stopped operation\u0026#39;) else: if log: print(\u0026#39;Scan finished\u0026#39;) def report(self): table = PrettyTable([\u0026#39;Language\u0026#39;, \u0026#39;Lines\u0026#39;, \u0026#39;Size\u0026#39;, \u0026#39;Files\u0026#39;], title=f\u0026#39;Scan result (OK {self._successful}, Error {self._error})\u0026#39;) for suffix, (lines, size, files) in sorted(self._results.items(), key=lambda x: x[1], reverse=True): table.add_row([self._languages[suffix], lines, self.__format_size(size), files]) print(table) def __format_size(self, bytes): for suffix, size in self.SIZES: if bytes \u0026lt; size * 1024: return \u0026#39;%.2f %s\u0026#39; % (bytes / size, suffix) return \u0026#39;%.2f %s\u0026#39; % (bytes / self.SIZES[-1][1], 2, self.SIZES[-1][0]) counter = CodeLinesCounter(languages={\u0026#39;py\u0026#39;: \u0026#39;Python\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;cpp\u0026#39;: \u0026#39;C++\u0026#39;, \u0026#39;java\u0026#39;: \u0026#39;Java\u0026#39;, \u0026#39;js\u0026#39;: \u0026#39;JavaScript\u0026#39;, \u0026#39;html\u0026#39;: \u0026#39;HTML\u0026#39;, \u0026#39;css\u0026#39;: \u0026#39;CSS\u0026#39;, \u0026#39;txt\u0026#39;: \u0026#39;Plain text\u0026#39;}) counter.scan(\u0026#39;E:/\u0026#39;) counter.report() 后期改进：\n增加正则表达式忽略文件 matplotlib绘图 PyQt5GUI ……（欢迎提出宝贵的意见！） ","date":"2022-03-15T15:24:00+08:00","permalink":"https://goodcoder666.github.io/p/py_codelinescounter/","title":"【Python】72行实现代码行数统计，简单实用！"},{"content":"C - 1111gal password\r题目大意\r给定正整数$N$，求符合下列条件的整数$X$的个数，对$998244353$取模：\n$X$是$N$位的正整数 $X$的每一位数都在$[1,9]$之间（==0不行==）； $X$的相邻两位数之差的绝对值不超过$1$。 $2\\le N\\le 10^6$\n输入格式\r$N$\n输出格式\r输出答案。\n样例\r$N$ 输出 $4$ $203$ $2$ $25$ $1000000$ $248860093$ 分析\r$$\rf(i,j)=\\begin{cases}\r1\u0026(i=1)\\\\\rf(i-1,1)+f(i-1,2)\u0026(j=1)\\\\\rf(i-1,8)+f(i-1,9)\u0026(j=9)\\\\\rf(i-1,j-1)+f(i-1,j)+f(i-1,j+1)\u0026(i\u003e1,2\\le j\\le8)\r\\end{cases}\r$$\n因此，直接输出$\\sum\\limits_{i=1}^9f(n,i)$即可。\n代码\r本代码运用了滚动表的优化，当然也可以直接开$N\\times9$大小的数组，但这样会导致内存占用大，不建议使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;cstdio\u0026gt; #define MOD 998244353 using namespace std; inline void mod(int\u0026amp; x) { if(x \u0026gt;= MOD) x -= MOD; } int dp[9], ldp[9]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;9; i++) dp[i] = 1; while(--n) { for(int i=0; i\u0026lt;9; i++) ldp[i] = dp[i]; mod(dp[0] += dp[1]), mod(dp[8] += dp[7]); for(int i=1; i\u0026lt;8; i++) mod(dp[i] += ldp[i - 1]), mod(dp[i] += ldp[i + 1]); } int ans = 0; for(int i=0; i\u0026lt;9; i++) mod(ans += dp[i]); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - ABC Transform\r题目大意\r给定由A、B、C组成的字符串$S$。令$S_0=S$，$S_i=S_{i-1}$将A、B、C分别替换为BC、CA、AB的新字符串。\n回答$Q$个查询，第$i$个查询的问题如下：\n求$S_{t_i}$的第$k_i$个字母。 $1\\le |S|\\le 10^5$\n$1\\le Q\\le 10^5$\n$1\\le t_i\\le 10^{18}$\n$1\\le k_i\\le min(10^{18},S_{t_i}$的长度$)$\n输入格式\r$S$\n$Q$\n$t_1~k_1$\n$\\vdots$\n$t_Q~k_Q$\n样例\r样例输入1\r1 2 3 4 5 6 ABC 4 0 1 1 1 1 3 1 6 样例输出1\r1 2 3 4 A B C B $S_0=~$ABC $S_1=~$AABCB 样例输入2\r1 2 3 4 5 6 7 CBBAACCCCC 5 57530144230160008 659279164847814847 29622990657296329 861239705300265164 509705228051901259 994708708957785197 176678501072691541 655134104344481648 827291290937314275 407121144297426665 样例输出2\r1 2 3 4 5 A A C A A 注意小心整数溢出问题。\n分析\r$$\rf(t,k)=\\begin{cases}\r0 \u0026 (t=0)\\\\\rg(0,t) \u0026 (k=0)\\\\\rg(f(t-1,\\lfloor\\frac k2\\rfloor),(k\\bmod2)+1) \u0026 (t\u003e0,k\u003e0)\r\\end{cases}\r$$\n其中$g(c,x)$为字符$c$在A,B,C,A,...这个环中$c$后面的第$x$个字符，即$g(c,x)=(c+x)\\bmod3$。\n因此，我们只要求出$x$在$S$的哪个字符分解后的结果中，再计算$f$即可。\n答案为$\\mathrm{ans}=g(f(t,(k-1)\\bmod2^t),S_{\\lfloor\\frac {k-1}{2t}\\rfloor})$。\n代码\r以下两种示范代码均使用非递归形式，当然也可使用递归形式。\n代码1（标准）\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;cstdio\u0026gt; using namespace std; char s[100005]; int main() { scanf(\u0026#34;%s\u0026#34;, s); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while(q--) { long long t, k; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;t, \u0026amp;k); k --; int x = s[t \u0026lt; 64? k \u0026gt;\u0026gt; t: 0] - \u0026#39;A\u0026#39;; // 防止t太大导致RE while(t \u0026gt; 0 \u0026amp;\u0026amp; k \u0026gt; 0) { x = (x + int(k \u0026amp; 1LL) + 1) % 3; k \u0026gt;\u0026gt;= 1LL, t --; } putchar((t + x) % 3 + \u0026#39;A\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); } return 0; } 代码2（优化）\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; using namespace std; char s[100005]; int main() { scanf(\u0026#34;%s\u0026#34;, s); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while(q--) { long long t, k; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;t, \u0026amp;k); k --; int c = 0; if(t \u0026lt; 64) { c = s[k \u0026gt;\u0026gt; t] - \u0026#39;A\u0026#39;; k \u0026amp;= (1LL \u0026lt;\u0026lt; t) - 1LL; } else c = s[0] - \u0026#39;A\u0026#39;; for(c+=t%3; k\u0026gt;0; k\u0026amp;=k-1) c ++; putchar(c % 3 + \u0026#39;A\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); } return 0; } E - (∀x∀)\r题目大意\r对于$T$个测试点，分别解决下列问题：\n给定整数$N$和字符串$S$，求合法字符串$X$的个数，使其符合下列条件：\n$|X|=N$ $X$由大写英文字母组成，是一个回文串 按字典序，==$X\\le S$== $1\\le T\\le 250000$\n$1\\le N\\le 10^6$\n$1\\le \\sum N\\le 10^6$\n$|S|=N$且由大写英文字母组成。\n分析\r显然，通过$X$的前$\\lceil\\frac N2\\rceil$个字符就可以确定唯一的$X$。下面，我们以ABCDE为例：\nABCDE的前$\\lceil\\frac N2\\rceil$个字符分别为ABC 字典序小于ABC的字符串有$28$个（可看作一个$26$进制数来计算） 判断ABCBA是否可行，与ABCDE比较 可行，答案增加$1$得到$29$ 因此，我们输出$29$。其他情况类似。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;cstdio\u0026gt; #define maxn 1000005 #define MOD 998244353 using namespace std; using LL = long long; char s[maxn]; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d%s\u0026#34;, \u0026amp;n, s); long long x = 0LL; int j = n - 1 \u0026gt;\u0026gt; 1; for(int i=0; i\u0026lt;=j; i++) (x = x * 26LL + s[i] - \u0026#39;A\u0026#39;) %= MOD; bool ok = true; while(j \u0026gt;= 0) { if(s[j] \u0026lt; s[n - 1 - j]) break; if(s[j] \u0026gt; s[n - 1 - j]) { ok = false; break;} j --; } if(ok \u0026amp;\u0026amp; ++x == MOD) x -= MOD; printf(\u0026#34;%lld\\n\u0026#34;, x); } return 0; } ","date":"2022-03-08T22:30:00+08:00","permalink":"https://goodcoder666.github.io/p/abc242/","title":"AtCoder Beginner Contest 242 C~E 题解"},{"content":"D - Sequence Query\r题目大意\r我们有一个空序列$A$。请依次处理$Q$个命令，每个命令有三种类型，每种类型的格式如下：\n1 x：将$x$加入$A$（不去重） 2 x k：求在$A$的$\\le x$的元素中，第$k$大的值。 3 x k：求在$A$的$\\ge x$的元素中，第$k$小的值。 $1\\le Q\\le 2\\times 10^5$\n$1\\le x\\le 10^{18}$\n==$1\\le k\\le 5$==\n分析\r注意题面中的$1\\le k\\le 5$，我们可以用multiset解决问题。\nmultiset顾名思义，就是不去重的set，支持二分查找操作。关于multiset的具体用法，请看这里\n对于每个查询，我们作如下处理：\n1 x：直接加入multiset 2 x k：先upper_bound，再将iterator向前移动$k$步 3 x k：先lower_bound，再将iterator向后移动$k$步 前面提到，因为$k$的值很小，所以移动iterator的时间复杂度可以忽略不计。\n因此，总时间复杂度最优为$\\mathcal O(Q)$，平均$\\mathcal O(Q\\log Q)$，最坏$\\mathcal O(Q\\log Q)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { multiset\u0026lt;long long\u0026gt; s; int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while(q--) { int op; long long x; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;op, \u0026amp;x); if(op == 1) s.insert(x); else { int k; scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); if(op == 2) { bool bad = false; auto it = s.upper_bound(x); for(; k--; --it) if(it == s.begin()) { bad = true; break; } if(bad) puts(\u0026#34;-1\u0026#34;); else printf(\u0026#34;%lld\\n\u0026#34;, *it); } else { auto it = s.lower_bound(x); for(; --k; ++it) if(it == s.end()) break; if(it == s.end()) puts(\u0026#34;-1\u0026#34;); else printf(\u0026#34;%lld\\n\u0026#34;, *it); } } } return 0; } E - Putting Candies\r题目大意\r给定长度为$N$的序列$A=(A_0,A_1,\\dots,A_{N-1})$。\n有一个空盘子。Takahashi每次会在其中加入$A_{(X\\bmod N)}$颗糖果（$X$是当前盘子中糖果的数量）。\n求$K$次操作后的糖果总数。\n$2\\le N\\le 2\\times 10^5$\n$1\\le K\\le 10^{12}$\n$1\\le A_i\\le 10^6$\n分析\r根据鸽笼原理（又称抽屉原理），$A_{(X\\bmod N)}$的结果在最多$N$次操作后一定会重复。\n因此，这道题可以看作数学上的一道周期问题。（又是数学题?!）\n我们只需分别记录结果对应的时间和时间对应的结果即可。\n最终总时间复杂度$\\mathcal O(n)$，空间复杂度$\\mathcal O(n)$。\n代码\r代码参考：AtCoder官方题解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; using LL = long long; LL A[maxn], S[maxn]; int pre[maxn]; int main() { int n; LL k; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%lld\u0026#34;, A + i); for(int i=1; i\u0026lt;n; i++) pre[i] = -1; int time, s; for(int i=0; i\u0026lt;n; i++) { S[i + 1] = S[i] + A[S[i] % n]; if(pre[S[i + 1] % n] != -1) { s = pre[S[i + 1] % n]; time = i + 1; break; } pre[S[i + 1] % n] = i + 1; } if(k \u0026lt;= s) printf(\u0026#34;%lld\\n\u0026#34;, S[k]); else { int p = time - s; LL X = S[time] - S[s], t = k - s - 1; printf(\u0026#34;%lld\\n\u0026#34;, S[s + t % p + 1] + t / p * X); } return 0; } F - Skate\r题目大意\r有一个$H\\times W$的网格。网格上有$N$个障碍物，第$i$个的位置是$(X_i,Y_i)$。\n我们从$(s_x,s_y)$开始，每一步向上、下、左、右中的一个方向行走，直到撞上障碍物，停在它前面的方格中。求到达$(g_x,g_y)$所用的最少步数。若无法到达终点，输出-1。\n$1\\le H,W\\le 10^9$\n==$1\\le N\\le 10^5$==\n$1\\le s_x,g_x,X_i\\le H$\n$1\\le s_y,g_y,Y_i\\le W$\n$(s_x,g_x)\\ne(g_x,g_y)\\ne(X_i,Y_i)$\n$(X_i,Y_i)\\ne(X_j,Y_j)$（$i\\ne j$）\n分析\r这道题看似数据范围很大，实则不然。因为$N$只有$10^5$，所以我们很容易想到使用$\\text{BFS}$，用map存储每行每列，对于每个坐标，二分查找当前行/列中的位置即可。\n代码\r写代码时注意事项主要有两点：\n行和列的坐标一定要排序，也可以用set 注意二分边界情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; using LL = long long; unordered_map\u0026lt;int, set\u0026lt;int\u0026gt;\u0026gt; row, col; unordered_map\u0026lt;LL, int\u0026gt; dis; inline LL pack(LL x, int y) { return x \u0026lt;\u0026lt; 31LL | y; } inline void unpack(const LL\u0026amp; b, int\u0026amp; x, int\u0026amp; y) { x = b \u0026gt;\u0026gt; 31LL, y = b \u0026amp; 0x7fffffff; } int main() { int h, w, n, sx, sy, gx, gy; scanf(\u0026#34;%d%d%d%d%d%d%d\u0026#34;, \u0026amp;h, \u0026amp;w, \u0026amp;n, \u0026amp;sx, \u0026amp;sy, \u0026amp;gx, \u0026amp;gy); for(int i=0; i\u0026lt;n; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); row[x].insert(y); col[y].insert(x); } LL target = pack(gx, gy); queue\u0026lt;pair\u0026lt;LL, int\u0026gt;\u0026gt; q; q.emplace(pack(sx, sy), 0); while(!q.empty()) { auto [p, d] = q.front(); q.pop(); if(!dis.emplace(p, d).second) continue; if(p == target) { printf(\u0026#34;%d\\n\u0026#34;, d); return 0; } int x, y; unpack(p, x, y), ++d; if(row.count(x)) { auto\u0026amp; s = row[x]; auto it = s.lower_bound(y); if(it != s.end()) q.emplace(pack(x, *it - 1), d); if(it != s.begin()) q.emplace(pack(x, *--it + 1), d); } if(col.count(y)) { auto\u0026amp; s = col[y]; auto it = s.lower_bound(x); if(it != s.end()) q.emplace(pack(*it - 1, y), d); if(it != s.begin()) q.emplace(pack(*--it + 1, y), d); } } puts(\u0026#34;-1\u0026#34;); return 0; } ","date":"2022-03-05T23:01:00+08:00","permalink":"https://goodcoder666.github.io/p/abc241/","title":"AtCoder Beginner Contest 241 (Sponsored by Panasonic) D~F 题解"},{"content":"C - Knight Fork\r题目大意\r在二维平面上是否有一个整数坐标点到$(x_1,y_1)$和$(x_2,y_2)$的欧几里得距离都是$\\sqrt5$？\n输入格式\r$x_1~y_1~x_2~y_2$\n输出格式\r如果存在符合条件的点，输出Yes；否则，输出No。\n样例\r$x_1$ $y_1$ $x_2$ $y_2$ 输出 $0$ $0$ $3$ $3$ Yes $0$ $1$ $2$ $3$ No $1000000000$ $1000000000$ $999999999$ $999999999$ Yes 分析\r$$\r(a-c)^2+(b-d)^2=5\\\\\r\\{a-c,b-d\\}=\\{1,2\\}\r$$\n所以，对于$(0,0)$这个点，有如下距离为$\\sqrt5$的点（其他点都类似）：\n所以，我们对找到$(x_1,y_1)$所有的距离为$\\sqrt5$的点，并对计算与$(x_2,y_2)$的距离即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; using namespace std; using LL = long long; const int d[8] = {-1, 1, 2, 2, 1, -1, -2, -2}; inline LL sqr2(const LL\u0026amp; x, const LL\u0026amp; y) { return x * x + y * y; } int main() { LL x1, y1, x2, y2; scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2); x1 -= x2, y1 -= y2; for(int i=0; i\u0026lt;8; i++) if(sqr2(x1 + d[i], y1 + d[(i + 2) \u0026amp; 7]) == 5) { puts(\u0026#34;Yes\u0026#34;); return 0; } puts(\u0026#34;No\u0026#34;); return 0; } D - Prime Sum Game\r==水题警告==\n题目大意\rTakahashi和Aoki在玩一个游戏。游戏过程如下：\nTakahashi在中选择一个整数$A\\le N\\le B$。 Aoki中选择一个整数$C\\le M\\le D$。 如果$N+M$是质数，Aoki获胜。否则，Takahashi获胜。 当两人都按最优策略游戏时，谁会赢得比赛？\n$1\\le A\\le B\\le 100$\n$1\\le C\\le D\\le 100$\n输入格式\r$A~B~C~D$\n输出格式\r输出胜者的名字，即Takahashi或Aoki。\n样例\r$A$ $B$ $C$ $D$ 输出 $2$ $3$ $3$ $4$ Aoki $1$ $100$ $50$ $60$ Takahashi $3$ $14$ $1$ $5$ Aoki 分析\r要解决这道题，首先要知道什么是“最优策略”。\n显然，当Takahashi选择的$N$加上任意的$M$都不是质数时，Takahashi胜利；\n否则，当任意的$N$加上某一个$M$都得到质数时，Aoki胜利。\n因为数据范围较小，我们可以暴力枚举所有$N$和$M$，质数判断耗时可以忽略不计。因此，总时间复杂度约为$\\mathcal O(BD)$。\n代码\rP.S. 不可思议，运行时间居然是$4\\mathrm{ms}$..（本来以为至少也有$30\\mathrm{ms}$的..）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;cstdio\u0026gt; using namespace std; inline bool isprime(int x) { for(int t=__builtin_sqrt(x), i=2; i\u0026lt;=t; i++) if(x % i == 0) return false; return true; } int main() { int a, b, c, d; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); for(int i=a; i\u0026lt;=b; i++) { int j = c; for(; j\u0026lt;=d; j++) if(isprime(i + j)) break; if(j \u0026gt; d) { puts(\u0026#34;Takahashi\u0026#34;); return 0; } } puts(\u0026#34;Aoki\u0026#34;); return 0; } E - Subtree K-th Max\r题目大意\r有一个由$N$个节点（节点$1$，..，节点$N$）组成的树（根节点为节点$1$）。\n第$i$条边连接节点$A_i$和$B_i$。节点$v$有一个数值$X_v$。\n给定$Q$个询问，第$i$个询问由$(V_i,K_i)$组成：\n在以节点$V_i$为根的子树当中，求所有节点的数值的第$K$大值（不去重）。 $2\\le N,Q\\le 10^5$\n$0\\le X_i\\le 10^9$\n$1\\le A_i,B_i,V_i\\le N$\n==$1\\le K_i\\le 20$==\n输入格式\r$N~Q$\n$X_1~\\dots~X_N$\n$A_1~B_1$\n$\\vdots$\n$A_{N-1}~B_{N-1}$\n$V_1~K_1$\n$\\vdots$\n$V_Q~K_Q$\n输出格式\r输出$Q$行。第$i$行应包含对第$i$个询问的回答。\n样例\r略，请自行前往AtCoder查看\n分析\r我们首先发现题面中，$1\\le K\\le 20$。于是我们对每个节点分别存储以它为根的子树中前$20$的数值。\n于是，我们按照拓扑序（或直接$\\text{DFS}$），执行如下操作：\n对于叶子节点，我们只存储一个当前的数值。 对于其他的节点，先排序当前节点数值和所有孩子的前$20$，排序后取前$20$即可。 排序建议用priority_queue，时间复杂度$\\mathcal O(N+Q)$或$\\mathcal O(N\\log N+Q)$（直接排序）。\n代码\r示例代码实现方式为DFS + priority_queue，用时$190\\mathrm{ms}$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define maxn 100005 using namespace std; int x[maxn]; vector\u0026lt;int\u0026gt; G[maxn], dp[maxn]; void dfs(int v, int par) { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; q.push(x[v]); for(int u: G[v]) if(u != par) { dfs(u, v); for(int val: dp[u]) { q.push(val); if(q.size() \u0026gt; 20) q.pop(); } } while(!q.empty()) { dp[v].push_back(q.top()); q.pop(); } } int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, x + i); for(int i=1; i\u0026lt;n; i++) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); G[--a].push_back(--b); G[b].push_back(a); } dfs(0, -1); while(q--) { int v, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;v, \u0026amp;k); const auto\u0026amp; d = dp[--v]; printf(\u0026#34;%d\\n\u0026#34;, d[d.size() - k]); } return 0; } ","date":"2022-02-25T23:08:00+08:00","permalink":"https://goodcoder666.github.io/p/abc239/","title":"Denso Create Programming Contest 2022 (AtCoder Beginner Contest 239) C~E 题解"},{"content":"A - kcal\r题目大意\r我们有一种每$100$毫升含有$A$千卡热量的饮料。$B$毫升的这种饮料含有多少千卡热量？\n$0\\le A, B\\le 1000$\n输入格式\r$A~B$\n输出格式\r输出$B$毫升这种饮料包含的的千卡数。最大允许浮点数精度误差$10^{-6}$。\n样例\r$A$ $B$ 输出 $45$ $200$ $90$ $37$ $450$ $166.5$ $0$ $1000$ $0$ $50$ $0$ $0$ 分析\r废话不多说，答案就是$\\frac{AB}{100}$~\n代码\r1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); a *= b; printf(\u0026#34;%d.%d\\n\u0026#34;, a / 100, a % 100); return 0; } B - Permutation Check\r题目大意\r给定长度为$N$的序列$A=(A_1,A_2,\\dots,A_N)$。\n判断$A$是否为$(1,2,\\dots,N)$的一种排列。\n$1\\le A_i\\le N\\le 10^3$\n输入格式\r$N$\n$A_1~A_2~\\dots~A_N$\n输出格式\r如果$A$是$(1,2,\\dots,N)$的一种排列，输出Yes；否则，输出No。\n样例\r样例输入1\r1 2 5 3 1 2 4 5 样例输出1\r1 Yes $(3,1,2,4,5)$是$(1,2,3,4,5)$的一种排列，所以我们输出Yes。\n样例输入2\r1 2 6 3 1 4 1 5 2 样例输出2\r1 No $(3,1,4,1,5,2)$不是$(1,2,3,4,5,6)$的一种排列，所以我们输出No。\n样例输入3\r1 2 3 1 2 3 样例输出3\r1 Yes 样例输入4\r1 2 1 1 样例输出4\r1 Yes 分析\r由于题目保证$1\\le A_i\\le N$，所以$(1,2,\\dots,N)$的一种排列$A$定义如下：\n$A$中$1$到$N$每个数字不重复出现。 因此，我们可以用数组记录每个数字是否出现，所以总时间复杂度为$\\mathcal O(n)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;cstdio\u0026gt; #define maxn 1005 using namespace std; bool used[maxn]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); if(used[a]) { puts(\u0026#34;No\u0026#34;); return 0; } used[a] = true; } puts(\u0026#34;Yes\u0026#34;); return 0; } C - POW\r题目大意\r给定三个整数$A,B,C$，判断$A^C$和$B^C$哪个更大。\n$-10^9\\le A,B\\le 10^9$\n$1\\le C\\le 10^9$\n输入格式\r$A~B~C$\n输出格式\r本题分如下三种情况输出：\n如果$A^C \u003c B^C$，输出\u0026lt;； 如果$A^C \u003e B^C$，输出\u0026gt;； 如果$A^C = B^C$，输出=。 样例\r$A$ $B$ $C$ 输出 $3$ $2$ $4$ \u0026gt; $-7$ $7$ $2$ = $-8$ $6$ $3$ \u0026lt; 分析\r首先，由于负负得正，$(-a)^2=a^2$。\n这样，我们可以根据奇偶性得出，如果$n$为偶数，$(-a)^n=a^n$；但如果$n$为奇数，则$(-a)^n=-(a^n)$。\n因此，我们只需判断如果$C$为偶数，将$A$替换为$|A|$，再将$B$替换为$|B|$。\n最后，$A$和$B$的大小关系就是$A^C$和$B^C$的大小关系。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); if(!(c \u0026amp; 1)) { if(a \u0026lt; 0) a = -a; if(b \u0026lt; 0) b = -b; } puts(a \u0026lt; b? \u0026#34;\u0026lt;\u0026#34;: a \u0026gt; b? \u0026#34;\u0026gt;\u0026#34;: \u0026#34;=\u0026#34;); return 0; } D - Kth Excluded\r题目大意\r给定长度为$N$的正整数序列$A=(A_1,A_2,\\dots,A_N)$和$Q$次查询。\n在第$i$次查询中，给定正整数$K_i$，求第$K_i$小的不在$A$中的正整数。\n$1\\le N,Q\\le 10^5$\n$1\\le A_1 \u003c A_2 \u003c \\dots \u003c A_N\\le10^{18}$\n$1\\le K_i\\le 10^{18}$\n输入格式\r$N~Q$\n$A_1~A_2~\\dots~A_N$\n$K_1$\n$K_2$\n$\\hspace{5pt}\\vdots$\n$K_N$\n输出格式\r输出$Q$行。第$i$行应该包含第$K_i$小的不在$A$中的正整数。\n样例\r样例输入1\r1 2 3 4 5 4 3 3 5 6 7 2 5 3 样例输出1\r1 2 3 2 9 4 不在$A$中的正整数有$1,2,4,8,9,10,11,\\dots$，其中有：\n第$2$小的$2$； 第$5$小的$9$； 第$3$小的$4$。 因此，我们应该依次输出2，9，4。\n样例输入2\r1 2 3 4 5 2 1 2 3 4 5 1 10 样例输出2\r1 2 6 15 分析\r本题我们可以先预处理出$A$中每个元素比它小的元素的数量，再二分查找即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 100005 using namespace std; using LL = long long; LL a[maxn]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%lld\u0026#34;, a + i); a[i] -= i; } while(q--) { LL k; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;k); printf(\u0026#34;%lld\\n\u0026#34;, k + (upper_bound(a, a + n, k) - a)); } return 0; } E - White and Black Balls\r题目大意\r有多少种排列$N$个白球和$M$个黑球的方法使得下列条件成立？\n对于每个$i$ ($1\\le i\\le N+M$)，设$w_i$和$b_i$分别是最左边$i$个球中白球和黑球的数量，$w_i\\le b_i+K$成立。 答案对$(10^9+7)$取模。\n$0\\le N,M\\le10^6$\n$1\\le N+M$\n$0\\le K\\le N$\n输入格式\r$N~M~K$\n输出格式\r输出答案，对$(10^9+7)$取模。\n样例\r$N$ $M$ $K$ 输出 $2$ $3$ $1$ $9$ $1$ $0$ $0$ $0$ $1000000$ $1000000$ $1000000$ $192151600$ 分析\r首先，本题中合法排列数就是如下符合任意$y\\le x+K$的$(0,0)\\to(M,N)$的最短路径的数量：\n由此可见，如果$N \u003e M+K$（即终点超出限制），答案一定为$0$。\n我们还可以发现，如果没有$y\\le x+K$这个限制，答案为$\\binom{N + M}{N}$。\n我们再考虑不合法的路径数，数量为$\\binom{N + M}{M + K + 1}$。\n因此，答案为$\\binom{N + M}{N}-\\binom{N + M}{M + K + 1}$。\n代码\r这里用AtCoder Library好像比较方便唉~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;atcoder/modint\u0026gt; using namespace std; using modint = atcoder::modint1000000007; modint f(int n, int m) { if(n \u0026lt; 0 || m \u0026lt; 0) return 0; modint ret = 1; for(int i=1; i\u0026lt;=m; i++) ret = ret * (n + i) / i; return ret; } int main() { int n, m, k; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); if(n \u0026gt; m + k) puts(\u0026#34;0\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, (f(n, m) - f(n - k - 1, m + k + 1)).val()); return 0; } ","date":"2021-07-07T16:40:00+08:00","permalink":"https://goodcoder666.github.io/p/abc205/","title":"AtCoder Beginner Contest 205 A~E 题解"},{"content":"A - Square Inequality\r题目大意\r给定三个整数$A,B,C$。判断$A^2+B^2 \u003c C^2$是否成立。\n$0\\le A,B,C\\le 1000$\n输入格式\r$A~B~C$\n输出格式\r如果$A^2+B^2 \u003c C^2$，输出Yes；否则，输出No。\n样例\r$A$ $B$ $C$ 输出 $2$ $2$ $4$ Yes $10$ $10$ $10$ No $3$ $4$ $5$ No 分析\r直接按题意计算即可。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); puts(a * a + b * b \u0026lt; c * c? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Intersection\r题目大意\r给定两个长度为$N$的序列：$A = (A_1, A_2, A_3, \\dots, A_N)$和$B = (B_1, B_2, B_3, \\dots, B_N)$。\n找到符合如下条件的整数$x$的个数：\n对于所有的$1\\le i\\le N$，$A_i\\le x\\le B_i$。 $1\\le N\\le 100$\n$1\\le A_i\\le B_i\\le 1000$\n输入格式\r$N$\n$A_1~A_2~\\dots~A_N$\n$B_1~B_2~\\dots~B_N$\n输出格式\r输出答案。\n样例\r样例输入1\r1 2 3 2 3 2 7 5 样例输出1\r1 3 $x$可以取$3,4,5$。\n样例输入2\r1 2 3 3 1 5 3 10 7 3 样例输出2\r1 0 没有$x$符合条件。\n样例输入3\r1 2 3 3 3 2 5 6 9 8 样例输出3\r1 2 分析\r我们将$x$的限制条件拆解为：\n对于所有的$1\\le i\\le N$，$A_i\\le x$。 对于所有的$1\\le i\\le N$，$x\\le B_i$。 这时，我们可以进一步简化条件：\n$(\\max A)\\le x$。 $x\\le (\\min B)$。 从而得到$(\\max A)\\le x\\le (\\min B)$，所以合法的$x$的个数为$\\max(0,\\min B-\\max A+1)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n, maxa = 1, minb = 1000; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); if(a \u0026gt; maxa) maxa = a; } while(n--) { int b; scanf(\u0026#34;%d\u0026#34;, \u0026amp;b); if(b \u0026lt; minb) minb = b; } if(maxa \u0026gt; minb) puts(\u0026#34;0\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, minb - maxa + 1); return 0; } C - IPFL\r题目大意\r给定长度为$2N$且只由大写英文字母组成的字符串$S$。\n你要处理$Q$个请求。\n第$i$个请求中由三个整数$T_i,A_i$和$B_i$组成：\n如果$T_i=1$：交换$S$中第$A_i$和$B_i$个字符； 如果$T_i=2$，交换$S$中的前$N$个和后$N$个字符（如：FLIP$\\to$IPFL）。 输出执行所有请求后的$S$。\n$1\\le N\\le 2\\times 10^5$\n$|S|=2N$\n$1\\le Q\\le 3\\times 10^5$\n$1\\le T_i\\le 2$，如果$T_i=1$，$1\\le A_i \u003c B_i\\le 2N$；如果$T_i=2$，$A_i=B_i=0$。\n输入格式\r$N$\n$S$\n$Q$\n$T_1~A_1~B_1$\n$T_2~A_2~B_2$\n$\\hspace{18pt}\\vdots$\n$T_Q~A_Q~B_Q$\n样例\r样例输入1\r1 2 3 4 5 2 FLIP 2 2 0 0 1 1 4 样例输出1\r1 LPFI $\\text{FLIP}\\to\\text{IPFL}\\to\\text{LPFI}$\n样例输入2\r1 2 3 4 5 6 7 8 9 2 FLIP 6 1 1 3 2 0 0 1 1 2 1 2 3 2 0 0 1 1 4 样例输出2\r1 ILPF 分析\r首先，$\\mathcal O(NQ)$的模拟法肯定行不通，会TLE。\n我们考虑优化。\n我们很容易发现，$T_i=1$的交换操作肯定是$\\mathcal O(1)$的，但$T_i=2$的翻转操作是$\\mathcal O(n)$的，所以需要优化。\n我们可以用一个变量$\\mathrm{flipped}$记录目前是否已经前后翻转（$1$表示已经翻转，$0$表示没有翻转），这时，操作变为如下：\n当$T_i=2$，$\\mathrm{flipped}:=1-\\mathrm{flipped}$； 当$T_i=1$且$\\mathrm{flipped}=0$时，我们直接交换$A_i$和$B_i$ 当$T_i=\\mathrm{flipped}=1$时，我们发现，一个位置$x$如果$\u003c N$，则实际位置在$x+N$；否则，实际位置在$x-N$。 这种算法的时间复杂度为$\\mathcal O(N+Q)$，可轻松通过此题。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;cstdio\u0026gt; #define maxn 400005 using namespace std; char s[maxn]; int n; inline void swap(char\u0026amp; x, char\u0026amp; y) { x ^= y ^= x ^= y; } inline char\u0026amp; calc(int pos) { return s[pos \u0026lt; n? pos + n: pos - n]; } int main() { scanf(\u0026#34;%d%s\u0026#34;, \u0026amp;n, s); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); bool flipped = false; while(q--) { int t, a, b; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;t, \u0026amp;a, \u0026amp;b); a --, b --; if(t == 2) flipped = !flipped; else if(flipped) swap(calc(a), calc(b)); else swap(s[a], s[b]); } if(flipped) for(int i=0; i\u0026lt;n; i++) swap(s[i], s[n + i]); puts(s); return 0; } D - RGB Coloring 2\r题目大意\r我们有一个有$N$个点和$M$条边的简单无向图，第$i$条边连接着顶点$A_i$和$B_i$。\n我们要给这个图用三种不同的颜色着色，使得相邻的顶点有不同的颜色。\n有多少种合法的着色方法？不一定要使用所有颜色。\n$1\\le N\\le 20$\n$0\\le M\\le \\frac{N(N-1)}2$\n$1\\le A_i,B_i\\le N$\n输入格式\r$N~M$\n$A_1~B_1$\n$A_2~B_2$\n$\\hspace{12pt}\\vdots$\n$A_M~B_M$\n输出格式\r输出答案。\n样例\r样例输入1\r1 2 3 4 3 3 1 2 2 3 3 1 样例输出1\r1 6 我们用R、G、B分别代表三种不同的颜色，则有$6$中不同的着色方法，它们分别是RGB、RBG、GRB、GBR、BRG、BGR。\n样例输入2\r1 3 0 样例输出2\r1 27 这个图没有边，所以任意着色都是可行的，一共有$3^N=27$种方法。\n样例输入3\r1 2 3 4 5 6 7 4 6 1 2 2 3 3 4 2 4 1 3 1 4 样例输出3\r1 0 这里没有合法方案。\n样例输入4\r1 20 0 样例输出4\r1 3486784401 分析\r我们将图中的每个连通块依次暴力算出所有可能的着色方案数，再相乘即可。\n其实，这里我们最大的总尝试数不是$3^N$，而是$3\\times 2^{N-1}$，因为使用$\\text{DFS}$时每个点的前一个点的颜色已经定好了，只需要尝试两种可能即可。\n代码\r似乎没人发现可以用unsigned int吧……\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 25 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; int col[maxn], dep[maxn]; inline int next(int c) { return (c + 1) % 3; } int paint(int v) { for(int u: G[v]) if(col[v] == col[u]) return 0; int ans = 1; for(int u: G[v]) { if(dep[u] == -1) dep[u] = dep[v] + 1; if(dep[u] == dep[v] + 1) { col[u] = next(col[v]); int res = paint(u); col[u] = next(col[u]); res += paint(u); col[u] = -1; if(res == 0) return 0; ans *= res; } } return ans; } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G[--x].push_back(--y); G[y].push_back(x); } for(int i=0; i\u0026lt;n; i++) col[i] = dep[i] = -1; unsigned int ans = 1; for(int i=0; i\u0026lt;n; i++) if(dep[i] == -1) { col[i] = dep[i] = 0; ans *= 3U * paint(i); } printf(\u0026#34;%u\\n\u0026#34;, ans); return 0; } E - Permutation\r题目大意\r求符合如下条件的$(1,2,\\dots,N)$的排列的个数：\n对于每个$1\\le i\\le M$，这个排列的前$X_i$个数中不超过$Y_i$的最多有$Z_i$个。 $2\\le N\\le 18$\n$0\\le M\\le 100$\n$1\\le X_i,Y_i \u003c N$\n$0\\le Z_i \u003c N$\n输入格式\r$N~M$\n$X_1~Y_1~Z_1$\n$X_2~Y_2~Z_2$\n$\\hspace{18pt}\\vdots$\n$X_M~Y_M~Z_M$\n输出格式\r输出一个整数，即符合条件的排列的个数。\n样例\r样例输入1\r1 2 3 1 2 2 1 样例输出1\r1 4 四个符合条件的排列分别为：$(1,2,3)$、$(2,3,1)$、$(3,1,2)$、$(3,2,1)$。\n样例输入2\r1 2 3 5 2 3 3 2 4 4 3 样例输出2\r1 90 样例输入3\r1 18 0 样例输出3\r1 6402373705728000 由于没有限制条件，所有的$18!=6402373705728000$个排列都可行。这也是本题的最大输出。\n分析\r首先，还是先排除$\\mathcal O(N!\\sum X)$的暴力算法，这样做的时间复杂度太高了。\n我们考虑状压$\\text{DP}$。令$\\mathrm{dp}_\\mathrm{mask}$表示从$(1,2,\\dots,N)$中选出子序列$\\mathrm{mask}$（二进制第$i$位是$0$表示不选$i$，$1$表示选$i$）。\n则，$\\mathrm{dp}_0=1$，动态转移方程为$\\mathrm{dp}_\\mathrm{mask}=\\mathrm{mask}$中所有为的$1$位上把$1$变成$0$的$\\mathrm{dp}$中的和，详见代码。\n写代码时注意判断合法性，最终答案应为$\\mathrm{dp}_{2^N-1}$（全选）。\n代码\r我这里做了一个小优化，即忽略$Z_i\\ge Y_i$的条件。当然，我们也可以不用优化，但不能不用long long！！！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 20 using namespace std; using LL = long long; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; lim[maxn]; LL dp[1 \u0026lt;\u0026lt; maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int x, y, z; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); if(z \u0026lt; y) lim[x].emplace_back(y, z); } int mx = 1 \u0026lt;\u0026lt; n; dp[0] = 1LL; for(int st=0; st\u0026lt;mx; st++) { vector\u0026lt;int\u0026gt; s; for(int i=0; i\u0026lt;n; i++) if(st \u0026gt;\u0026gt; i \u0026amp; 1) s.push_back(i); int cnt = __builtin_popcount(st); bool ok = true; for(auto [y, z]: lim[cnt]) { int tot = 0; for(auto x: s) if(x \u0026lt; y \u0026amp;\u0026amp; ++tot \u0026gt; z) { ok = false; break; } if(!ok) break; } if(ok) for(int x: s) dp[st] += dp[st ^ (1 \u0026lt;\u0026lt; x)]; } printf(\u0026#34;%lld\\n\u0026#34;, dp[mx - 1]); return 0; } ","date":"2021-06-13T11:31:00+08:00","permalink":"https://goodcoder666.github.io/p/abc199/","title":"AtCoder Beginner Contest 199 (Sponsored by Panasonic) A~E 题解"},{"content":"A - Century\r题目大意\r公元$N$年在第几个世纪中？\n一个世纪是由$100$个年份组成的一个区间。如，$1$世纪为$[1,100]$年，$2$世纪为$[101,200]$年，……\n$1\\le N\\le 3000$\n输入格式\r$N$\n输出格式\r将答案输出为一个整数。\n样例\r$N$ 输出 $2021$ $21$ $200$ $2$ 分析\r根据本题条件我们可以推出：公元$N$年在世纪$\\lceil \\frac N {100}\\rceil$。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;%d\\n\u0026#34;, n % 100 == 0? n / 100: n / 100 + 1); return 0; } B - 200th ABC-200\r题目大意\r对于整数$N$，执行$K$次如下操作：\n如果$N$是$200$的倍数，将$N$除以$200$。 否则，在$N$后面添上$200$。（如，$123$变为$123200$）。 $1\\le N\\le 10^5$\n$1\\le K\\le 20$\n输入格式\r$N~K$\n输出格式\r输出最终的$N$。\n样例\r$N$ $K$ 输出 $2021$ $4$ $50531$ $40000$ $2$ $1$ $8691$ $20$ $84875488281$ 分析\r本题我们按照题意模拟即可，但我们需要证明答案不会超过$2^{63}-1$，这样才能使用long long：\n任何数$N$添上$200$都是$200$的倍数。证明：一个数只要是$100$和$2$的公倍数，它就是$200$的倍数。$N$添上$200$后以00结尾，就证明了它是$200$的倍数。 这样，$N$每次添上$200$后都要除以$200$，相当于去掉两个零再将$N$除以$2$。 所以，$N$每次最多增加一位，还经常减少位数（除以$200$），肯定严格小于$2^{63}$。 代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { long long n; int k; scanf(\u0026#34;%lld%d\u0026#34;, \u0026amp;n, \u0026amp;k); while(k--) n = n % 200LL == 0LL? n / 200LL: n * 1000LL + 200LL; printf(\u0026#34;%lld\\n\u0026#34;, n); return 0; } C - Ringo\u0026rsquo;s Favorite Numbers 2\r题目大意\r给定序列$A=(A_1,A_2,\\dots,A_N)$，找到符合下列条件的所有$(i,j)$：\n$1\\le i \u003c j\\le N$； $|A_i-A_j|$是$200$的倍数。 $2\\le N\\le 2\\times 10^5$\n$1\\le A_i\\le 10^9$\n输出格式\r$N$\n$A_1~A_2~\\dots~A_N$\n样例\r$A$ 输出 $(123,223,123,523,200,2000)$ $4$ $(1,2,3,4,5)$ $0$ $(199,100,200,400,300,500,600,200)$ $9$ 分析\r首先，最容易想到的$\\mathcal O(n^2)$的暴力算法肯定不行，因为$2\\le N\\le 2\\times 10^5$。\n我们考虑用桶优化：\n我们有$200$个桶，分别如下：\n桶的编号 元素$1$ 元素$2$ 元素$3$ 元素$4$ …… 元素除以$200$的余数 $0$ $0$ $200$ $400$ $600$ …… $0$ $1$ $1$ $201$ $401$ $601$ …… $1$ $2$ $2$ $202$ $402$ $602$ …… $2$ …… …… …… …… …… …… …… $198$ $198$ $398$ $598$ $798$ …… $198$ $199$ $199$ $399$ $599$ $799$ …… $199$ 这时，我们发现，每个桶中的每个元素都能与这个同种的其他元素组成一对，所以我们只要在将元素加入桶中前将答案加上桶目前的大小即可。 总时间复杂度$\\mathcal O(n)$。\n代码\r我们的桶中不需要真正的元素，只需要记录桶的大小即可。\n注意：答案的数据类型一定要用long long！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define MOD 200 using namespace std; int cnt[MOD]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); long long ans = 0LL; while(n--) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); ans += cnt[x %= MOD] ++; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } D - Happy Birthday! 2\r题目大意\r给定序列$A=(A_1,A_2,\\dots,A_N)$。你要从中选出两个子序列$B$和$C$（下标不同，不要求连续），使得$\\sum B\\equiv \\sum C\\pmod{200}$。\n$2\\le N\\le 200$\n$1\\le A_i\\le 10^9$\n输入格式\r$N$\n$A_1~A_2~\\dots~A_N$\n输出\r如果没有合法的$B$和$C$，输出No。\n如果有合法的$B$和$C$，按下列格式输出，其中$x$为$B$的长度、$y$为$C$的长度，$B'$为$B$中元素对应的下标，$C'$为$C$中元素对应的下标：\n$\\text{Yes}$\n$x~B'_1~B'_2~\\dots~B'_x$\n$y~C'_1~C'_2~\\dots~C'_y$\n样例\r略，请自行前往AtCoder查看\n分析\r我们可以证明，只要$N\\ge 8$，那么就一定有解。证明如下：\n$8$个元素能组成的子序列有$2^8-1=255$种。（每个元素可以选或不选，去掉全不选的情况） 根据抽屉原理，我们将这$255$种子序列按照他们除以$200$的余数分别放入抽屉中，则至少有两个子序列在一个抽屉中，即必定有合法的$A$和$B$。 当$N \u003c 8$时，我们暴力枚举所有可能；\n当$N\\ge 8$时，我们暴力枚举其中任意$8$个元素组成的所有可能即可找到解。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 10 #define MOD 200 using namespace std; int a[maxn]; vector\u0026lt;int\u0026gt; bkt[MOD]; inline void print(const vector\u0026lt;int\u0026gt;\u0026amp; v) { printf(\u0026#34;%llu\u0026#34;, v.size()); for(int x: v) printf(\u0026#34; %d\u0026#34;, x + 1); putchar(\u0026#39;\\n\u0026#39;); } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if(n \u0026gt; 8) n = 8; for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); int lim = 1 \u0026lt;\u0026lt; n; for(int st=0; st\u0026lt;lim; st++) { int s = 0; vector\u0026lt;int\u0026gt; pos; for(int i=0; i\u0026lt;n; i++) if(st \u0026gt;\u0026gt; i \u0026amp; 1) s = (s + a[i]) % MOD, pos.push_back(i); if(!bkt[s].empty()) { puts(\u0026#34;Yes\u0026#34;); print(bkt[s]); print(pos); return 0; } else bkt[s] = pos; } puts(\u0026#34;No\u0026#34;); return 0; } E - Patisserie ABC 2\r题目大意\r有$N^3$个三元组$(i,j,k)$（$1\\le i,j,k\\le N$），按如下排序：\n$i+j+k$小的排在前面。 对于$i+j+k$相同的三元组，$i$小的排在前面，对于$i$相同的，$j$小的排在前面。 求第$K$个$(i,j,k)$。\n$1\\le N\\le 10^6$\n$1\\le K\\le N^3$\n输入格式\r$N~K$\n输出格式\r输出第$K$个$(i,j,k)$，用空格分隔。\n样例\r$N$ $K$ 输出 $2$ $5$ $1~2~2$ $1000000$ $1000000000000000000$ $1000000~1000000~1000000$ $9$ $47$ $3~1~4$ 分析\r$$\\begin{cases}i+j+k=n\\\\1\\le i,j,k\\le N\\end{cases}$$$$\\begin{cases}i+j+k=n\\\\1\\le i,j,k\\le n\\end{cases}$$\n这个可以用挡板法解决，在$n-1$个位置上任选$2$个插入挡板，挡板分开的就是$i,j,k$，则公式为$C_{n-1}^2$。我们设$f(n)=~$上述方程解的个数（$C_{n-1}^2=(n-1)(n-2)$），则总方程解的个数为$f(n)$。\n我们考虑一个、两个（不可能有三个）数大于$N$的情况，这样$\\begin{cases}i+j+k=n\\\\1\\le i,j,k\\le N\\end{cases}$这个方程解的个数就为$f(n)+3f(n-2N)-3f(n-N)$。\n代码\r计算$f(n)$时注意特判$n\\le 2$的情况，否则可能会出现负数！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstdio\u0026gt; using namespace std; using LL = long long; int n; inline int max(int x, int y) { return x \u0026gt; y? x: y; } inline int min(int x, int y) { return x \u0026lt; y? x: y; } inline LL f(LL n) { return n-- \u0026gt; 2? n * (n - 1LL) \u0026gt;\u0026gt; 1LL: 0LL; } inline LL count(int s) { return f(s) - 3 * (f(s - n) - f(s - (n \u0026lt;\u0026lt; 1))); } int main() { LL k; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;k); int lim = n * 3; for(int sum=3; sum\u0026lt;=lim; sum++) { LL cnt = count(sum); if(k \u0026gt; cnt) { k -= cnt; continue; } for(int a=1; a\u0026lt;=n; a++) { int minb = max(1, sum - a - n), maxb = min(n, sum - a - 1); if(minb \u0026gt; maxb) continue; int num = maxb - minb + 1; if(k \u0026lt;= num) { int b = minb + k - 1; int c = sum - a - b; printf(\u0026#34;%d %d %d\\n\u0026#34;, a, b, c); return 0; } k -= num; } } return 0; } ","date":"2021-06-10T22:16:00+08:00","permalink":"https://goodcoder666.github.io/p/abc200/","title":"KYOCERA Programming Contest 2021 (AtCoder Beginner Contest 200) A~E 题解"},{"content":"A - Rock-paper-scissors\r三个人玩石头剪刀布平局，其中两个出的分别是$x,y$，求另一个人出的。\n$0\\le x,y\\le 2$（$0,1,2$分别表示石头，剪刀，布）\n输入格式\r$x,y$\n输出格式\r用整数格式输出答案。\n样例\r$x$ $y$ 输出 $0$ $1$ $2$ $0$ $0$ $0$ 分析\r石头剪刀布这个游戏三人平局只有两种情况（设$z$为第三个人出的）：\n$x=y=z$ $x\\ne y\\ne z$ 所以，我们得出如下递推式：\n$z=\\begin{cases}x \u0026 (x=y)\\\\3-x-y \u0026 (x\\ne y)\\end{cases}$\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); printf(\u0026#34;%d\\n\u0026#34;, x == y? x: 3 - x - y); return 0; } B - Nuts\r有$N$棵树，第$i$棵树上有$A_i$颗果实。\n一个人会从第$i$棵树摘下$\\max(0,A_i-10)$颗果实。他一共会得到多少果实？\n$1\\le N,A_i\\le 1000$\n输入格式\r$N$\n$A_1~\\dots~A_N$\n输出格式\r输出答案。\n样例\r样例输入1\r1 2 3 6 17 28 样例输出1\r1 25 他会从三棵树上分别摘下$0,7,18$颗果实，总共$25$颗。\n样例输入2\r1 2 4 8 9 10 11 样例输出2\r1 1 他只会从最后一棵树上得到一颗果实。\n分析\r我们直接按题意模拟即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n, ans = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while(n--) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); if(a \u0026gt; 10) ans += a - 10; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } C - Tour\r一个国家有编号为$1$至$N$的$N$座城市和编号为$1$至$M$的$M$条路。\n第$i$条路从城市$A_i$到$B_i$，且不能用它从城市$B_i$到$A_i$。\n一个人想从起点城市开始旅行并走过若干条路（可以不走，即只游玩一个城市）并到达终点城市。\n有多少种合法的起点和终点城市？如果$X\\ne Y$，则$X\\to Y$和$Y\\to X$算作两种不同的方案。\n$2\\le N\\le 2000$\n$0\\le M\\le \\min(2000,N(N-1))$\n$1\\le A_i,B_i\\le N$\n$A_i\\ne B_i$\n$(A_i,B_i)$互不相同。\n输入格式\r$N~M$\n$A_1~B_1$\n$\\vdots$\n$A_M~B_M$\n输出格式\r输出答案。\n样例\r样例输入1\r1 2 3 4 3 3 1 2 2 3 3 2 样例输出1\r1 7 有七种可行的旅游方案：$1\\to1$、$1\\to2$、$1\\to3$、$2\\to2$、$2\\to3$、$3\\to2$、$3\\to3$。\n样例输入2\r1 3 0 样例输出2\r1 3 有三种可行的旅游方案：$1\\to1$、$2\\to2$、$3\\to3$。\n分析\r我们可以把这个国家看成一个简单有向无权图，并把每个节点作为起点跑一遍$\\text{DFS}$，计算总共能到达的结点数即可。\n总时间复杂度为$\\mathcal O(n^2)$。\n代码\r注意：每次$\\text{DFS}$之前一定要将$\\mathrm{vis}$数组清零！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 2005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; bool vis[maxn]; int ans; void dfs(int v) { if(vis[v]) return; vis[v] = true, ans ++; for(int u: G[v]) dfs(u); } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G[--x].push_back(--y); } ans = 0; for(int i=0; i\u0026lt;n; i++) { for(int j=0; j\u0026lt;n; j++) vis[j] = false; dfs(i); } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Cooking\r两个人要洗$N$个碗，其中任意一个人洗第$i$个碗需要$T_i$分钟。一个人不能同时洗多个碗。\n两个人一起洗碗，洗完所有碗至少需要多少分钟？\n$1\\le N\\le 100$\n$1\\le T_i\\le 10^3$\n输入格式\r$N$\n$T_1~T_2~\\dots~T_N$\n输出格式\r输出答案。\n样例\r样例输入1\r1 2 5 8 3 7 2 5 样例输出1\r1 13 我们可以让两个人分别洗如下的碗：\n第一个人洗编号为$5,1$的碗。总时间为$T_5+T_1=13$分钟。 第二个人洗编号为$2,4,3$的碗。总时间为$T_2+T_4+T_3=10$分钟。 总耗时为$\\max(13,10)=13$分钟。\n样例输入2\r1 2 2 1000 1 样例输出2\r1 1000 样例输入3\r1 2 9 3 14 15 9 26 5 35 89 79 样例输出3\r1 138 分析\r这是一道经典01背包题。\n题目可以直接描述为：给定序列$T$，将其分成两个子序列$A$和$B$（不要求连续），求最小的$\\min(\\sum A,\\sum B)$。\n这时，我们发现要使$\\min(\\sum A,\\sum B)$最小，由于$\\sum A+\\sum B=\\sum T$，所以$|\\sum A-\\sum B|$必须也达到最小。\n我们可以将$\\sum T$分成两半，其中一半为$\\lfloor\\frac{\\sum T}2\\rfloor$。这时，我们可以用dp背包解决此题：从$T$中选出一个子序列$A$，使得$\\sum A\\le\\lfloor\\frac{\\sum T}2\\rfloor$，这样答案就为$\\sum T-\\sum A$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #define maxn 105 #define maxv 100005 using namespace std; int dp[maxv], w[maxn]; inline void setmax(int\u0026amp; x, int y) { if(y \u0026gt; x) x = y; } int main() { int n, v = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d\u0026#34;, w + i); v += w[i]; } int t = v; v \u0026gt;\u0026gt;= 1; for(int i=0; i\u0026lt;n; i++) for(int j=v; j\u0026gt;=w[i]; j--) setmax(dp[j], dp[j - w[i]] + w[i]); printf(\u0026#34;%d\\n\u0026#34;, t - dp[v]); return 0; } E - Rush Hour 2\r一个国家有$N$座城市和$M$条路。城市的编号是$1$至$N$，路的编号则为$1$至$M$。第$i$条路双向连接着城市$A_i$和$B_i$。\n在这个国家中，初始时间为$0$。如果你在时间点$t$通过公路$i$，所需时间为$C_i+\\lfloor\\frac {D_i} {t+1}\\rfloor$。\n一个人想从城市$1$到达城市$N$。他在每个城市可以停留任意自然数的时间。\n求这个人最早到达城市$N$的时间。如果无法到达城市$N$，输出-1。\n$2\\le N\\le 10^5$\n$2\\le M\\le 10^5$\n$1\\le A_i,B_i\\le N$\n$0\\le C_i,D_i\\le 10^9$\n输入格式\r$N~M$\n$A_1~B_1~C_1~D_1$\n$\\vdots$\n$A_M~B_M~C_M~D_M$\n输出格式\r输出答案。\n样例\r样例输入1\r1 2 2 1 1 2 2 3 样例输出1\r1 4 我们可以先在城市$1$停留至时间$1$。然后，我们出发，最终到达时间$1+2+\\lfloor\\frac 3 {1+1}\\rfloor=4$。\n样例输入2\r1 2 3 4 2 3 1 2 2 3 1 2 2 1 1 1 1 1 样例输出2\r1 3 两个城市之间可能有多条路，一个城市也可能有到自己的路。\n样例输入3\r1 2 3 4 2 1 2 3 4 3 4 5 6 样例输出3\r1 -1 城市$1$到城市$N$可能没有路径。\n分析\r我们可以把输入当成一幅无向图。其实，从一个城市到它自己的路根本没有用，所以我们直接忽略不计。\n如果目前时间为$T$且我们要从城市$A_i$到$B_i$，我们可以证明，最好的整数出发时间应该是$\\lfloor\\sqrt D\\rceil-1$（$\\lfloor x\\rceil$表示$x$四舍五入）。\n如果$\\lfloor\\sqrt D\\rceil\\le T$，我们应该等到时间$\\lfloor\\sqrt D\\rceil-1$再出发；否则，我们直接出发。\n这时，我们可以使用Dijkstra最短路算法（使用优先队列优化），这样总时间复杂度就为$\\mathcal O(M\\log N)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;tuple\u0026gt; #define maxn 100005 #define INF 9223372036854775807LL using namespace std; using Road = tuple\u0026lt;int, int, int\u0026gt;; using LL = long long; using pli = pair\u0026lt;LL, int\u0026gt;; vector\u0026lt;Road\u0026gt; G[maxn]; LL dist[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int a, b, c, d; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); if(--a == --b) continue; G[a].emplace_back(b, c, d); G[b].emplace_back(a, c, d); } dist[0] = 0LL; for(int i=1; i\u0026lt;n; i++) dist[i] = INF; priority_queue\u0026lt;pli, vector\u0026lt;pli\u0026gt;, greater\u0026lt;pli\u0026gt;\u0026gt; q; q.emplace(0LL, 0); while(!q.empty()) { auto [t, u] = q.top(); q.pop(); if(dist[u] != t) continue; for(auto [v, c, d]: G[u]) { LL t2 = sqrt((long double) d) - 0.5; if(t2 \u0026lt; t) t2 = t; t2 += LL(c) + LL(d) / (t2 + 1LL); if(t2 \u0026lt; dist[v]) q.emplace(dist[v] = t2, v); } } if(dist[n - 1] == INF) puts(\u0026#34;-1\u0026#34;); else printf(\u0026#34;%lld\\n\u0026#34;, dist[n - 1]); return 0; } ","date":"2021-06-07T19:02:00+08:00","permalink":"https://goodcoder666.github.io/p/abc204/","title":"AtCoder Beginner Contest 204 A~E 题解"},{"content":"A - Three Dice\r一个人抛了三个骰子，它们的顶面分别是$a,b,c$。求它们的底面之和。\n这里用的骰子是标准骰子，即两个相对的面之和为$7$。\n$1\\le a,b,c\\le 6$\n输入格式\r$a~b~c$\n输出格式\r输出答案。\n样例\r$a$ $b$ $c$ 答案 $1$ $4$ $3$ $13$ $5$ $6$ $4$ $6$ 分析\r因为两个相对的面之和为$7$，所以本题的答案为$(7-a)+(7-b)+(7-c)=21-a-b-c$。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); printf(\u0026#34;%d\\n\u0026#34;, 21 - a - b - c); return 0; } B - 180°\r给定一个由0、1、6、8、9组成的字符串$S$。将其旋转$180\\degree$并输出。\n一个字符串旋转$180\\degree$的方法：\n将其翻转（reverse）。 将其中的6替换为9，9替换为6。 $1\\le |S|\\le10^5$\n输入格式\r$S$\n输出格式\r输出$S$旋转$180\\degree$后的字符串。\n样例\r$S$ 输出 0601889 6881090 86910 01698 01010 01010 分析\r本题直接按要求模拟即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 using namespace std; char s[maxn]; int main() { int n = 0; char c; while((c = getchar()) != \u0026#39;\\n\u0026#39;) s[n++] = c; while(n--) putchar(s[n] == \u0026#39;6\u0026#39;? \u0026#39;9\u0026#39;: s[n] == \u0026#39;9\u0026#39;? \u0026#39;6\u0026#39;: s[n]); putchar(\u0026#39;\\n\u0026#39;); return 0; } C - Made Up\r给定三个长度为$N$的序列：$A,B,C$。\n有多少对$(i,j)$符合$A_i=B_{C_j}$？\n$1\\le N\\le 10^5$\n$1\\le A_i,B_i,C_i\\le N$\n输入格式\r$N$\n$A_1~A_2~\\dots~A_N$\n$B_1~B_2~\\dots~B_N$\n$C_1~C_2~\\dots~C_N$\n输出格式\r输出符合$A_i=B_{C_j}$的$(i,j)$的对数。\n样例\r样例输入1\r1 2 3 4 3 1 2 2 3 1 2 2 3 2 样例输出1\r1 4 $4$对$(i,j)$符合条件：$(1,1),(1,3),(2,2),(3,2)$。\n样例输入2\r1 2 3 4 4 1 1 1 1 1 1 1 1 1 2 3 4 样例输出2\r1 16 所有$(i,j)$都符合条件。\n样例输入3\r1 2 3 4 3 2 3 3 1 3 3 1 1 1 样例输出3\r1 0 没有$(i,j)$符合条件。\n分析\r我们很容易想到$O(n^2)$的算法：暴力枚举所有$(i,j)$，并统计符合条件的对数。\n可惜，这样会TLE。\n我们考虑将所有的$A_i$和$B_{C_j}$分别放入两个桶$\\mathrm{acnt}$和$\\mathrm{bcnt}$。\n根据乘法原理我们得出答案为$\\sum\\limits_{i=1}^n\\mathrm{acnt}_i\\mathrm{bcnt}_i$。\n代码\r注意：不要忘记使用long long！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 using namespace std; using LL = long long; int acnt[maxn], b[maxn], bcnt[maxn]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); acnt[a] ++; } for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, b + i); for(int i=0; i\u0026lt;n; i++) { int c; scanf(\u0026#34;%d\u0026#34;, \u0026amp;c); bcnt[b[--c]] ++; } LL ans = 0LL; for(int i=1; i\u0026lt;=n; i++) ans += LL(acnt[i]) * LL(bcnt[i]); printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } D - aab aba baa\r在由$A$个a和$B$个b（均不要求连续）组成的字符串中，求字典序第$K$小的。\n$1\\le A,B\\le 30$\n$1\\le K\\le S$（$S$为由$A$个a和$B$个b组成的字符串的个数）\n输入格式\r$A~B~K$\n输出格式\r输出由$A$个a和$B$个b组成的字符串中字典序第$K$小的。\n样例\r$A$ $B$ $K$ 输出 $2$ $2$ $4$ baab $30$ $30$ $118264581564861424$ （$30$个b$+30$个a) 分析\r我们令$\\mathrm{dp}(a,b)$为由$a$个a和$b$个b组成的字符串的个数，则：\n我们在长度为$a+b-1$的字符串上再添上一个a或b： $\\mathrm{dp}(a,b)=\\mathrm{dp}(a-1,b)+\\mathrm{dp}(a,b-1)$。 $$f(a,b,k)=\\begin{cases}\r``\" \u0026 (a=b=0)\\\\\r``a\"+f(a-1,b,k) \u0026 (b=0)\\\\\r``b\"+f(a,b-1,k) \u0026 (a=0)\\\\\r``a\"+f(a-1,b,k) \u0026 (k\\le \\mathrm{dp}(a-1,b))\\\\\r``b\"+f(a,b-1,k- \\mathrm{dp}(a-1,b)) \u0026 (k\u003e\\mathrm{dp}(a-1,b))\r\\end{cases}$$代码\r写代码时，可以用递归形式，也可以使用非递归形式（更快）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; #define maxn 35 using namespace std; using LL = long long; LL dp[maxn][maxn]; int main() { int a, b; LL k; scanf(\u0026#34;%d%d%lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;k); for(int i=0; i\u0026lt;=a; i++) dp[i][0] = 1; for(int i=0; i\u0026lt;=b; i++) dp[0][i] = 1; for(int i=1; i\u0026lt;=a; i++) for(int j=1; j\u0026lt;=b; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; while(a \u0026amp;\u0026amp; b) { LL t = dp[a - 1][b]; if(k \u0026lt;= t) putchar(\u0026#39;a\u0026#39;), a --; else putchar(\u0026#39;b\u0026#39;), b --, k -= t; } while(a--) putchar(\u0026#39;a\u0026#39;); while(b--) putchar(\u0026#39;b\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); return 0; } E - Count Descendants\r我们有一棵$N$个节点的树，节点的编号分别为$1,2,\\dots,N$。\n$1$号点是根节点，且第$i$个点（$2\\le i\\le N$）的父亲节点是$P_i$。\n给你$Q$个查询，第$i$个查询包含两个整数$U_i$和$D_i$，求符合下列条件的点$u$的个数：\n$u$到根节点的最短路径正好有$D_i$条边； $U_i$在$u$到根节点的最短路径中（包含两端）。 $1\\le N\\le 2\\times10^5$\n$1\\le P_i \u003c i$\n$1\\le Q\\le 2\\times10^5$\n$1\\le U_i\\le N$\n$0\\le D_i \u003c N$\n输入格式\r$N$\n$P_2~P_3~\\dots~P_N$\n$Q$\n$U_1~D_1$\n$U_2~D_2$\n$\\vdots$\n$U_Q~D_Q$\n输出格式\r输出$Q$行。第$i$行包含对第$i$个查询的回应。\n样例\r样例输入\r1 2 3 4 5 6 7 7 1 1 2 2 4 2 4 1 2 7 2 4 1 5 5 样例输出\r1 2 3 4 3 1 0 0 在第一个查询中，节点$4,5,7$符合条件。\n在第二个查询中，只有节点$7$符合条件。\n在最后两个查询中，没有节点符合条件。\n分析\r我们可以先在整棵树上从根节点开始跑一遍$\\text{DFS}$，对于节点$i$预处理出$\\mathrm{in}_i$和$\\mathrm{out}_i$，分别表示进入和走出这个节点的时间，同时将第$i$层节点的所有$\\mathrm{in}$放入$\\mathrm{depin}_i$。\n如果节点$u$到根节点的路径中有$v$，则$\\mathrm{in}_v\\le\\mathrm{in}_u \u003c \\mathrm{out}_v$。\n因此，对于每个查询，我们利用二分查找即可快速算出符合条件的节点个数。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 200005 using namespace std; int in[maxn], out[maxn], dep[maxn], cnt; vector\u0026lt;int\u0026gt; G[maxn], depin[maxn]; void dfs(int v) { depin[dep[v]].push_back(in[v] = cnt++); for(int u: G[v]) dfs(u); out[v] = cnt++; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); dep[0] = cnt = 0; for(int i=1; i\u0026lt;n; i++) { int p; scanf(\u0026#34;%d\u0026#34;, \u0026amp;p); dep[i] = dep[--p] + 1; G[p].push_back(i); } dfs(0); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while(q--) { int u, d; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;d); const auto\u0026amp; din = depin[d]; auto first = lower_bound(din.begin(), din.end(), in[--u]); auto last = lower_bound(din.begin(), din.end(), out[u]); printf(\u0026#34;%lld\\n\u0026#34;, last - first); } return 0; } ","date":"2021-06-06T11:28:00+08:00","permalink":"https://goodcoder666.github.io/p/abc202/","title":"AISing Programming Contest 2021 (AtCoder Beginner Contest 202) A~E 题解"},{"content":"A - Chinchirorin\r题目大意\r给定三个整数$a,b,c$，如果它们中有两个相等，输出另一个；否则，输出$0$。\n$1\\le a,b,c\\le 6$\n输入格式\r$a~b~c$\n输出格式\r如果$a,b,c$中有两个相等，输出另一个；否则，输出$0$。\n样例\r$a$ $b$ $c$ 输出 $2$ $5$ $2$ $5$ $4$ $5$ $6$ $0$ $1$ $1$ $1$ $1$ 分析\r$A$题还是一如既往的水……直接暴力判断三种相等的情况即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); if(a == b) printf(\u0026#34;%d\\n\u0026#34;, c); else if(b == c) printf(\u0026#34;%d\\n\u0026#34;, a); else if(a == c) printf(\u0026#34;%d\\n\u0026#34;, b); else puts(\u0026#34;0\u0026#34;); return 0; } B - AtCoder Condominium\r题目大意\r给定$N$和$K$，求$\\sum\\limits_{i=1}^N\\sum\\limits_{j=1}^K \\overline{i0j}$。\n$1\\le N,K\\le 9$\n输入格式\r$N~K$\n输出格式\r输出$\\sum\\limits_{i=1}^N\\sum\\limits_{j=1}^K \\overline{i0j}$。\n样例\r$N$ $K$ 输出 $1$ $2$ $203$ $3$ $3$ $1818$ 分析\r本题可以直接暴力，但我使用的是如下$\\mathcal O(1)$算法：\n根据$\\overline{i0j}=100i+j$且$1+2+\\dots+N=\\frac{N(N+1)}2$，则有如下推导：\n$\\sum\\limits_{i=1}^N\\sum\\limits_{j=1}^K \\overline{i0j}=\\sum\\limits_{i=1}^N\\sum\\limits_{j=1}^K 100i+\\sum\\limits_{i=1}^N\\sum\\limits_{j=1}^K j$ $\\sum\\limits_{i=1}^N\\sum\\limits_{j=1}^K 100i=\\sum\\limits_{i=1}^N 100iK=100K\\sum\\limits_{i=1}^N i=\\frac{100N(N+1)K}2$ $\\sum\\limits_{i=1}^N\\sum\\limits_{j=1}^K j=\\sum\\limits_{i=1}^N\\frac{K(K+1)}2=\\frac{K(K+1)N}2$ $\\sum\\limits_{i=1}^N\\sum\\limits_{j=1}^K \\overline{i0j}=\\frac{100N(N+1)K}2+\\frac{K(K+1)N}2=\\frac{100N(N+1)K+K(K+1)N}2$ 这样，我们就可以直接通过公式$\\frac{100N(N+1)K+K(K+1)N}2$计算出结果了。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;cstdio\u0026gt; using namespace std; inline int sum(int x) { return x * (x + 1) \u0026gt;\u0026gt; 1; } int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); printf(\u0026#34;%d\\n\u0026#34;, sum(n) * k * 100 + sum(k) * n); return 0; } C - Friends and Travel costs\r题目大意\r有$10^{100}+1$个村庄，分别为村庄$0,1,\\dots,10^{100}$，相邻两个村庄之间的过路费是$1$元。\nTaro一开始有$K$元且在村庄$0$。他想要到达编号尽可能大的村庄。\n他有$N$个朋友。第$i$个朋友会在Taro到达村庄$A_i$时给他$B_i$元。\n求Taro最后到达的村庄的编号。\n$1\\le N\\le 2\\times10^5$\n$1\\le K\\le 10^9$\n$1\\le A_i\\le 10^{18}$\n$1\\le B_i\\le 10^9$\n输入格式\r$N~K$\n$A_1~B_1$\n$A_2~B_2$\n$\\dots$\n$A_N~B_N$\n输出\r输出Taro最后到达的村庄的编号。\n样例\r样例输入1\r1 2 3 2 3 2 1 5 10 样例输出1\r1 4 样例输入2\r1 2 3 4 5 6 5 1000000000 1 1000000000 2 1000000000 3 1000000000 4 1000000000 5 1000000000 样例输出2\r1 6000000000 请不要使用$32$位整数。\n样例输入3\r1 2 3 4 3 2 5 5 2 1 2 2 样例输出3\r1 10 Taro在一个村庄可能有多个朋友。\n分析\r根据题目中的数据范围，我们可以证明答案严格小于$2^{64}$，所以我们使用unsigned long long作为存储数据类型。\n可是，由于村庄数量还是太多，我们仍然无法依次模拟到达每个村庄。\n我们发现$N$较小，所以我们可以从朋友的角度考虑。\n我们可以按$A_i$排序所有朋友（$B_i$的顺序不重要），这样就能把整个行程形成分成若干个区间，并依次判断每个区间是否能走完即可。\n代码\r注意：我这里排序使用的是优先队列（priority_queue）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define maxn 200005 #define INF 18446744073709551615ULL using namespace std; using ULL = unsigned long long; using pll = pair\u0026lt;ULL, ULL\u0026gt;; int main() { int n; ULL k; scanf(\u0026#34;%d%llu\u0026#34;, \u0026amp;n, \u0026amp;k); priority_queue\u0026lt;pll, vector\u0026lt;pll\u0026gt;, greater\u0026lt;pll\u0026gt; \u0026gt; q; for(int i=0; i\u0026lt;n; i++) { ULL a, b; scanf(\u0026#34;%llu%llu\u0026#34;, \u0026amp;a, \u0026amp;b); q.emplace(a, b); } ULL lastv = 0ULL; q.emplace(INF, 0ULL); while(!q.empty()) { auto [a, b] = q.top(); q.pop(); ULL cost = a - lastv; if(k \u0026lt; cost) { printf(\u0026#34;%llu\\n\u0026#34;, lastv + k); return 0; } k -= cost; lastv = a, k += b; } return 0; } D - Pond\r题目大意\r给定一个$N\\times N$的正方形矩阵$A$，第$i$行第$j$列的元素是$A_{i,j}$。\n求$A$中所有的$K\\times K$的子矩阵的中间值的最小值。\n一个$K\\times K$的正方形的中间值为其中第$(\\left\\lfloor\\frac{K^2}2\\right\\rfloor+1)$大的值。\n$1\\le K\\le N\\le 800$\n$1\\le A_{i,j}\\le 10^9$\n如果不能理解题意，请看下图：\n对应的输入输出：\n1 2 3 4 3 2 5 9 8 2 1 3 7 4 6 /\n1 2 输入格式\r$N~K$\n$A_{1,1}~A_{1,2}~\\dots~A_{1,N}$\n$A_{2,1}~A_{2,2}~\\dots~A_{2,N}$\n$A_{N,1}~A_{N,2}~\\dots~A_{N,N}$\n输出格式\r输出答案。\n样例\r样例输入1\r1 2 3 4 3 2 1 7 0 5 8 11 10 4 2 样例输出1\r1 4 $$N=3~~~~~K=2\\\\\rA=\\begin{bmatrix}\r1 \u0026 7 \u0026 0\\\\\r5 \u0026 8 \u0026 11\\\\\r10 \u0026 4 \u0026 2\r\\end{bmatrix}$$\n我们有四个$2\\times2$的正方形：$\\{8, 7, 5, 1\\}, ~\\{11,8,7,0\\},~ \\{10,8,5,4\\}, ~\\{11,8,4,2\\}$。\n我们依次从每个的元素中取第$\\left\\lfloor\\frac{K^2}2\\right\\rfloor+1=3$大的：$\\{5,7,5,4\\}$\n最后，我们从$\\{5,7,5,4\\}$中选出最小的：$4$。\n样例输入2\r1 2 3 4 3 3 1 2 3 4 5 6 7 8 9 样例输出2\r1 5 分析\r本题可以二分答案。我们判定一个数是否为一个$K\\times K$的正方形的中间值时，只需要计算这个正方形内严格大于这个数的数的个数是否为$\\left\\lfloor\\frac{K^2}2\\right\\rfloor$即可。\n因此，我们可以使用矩阵前缀和快速计算一个正方形内严格大于一个数的数的数的个数。\n总时间复杂度$\\mathcal O(n^2\\log\\max\\{A\\})$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;cstdio\u0026gt; #define maxn 805 #define INF 2147483647 using namespace std; int a[maxn][maxn], dp[maxn][maxn], n, k, target; inline int count(int x1, int y1, int x2, int y2) { return dp[x2][y2] - dp[x1 - 1][y2] - dp[x2][y1 - 1] + dp[x1 - 1][y1 - 1]; } inline bool check(int x) { for(int i=1; i\u0026lt;=n; i++) for(int j=1; j\u0026lt;=n; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + (a[i][j] \u0026gt; x); for(int x2=k; x2\u0026lt;=n; x2++) for(int y2=k; y2\u0026lt;=n; y2++) { int x1 = x2 - k + 1, y1 = y2 - k + 1; if(count(x1, y1, x2, y2) \u0026lt; target) return true; } return false; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); target = (k * k \u0026gt;\u0026gt; 1) + 1; int l = INF, r = 0, ans = 0; for(int i=1; i\u0026lt;=n; i++) for(int j=1; j\u0026lt;=n; j++) { scanf(\u0026#34;%d\u0026#34;, a[i] + j); if(a[i][j] \u0026gt; r) r = a[i][j]; if(a[i][j] \u0026lt; l) l = a[i][j]; } while(l \u0026lt;= r) { int mid = l + r \u0026gt;\u0026gt; 1; if(check(mid)) ans = mid, r = mid - 1; else l = mid + 1; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } E - White Pawn\r题目大意\r有一个$(2N+1)\\times(2N+1)$的正方形棋盘，行数、列数下标都依次从$0$到$2N$。我们用$(i,j)$表示棋盘上$i$行$j$列的位置。\n我们有一颗棋子，初始位置在$(0,N)$。棋盘上有$M$个黑方格，第$i$个的位置在$(X_i,Y_i)$，其余都是白方格。\n当棋子在$(i,j)$时，你可以执行任意下列操作，但不能移出棋盘：\n$(i+1,j)$是白色时，移到$(i+1,j)$； $(i+1,j-1)$是黑色时，移到$(i+1,j-1)$。 $(i+1,j+1)$是黑色是，移到$(i+1,j+1)$。 棋盘上的方格不能移动。求棋盘的最后一行的能到达的列的个数。\n$1\\le N\\le 10^9$\n$0\\le M\\le 2\\times 10^5$\n$1\\le X_i\\le 2N$\n$0\\le Y_i\\le 2N$\n$(X_i,Y_i)$互不相等。\n输入格式\r$N~M$\n$X_1~Y_1$\n$X_2~Y_2$\n$\\vdots$\n$X_M~Y_M$\n输出格式\r输出棋盘的最后一行的能到达的列的个数。\n样例\r样例输入1\r1 2 3 4 5 2 4 1 1 1 2 2 0 4 2 样例输出1\r1 3 我们可以将棋子移动到$(4,0)$、$(4,1)$和$(4,2)$，如下：\n$(0,2)\\to(1,1)\\to(2,1)\\to(3,1)\\to(4,2)$ $(0,2)\\to(1,1)\\to(2,1)\\to(3,1)\\to(4,1)$ $(0,2)\\to(1,1)\\to(2,0)\\to(3,0)\\to(4,0)$ 我们不能移动到$(4,3)$或$(4,4)$，所以输出$3$。\n样例输入2\r1 2 1 1 1 1 样例输出2\r1 0 我们无法移动棋子。\n分析\r我们发现，当$N$较大时，大多数行多是空着的，所以我们从每个$X_i$开始考虑。对于白色的位置$(i,j)$，如果不能到达$(i-1,j)$，则不能到达$(i,j)$。相反，对于黑色的$(i,j)$，如果能到达$(i-1,j-1)$或$(i-1,j+1)$，则能到达$(i,j)$。\n因此，我们先排序每个$(X_i,Y_i)$，再对于每个有黑色的行，用set维护能到达的列数，再按上述方法判断即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) using namespace std; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; black; black.reserve(m); while(m--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); black.emplace_back(x, y); } m = black.size(); sort(black.begin(), black.end()); set\u0026lt;int\u0026gt; cols; cols.insert(n); for(int l=0, r=0; l\u0026lt;m; l=r) { while(r \u0026lt; m \u0026amp;\u0026amp; black[r].first == black[l].first) r ++; vector\u0026lt;int\u0026gt; rem, add; for(int i=l; i\u0026lt;r; i++) { int y = black[i].second; bool ok = cols.count(y - 1) || cols.count(y + 1); if(cols.count(y)) { if(!ok) rem.push_back(y); } else if(ok) add.push_back(y); } for(int y: rem) cols.erase(y); for(int y: add) cols.insert(y); } printf(\u0026#34;%llu\\n\u0026#34;, cols.size()); return 0; } ","date":"2021-06-03T21:11:00+08:00","permalink":"https://goodcoder666.github.io/p/abc203/","title":"AtCoder Beginner Contest 203 (Sponsored by Panasonic) A~E 题解"},{"content":"A - Tiny Arithmetic Sequence\r题目大意\r给定序列$A=(A_1,A_2,A_3)$。能否将$A$重新排列，使得$A_3-A_2=A_2-A_1$？\n$1\\le A_i\\le 100$\n输入格式\r$A_1~A_2~A_3$\n输出格式\r如果能将$A$重新排列使得$A_3-A_2=A_2-A_1$，输出Yes；如果不能，输出No。\n样例\r$A$ 输出 $(5,1,3)$ Yes $(1,4,3)$ No $(5,5,5)$ Yes 分析\r很容易想到，如果$A_3-A_2=A_2-A_1$，则$A_1\\le A_2\\le A_3$或$A_3\\le A_2\\le A_1$必定成立。\n因此，我们可以先把$A$按升序排列，再$A_3-A_2=A_2-A_1$是否成立即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int a[3]; scanf(\u0026#34;%d%d%d\u0026#34;, a, a + 1, a + 2); sort(a, a + 3); puts(a[2] - a[1] == a[1] - a[0]? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Do you know the second highest mountain?\r题目大意\r有$N$坐山。第$i$坐山有一个名字$S_i$和高度$T_i$。\n输出第二高的山的名字。\n$2\\le N\\le 1000$\n$1\\le |S_i|\\le 15$\n$1\\le T_i\\le 10^5$\n$S_i\\ne S_j~(i\\ne j)$\n$T_i\\ne T_j~(i\\ne j)$\n$S_i$由大小写英文字母和数字组成。\n输入格式\r$N$\n$S_1~T_1$\n$S_2~T_2$\n$\\vdots$\n$S_N~T_N$\n输出格式\r输出第二高的山的名字。\n样例\r样例输入1\r1 2 3 4 3 Everest 8849 K2 8611 Kangchenjunga 8586 样例输出1\r1 K2 第二高的山是K2。\n样例输入2\r1 2 3 4 5 4 Kita 3193 Aino 3189 Fuji 3776 Okuhotaka 3190 样例输出2\r1 Kita 第二高的山是Kita。\n样例输入3\r1 2 3 4 5 4 QCFium 2846 chokudai 2992 kyoprofriends 2432 penguinman 2390 样例输出3\r1 QCFium 第二高的山是QCFium。\n分析\r这道题其实就是给定求数组$T$中第二大的元素的$S_i$。我们可以利用优先队列实现求第二大的元素。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; using pis = pair\u0026lt;int, string\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin \u0026gt;\u0026gt; n; priority_queue\u0026lt;pis, vector\u0026lt;pis\u0026gt;, greater\u0026lt;pis\u0026gt; \u0026gt; q; while(n--) { string s; int h; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; h; q.emplace(h, s); if(q.size() \u0026gt; 2) q.pop(); } cout \u0026lt;\u0026lt; q.top().second \u0026lt;\u0026lt; endl; return 0; } C - Secret Number\r题目大意\r有一个四位的PIN。这个PIN由0~9组成，也可能以0开头。\n有一个字符串$S_0S_1\\dots S_9$，代表每一种数字是否在这个PIN中出现：\n如果$S_i=~$o，这个PIN肯定包含数字$i$； 如果$S_i=~$x，这个PIN肯定不包含数字$i$； 如果$S_i=~$?，这个PIN可能包含（也可能不包含）数字$i$。 有多少个合法的PIN？\n$S$是一个由o、x、?组成的长度为$10$的字符串。\n输入格式\r$S$\n输出格式\r将答案输出为一个整数。\n样例\r$S$ 答案 ooo???xxxx $108$ o?oo?oxoxo $0$ xxxxx?xxxo $15$ 极端测试点：$S=~$??????????，正确输出：$10000$ 分析\r因为可能的PIN数量非常少（最多只有$10000$个），所以我们考虑暴力枚举所有可能的PIN，即尝试0000到9999之间所有的PIN。对于每个可能的PIN，我们可以在$\\mathcal O(|S|)$的时间内判断出它是否合法。\n程序的总时间复杂度为$\\mathcal O(10000|S|)$，由于$10000$和$|S|$都是常数，所以也可以看作$\\mathcal O(1)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;cstdio\u0026gt; using namespace std; char s[15]; inline bool valid(int a, int b, int c, int d) { bool used[10] = {false}; used[a] = used[b] = used[c] = used[d] = true; for(int i=0; i\u0026lt;10; i++) if(s[i] == \u0026#39;o\u0026#39;) { if(!used[i]) return false; } else if(s[i] == \u0026#39;x\u0026#39; \u0026amp;\u0026amp; used[i]) return false; return true; } int main() { scanf(\u0026#34;%s\u0026#34;, s); int ans = 0; for(int a=0; a\u0026lt;10; a++) for(int b=0; b\u0026lt;10; b++) for(int c=0; c\u0026lt;10; c++) for(int d=0; d\u0026lt;10; d++) ans += valid(a, b, c, d); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Game in Momotetsu World\r题目大意\r我们有一个$H\\times W$的棋盘，它上面每个小格子都是蓝色或红色的。棋盘上$(i,j)$这个点的颜色取决于$A_{i,j}$。如果$A_{i,j}=~$+，则$(i,j)$为蓝；如果$A_{i,j}=~$-，则$(i,j)$为红。\n在棋盘上有一颗棋子，它的初始位置在左上角，也就是$(1,1)$。Takahashi和Aoki要用这颗棋子对战。两人一开始都有$0$分，他们要轮流执行如下操作，Takahashi先走：\n将棋子往右或下移动（不能移出棋盘）。然后，如果移到的点是蓝色的，对应的玩家得一分；否则，玩家扣一分。 当棋子走到$(H,W)$时，游戏结束。此时，如果两人得分相等，则视为平局；否则，得分多的人胜利。\n当两人都按最优操作进行游戏时，求最终的游戏结果。\n$1\\le H,W\\le 2000$\n$A_{i,j}$是+或-。\n输入格式\r$H~W$\n$A_{1,1}A_{1,2}A_{1,3}\\dots A_{1,W}$\n$A_{2,1}A_{2,2}A_{2,3}\\dots A_{2,W}$\n$\\vdots$\n$A_{H,1}A_{H,2}A_{H,3}\\dots A_{H,W}$\n输出格式\r如果Takahashi会赢，输出Takahashi；如果Aoki，输出Aoki；否则，游戏平局，输出Draw。\n样例\r略，请自行前往AtCoder查看。\n分析\r本题可以使用动态规划的思想。\n我们设$d$为$(\\text{Takahashi目前的得分})-(\\text{Aoki目前的得分})$，则Takahashi的目标是最大化$d$、Aoki的目标是最小化$d$。我们很容易想到，对于棋子在$(i,j)$时，如果$(i+j)$是奇数，则Aoki走棋，如果它是偶数，则Takahashi走棋。\n所以，对于棋盘上的每个点$(i,j)$我们考虑如下$\\text{dp}$：\n如果$(i+j)$是偶数：棋子在$(i,j)$时最小的$d$（这是Aoki走棋）。 如果$(i+j)$是奇数：棋子在$(i,j)$时最大的$d$（这是Takahashi走棋）。 我们设$add(i,j)$为玩家把棋子走到$(i,j)$获得的分数，则有如下$\\text{dp}$状态：\n如果$(i+j)$是偶数：$dp(i,j)=\\min(dp(i+1,j)-add(i+1,j),dp(i,j+1)-add(i, j+1))$ 如果$(i+j)$是奇数：$dp(i,j)=\\max(dp(i+1,j)+add(i+1,j),dp(i,j+1)+add(i, j+1))$ 所以，最终我们只需要通过$dp(0,0)$判断结果即可。如果$dp(0,0) \u003e 0$，则Takahashi胜；如果$dp(0,0) \u003c 0$，Aoki胜；否则，游戏平局。\n程序的总时间复杂度为$\\mathcal O(NM)$。\n代码\r注意：我这里的dp运用了滚动表的技巧，所以是一维的，当然也可以使用普通的二维dp。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 2005 using namespace std; int dp[maxn], add[maxn][maxn]; int main() { int h, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;h, \u0026amp;w); for(int i=0; i\u0026lt;h; i++) { char tmp[maxn]; scanf(\u0026#34;%s\u0026#34;, tmp); for(int j=0; j\u0026lt;w; j++) add[i][j] = tmp[j] == \u0026#39;+\u0026#39;? 1: -1; } dp[w - 1] = 0; for(int j=w-2; j\u0026gt;=0; j--) dp[j] = j + h \u0026amp; 1? dp[j + 1] + add[h - 1][j + 1]: dp[j + 1] - add[h - 1][j + 1]; for(int i=h-2; i\u0026gt;=0; i--) { dp[w - 1] = i + w \u0026amp; 1? dp[w - 1] + add[i + 1][w - 1]: dp[w - 1] - add[i + 1][w - 1]; for(int j=w-2; j\u0026gt;=0; j--) if(i + j \u0026amp; 1) dp[j] = min(dp[j] - add[i + 1][j], dp[j + 1] - add[i][j + 1]); else dp[j] = max(dp[j] + add[i + 1][j], dp[j + 1] + add[i][j + 1]); } if(dp[0] \u0026gt; 0) puts(\u0026#34;Takahashi\u0026#34;); else if(dp[0] \u0026lt; 0) puts(\u0026#34;Aoki\u0026#34;); else puts(\u0026#34;Draw\u0026#34;); return 0; } E - Xor Distances\r题目大意\r我们有一棵由$N$个顶点组成的加权树。第$i$条边双向连接着顶点$u_i$和$v_i$且有一个权值$w_i$。\n对于一对顶点$(x,y)$（$x\\ne y$），我们如下定义$\\mathrm{dist}(x,y)$：\n$\\mathrm{dist}(x,y)=x$和$y$之间的最短路径经过的所有边权值的异或结果。 输出每对点$(i,j)$的$\\mathrm{dist}(i,j)$之和，对$(10^9+7)$取模，即$\\sum\\limits_{i=1}^{N-1}\\sum\\limits_{j=i+1}^N \\mathrm{dist}(i,j)\\bmod(10^9+7)$。\n$1\\le N\\le 2\\times10^5$\n$1\\le u_i \u003c v_i\\le N$\n$0\\le w_i \u003c 2^{60}$\n输入格式\r$N$\n$u_1~v_1~w_1$\n$u_2~v_2~w_2$\n$\\vdots$\n$u_{N-1}~v_{N-1}~w_{N-1}$\n输出格式\r输出每对点$(i,j)$的$\\mathrm{dist}(i,j)$之和，对$(10^9+7)$取模。\n样例\r略，请自行前往AtCoder查看\n分析\r首先，我们先看数据范围。\n$1\\le N\\le 2\\times10^5$\n这样一来，最暴力的$\\mathcal O(n^3)$解法，即枚举所有对点$\\mathcal O(n^2)$、找最短路$\\mathcal O(n)$就肯定不行了。\n其次，我们尝试优化暴力过程，考虑异或（$\\oplus$）的几个特征：\n$0\\oplus A = A$ $A\\oplus A = 0$ $A\\oplus B = B\\oplus A$ $A\\oplus B\\oplus B = A$ $$\\begin{aligned}\\mathrm{dist}(x,y)\u0026=\\mathrm{dist}(x,k)\\oplus\\mathrm{dist}(y,k)\\\\\u0026=\\mathrm{dist}(x,k)\\oplus\\mathrm{dist}(y,k)\\oplus(\\mathrm{dist}(n,k)\\oplus\\mathrm{dist}(n,k))\\\\\u0026=(\\mathrm{dist}(x,k)\\oplus\\mathrm{dist}(n,k))\\oplus(\\mathrm{dist}(y,k)\\oplus\\mathrm{dist}(n,k))\\\\\u0026=\\mathrm{dist}(x,n)\\oplus\\mathrm{dist}(y,n)\\end{aligned}$$这时，我们可以令$n=1$，并从$n$开始跑一遍搜索，计算出所有的$\\mathrm{dist}(n,x)$（时间复杂度$\\mathcal O(n)$），再对所有的$(i,j)$求出所有的$\\mathrm{dist}(n,i)\\oplus\\mathrm{dist}(n,j)$并求和（时间复杂度$\\mathcal O(n^2)$），算出结果。这样做的总时间复杂度为$\\mathcal O(n^2)$。可惜，这样还是过不去。\n我们考虑进一步优化。我们发现，对于每个二进制位，在异或的操作下，一个$1$和一个$0$就能组成一个$1$。所以，我们可以统计每一位的$0$和$1$的个数，计算它们的乘积并相加即可。\n代码\r这里的搜索推荐$\\text{BFS}$，因为这道题中它比$\\text{DFS}$好写且更快，当然$\\text{DFS}$也可以实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #define maxn 200005 #define MOD 1000000007LL using namespace std; using LL = long long; vector\u0026lt;pair\u0026lt;int, LL\u0026gt;\u0026gt; G[maxn]; LL d[maxn]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=1; i\u0026lt;n; i++) { int u, v; LL w; scanf(\u0026#34;%d%d%lld\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); G[--u].emplace_back(--v, w); G[v].emplace_back(u, w); } queue\u0026lt;int\u0026gt; q; q.push(0); for(int i=1; i\u0026lt;n; i++) d[i] = -1; while(!q.empty()) { int v = q.front(); q.pop(); for(auto [u, w]: G[v]) if(d[u] == -1) q.push(u), d[u] = d[v] ^ w; } LL ans = 0LL; for(int i=0; i\u0026lt;60; i++) { int cnt = 0; for(int j=0; j\u0026lt;n; j++) if(d[j] \u0026gt;\u0026gt; i \u0026amp; 1LL) cnt ++; if((ans += (1LL \u0026lt;\u0026lt; i) % MOD * cnt % MOD * (n - cnt) % MOD) \u0026gt; MOD) ans -= MOD; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2021-05-18T19:30:00+08:00","permalink":"https://goodcoder666.github.io/p/abc201/","title":"Mynavi Programming Contest 2021 (AtCoder Beginner Contest 201) A~E 题解"},{"content":"A - Div\r题目大意\r两个男孩要分$N$颗糖。问一共有几种分法（每个男孩都必须分到糖）？\n$1\\le N\\le 15$\n输入格式\r$N$\n输出格式\r将答案输出为一个整数。\n样例\r$N$ 输出 $2$ $1$ $1$ $0$ $3$ $2$ 分析\r这题说白了就是将$N$分成$A$和$B$两个正整数的和（$A+B$和$B+A$是两种分法），所以列表如下：\n$A$ $B$ $1$ $N-1$ $2$ $N-2$ $\\dots$ $\\dots$ $N-1$ $1$ 这个表一共有$N-1$项，所以我们直接输出$N-1$即可。 代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;%d\\n\u0026#34;, n - 1); return 0; } B - Palindrome with leading zeros\r题目大意\r给定一个整数$N$。\n是否可以在$N$的十进制表示的前面填上任意（可以为$0$）个0，使得$N$变成一个回文数？\n$0\\le N\\le 10^9$\n输入格式\r$N$\n输出格式\r输出Yes或者No。\n样例\r$N$ 输出 $1210$ Yes $777$ Yes $123456789$ No 分析\r如果能在$N$的前面加上一些0使得$N$变成一个回文数，那么将$N$去掉末尾的所有0后也一定能得到一个回文数。所以，我们只需将$N$末尾的0去掉后，再判断它是不是一个回文数即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;cstdio\u0026gt; using namespace std; char s[10]; int main() { char c; int len = 0; while((c = getchar()) != \u0026#39;\\n\u0026#39;) s[len++] = c; while(len \u0026gt; 0 \u0026amp;\u0026amp; s[--len] == \u0026#39;0\u0026#39;); for(int i=0; i\u0026lt;=len; i++) if(s[i] != s[len - i]) { puts(\u0026#34;No\u0026#34;); return 0; } puts(\u0026#34;Yes\u0026#34;); return 0; } C - Compass Walking\r题目大意\r在一个二维的平面上，一个人每一步都只能走正好$R$个距离单位。\n这个人从$(0,0)$走到$(X,Y)$至少需要多少步？\n注意：在二维平面上，两个点$(x_1, y_1)$和$(x_2,y_2)$的距离是$\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。\n$1\\le R\\le 10^5$\n$0\\le X,Y\\le 10^5$\n$(X,Y)\\ne(0,0)$\n输入格式\r$R~X~Y$\n输出格式\r输出一行，即最少需要的步数。\n样例\r$R$ $X$ $Y$ 输出 $5$ $15$ $0$ $3$ $5$ $11$ $0$ $3$ $3$ $4$ $4$ $2$ 分析\r我们可以先定义$d=\\sqrt{X^2+Y^2}$，即$(X,Y)$到$(0,0)$的距离，则有如下解法：\n如果$d = R$，则总共只需要$1$步。 如果$d \u003c R$，则总共需要$2$步。 如果$d \u003e R$，总共需要$\\lceil\\frac d r\\rceil$步。 这样，我们就可以写代码了。\n代码\r这题很容易出现精度问题，但我用long double居然卡过去了……\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int r, x, y; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;r, \u0026amp;x, \u0026amp;y); long double dist = hypotl(x, y); if(dist == r) puts(\u0026#34;1\u0026#34;); else if(dist \u0026lt; r) puts(\u0026#34;2\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, int(ceill(dist / r))); return 0; } D - Send More Money\r题目大意\r注意：本题的时间限制是$5$秒。\n给定三个由小写字母组成的字符串$S_1,S_2,S_3$。\n在这里，相同的字母表示相同的数字，不同的字母表示不同的数字。\n我们要找到一种每个字母对应的数字，并将它们分别填入$S_1,S_2,S_3$，变成三个无前导$0$的正整数$N_1,N_2,N_3$，使得$N_1+N_2=N_3$。如果有多组解，找到任意一组即可。\n$1\\le |S_1|,|S_2|,|S_3|\\le 10$\n输入格式\r$S_1$\n$S_2$\n$S_3$\n输出格式\r如果有解，输出三行，即$N_1,N_2$和$N_3$；如果无解，输出UNSOLVABLE。\n样例\r$S_1$ $S_2$ $S_3$ 输出 a b c 1 2 3 x x y 1 1 2 p q p UNSOLVABLE 分析\r很容易想到，因为每位能填的数字只有$0$到$9$（一共$10$个），所以如果$S_1,S_2$和$S_3$中总共不同的字母个数超过$10$个，我们就可以直接认为这个等式无解。\n现在，由于这道题时间限制较长，我们就可以暴力枚举每一种字母对应的数字（一共最多有$10!=3628800$种可能），再逐个填入并验证即可。\n代码\r这里的枚举我是用全排列做的，当然也可以用回溯法等，方法不限。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxl 15 using namespace std; using LL = long long; char s1[maxl], s2[maxl], s3[maxl], ch[maxl]; set\u0026lt;char\u0026gt; chars; int pos[26], num[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; #define N (num[pos[str[i] - \u0026#39;a\u0026#39;]]) inline LL parse(const char* str) { LL res = 0LL; for(int i=0; str[i]; i++) res = res * 10LL + N; return res; } inline void print(const char* str) { for(int i=0; str[i]; i++) putchar(N + \u0026#39;0\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); } #undef N inline void add(const char* str) { for(int i=0; str[i]; i++) chars.insert(str[i]); } inline bool isok(const char* str) { return num[pos[str[0] - \u0026#39;a\u0026#39;]] != 0; } int main() { scanf(\u0026#34;%s%s%s\u0026#34;, s1, s2, s3); add(s1), add(s2), add(s3); if(chars.size() \u0026gt; 11) { puts(\u0026#34;UNSOLVABLE\u0026#34;); return 0; } int cnt = 0; for(char x: chars) pos[x - \u0026#39;a\u0026#39;] = cnt++; do { if(isok(s1) \u0026amp;\u0026amp; isok(s2) \u0026amp;\u0026amp; isok(s3) \u0026amp;\u0026amp; (parse(s1) + parse(s2) == parse(s3))) { print(s1); print(s2); print(s3); return 0; } } while(next_permutation(num, num + 10)); puts(\u0026#34;UNSOLVABLE\u0026#34;); return 0; } P.S. 这段代码的运行速度不可思议的快…… 居然只花了$109$ms……\nE - Unique Color\r题目大意\r给你一棵由编号为$1,2,~\\dots,N$的$N$个顶点组成的树。其中，第$i$条边连接着顶点$A_i$和$B_i$。第$i$个顶点的颜色是$C_i$（在这里，颜色用一个整数表示）。\n我们定义一个顶点$x$是好的，仅当如下条件成立：\n从顶点$1$到顶点$x$的最短路径上，没有与顶点$x$颜色相同的点（顶点$x$本身除外）。 找到所有的好的顶点。\n$2\\le N\\le 10^5$\n$1\\le C_i\\le 10^5$\n$1\\le A_i,B_i\\le 10^5$\n输入格式\r$N$\n$C_1~\\dots~C_N$\n$A_1~B_1$\n$\\vdots$\n$A_{N-1}~B_{N-1}$\n输出格式\r输出所有的好的顶点，按升序排序，每行一个。\n样例\r略，请自行前往AtCoder查看\n分析\r其实这题用最朴素的$\\text{DFS}$算法就能解决。\n我们在搜索的同时，维护一个$\\text{used}$数组，记录每个颜色在路径上是否已经用过。这样，我们就能$\\mathcal O(1)$地判断每个点是否是一个好的点，最后排序并输出即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 100005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; bool used[maxn]; int color[maxn]; set\u0026lt;int\u0026gt; res; void dfs(int v, int par) { if(used[color[v]]) { for(int u: G[v]) if(u != par) dfs(u, v); return; } used[color[v]] = true; res.insert(v); for(int u: G[v]) if(u != par) dfs(u, v); used[color[v]] = false; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%d\u0026#34;, color + i); while(--n) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G[x].push_back(y); G[y].push_back(x); } dfs(1, -1); for(int v: res) printf(\u0026#34;%d\\n\u0026#34;, v); return 0; } ","date":"2021-04-13T21:29:00+08:00","permalink":"https://goodcoder666.github.io/p/abc198/","title":"AtCoder Beginner Contest 198 A~E 题解"},{"content":"原题链接：洛谷链接；AtCoder链接\n思路\r每次根据上一位，计算下一位为TA-1/TA/TA+1，放入queue中，最后输出第$K$次弹出的整数。\n注意事项\r不用long long会WA！ 上一位为$0$时下一位不能为$-1$！（要特判） 上一位为$9$时下一位不能为$10$！（也要特判） 代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; typedef long long LL; int main(int argc, char** argv) { int k; scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); queue\u0026lt;LL\u0026gt; q; for(int i=1; i\u0026lt;10; i++) q.push(i); while(true) { LL x = q.front(); q.pop(); if(--k == 0) { printf(\u0026#34;%lld\\n\u0026#34;, x); return 0; } int r = x % 10LL; x *= 10LL; x += r; if(r \u0026gt; 0) q.push(x - 1); q.push(x); if(r \u0026lt; 9) q.push(x + 1); } return 0; } ","date":"2021-04-01T19:53:00+08:00","permalink":"https://goodcoder666.github.io/p/abc161/","title":"AtCoder Beginner Contest 161D 题解"},{"content":"A - Difference Max\r题目大意\r给定四个整数$a,b,c$和$d$。\n我们要选择两个整数$x$和$y$（$a\\le x\\le b$；$c\\le y\\le d$）。输出最大的$x-y$。\n$-100\\le a\\le b\\le 100$\n$-100\\le c\\le d\\le 100$\n输入格式\r$a~~b$\n$c~~d$\n输出格式\r输出最大的$x-y$。\n样例\r$a$ $b$ $c$ $d$ 输出 $0$ $10$ $0$ $10$ $10$ $-100$ $-100$ $100$ $100$ $200$ $-100$ $100$ $-100$ $100$ $200$ 分析\r如果要$x-y$最大，那么$x$要尽可能大、$y$要尽可能小。因此，$x$取最大值$b$，$y$取最小值$c$。所以，我们直接输出$b-c$即可。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c, d; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); printf(\u0026#34;%d\\n\u0026#34;, b - c); return 0; } B - Round Down\r题目大意\r给定一个数$X$，求$\\lfloor X\\rfloor$。\n$0\\le X\\le 10^{100}$\n输入格式\r$X$\n输出格式\r输出$\\lfloor X\\rfloor$。\n样例\r$X$ 输出 $5.90$ $5$ $0$ $0$ $84939825309432908832902189.9092309409809091329$ $84939825309432908832902189$ 分析\r只需找到小数点并将其及后面的数位删去再输出即可。例如：$5\\sout{.90}$\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char c; while((c = getchar()) != \u0026#39;\\n\u0026#39;) { if(c == \u0026#39;.\u0026#39;) return 0; putchar(c); } return 0; } C - Doubled\r题目大意\r$1$~$N$之间有多少个数是另一个正整数重复两遍得来的？\n$1\\le N \u003c 10^{12}$\n输入格式\r$N$\n输出格式\r输出答案。\n样例\r$N$ 输出 $33$ $3$ $1333$ $13$ $10000000$ $999$ 分析\r这道题说白了就是要找到最大的$X$，使得$X$重复两遍不超过$N$，并输出$X$。我们可以使用二分法求出最大的$X$。\n注意：这里的二分右边界最好设置为$\\sqrt N$，否则一不小心就会溢出！\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; typedef long long LL; inline bool check(const LL\u0026amp; x, const LL\u0026amp; n) { LL p = 1LL; while(p \u0026lt;= x) p *= 10LL; return x * p + x \u0026lt;= n; } int main() { LL n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); LL l = 0LL, r = sqrt(n); while(l \u0026lt; r) { LL mid = l + r + 1LL \u0026gt;\u0026gt; 1LL; if(check(mid, n)) l = mid; else r = mid - 1; } printf(\u0026#34;%lld\\n\u0026#34;, l); return 0; } D - Hanjo\r题目大意\r有一个$H\\times W$的地板，请你在地板上铺砖。\n有两种地砖：$a$和$b$。$a$地砖有$A$个，是$2\\times1$的可旋转长方形。$b$地砖有$B$个，是$1\\times1$的正方形。问要将这个地板正好铺满，总共有多少种铺法？\n$1\\le H,W,HW\\le 16$\n$0\\le A,B$\n$2A+B=HW$\n输入格式\r$H~W~A~B$\n输出格式\r输出答案。\n样例\r$H$ $W$ $A$ $B$ 输出 $2$ $2$ $1$ $2$ $4$ $3$ $3$ $4$ $1$ $18$ $4$ $4$ $8$ $0$ $36$ 分析\r由于数据范围较小，我们可以用暴力搜索解决这道题。注意，这里搜索时为了避免重复计算，我们每次递归只尝试一个位置，这样还能有效加速。具体请看代码。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;cstdio\u0026gt; #define maxn 20 using namespace std; bool mat[maxn][maxn]; int h, w, a, b, ans; inline bool valid(int x, int y) { return !mat[x][y] \u0026amp;\u0026amp; x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; h \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; w; } void dfs(int i, int j, int usedA, int usedB) { if((usedA \u0026lt;\u0026lt; 1) + usedB == h * w) { ans ++; return; } if(i == h) return; int ni, nj; if(j == w - 1) ni = i + 1, nj = 0; else ni = i, nj = j + 1; if(mat[i][j]) { dfs(ni, nj, usedA, usedB); return; } mat[i][j] = true; // Rectangle (A) if(usedA \u0026lt; a) { if(valid(i, j + 1)) { mat[i][j + 1] = true; dfs(ni, nj, usedA + 1, usedB); mat[i][j + 1] = false; } if(valid(i + 1, j)) { mat[i + 1][j] = true; dfs(ni, nj, usedA + 1, usedB); mat[i + 1][j] = false; } } // Square (B) if(usedB \u0026lt; b) dfs(ni, nj, usedA, usedB + 1); mat[i][j] = false; } int main() { scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;h, \u0026amp;w, \u0026amp;a, \u0026amp;b); dfs(0, 0, 0, 0); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } E - Filters\r题目大意\r给定三个整数序列$A = (a_1, a_2, \\dots, a_N)$、$T = (t_1, t_2, \\dots, t_N)$和$X = (x_1, x_2, \\dots, x_Q)$。\n我们如下定义$N$个函数$f_1(x), f_2(x), \\dots, f_N(x)$：\n$f_i(x) = \\begin{cases} x + a_i \u0026 (t_i = 1)\\\\ \\max(x, a_i) \u0026 (t_i = 2)\\\\ \\min(x, a_i) \u0026 (t_i = 3)\\\\ \\end{cases}$\n对于每个$i = 1, 2, \\dots, Q$，求$f_N( \\dots f_2(f_1(x_i)) \\dots )$。\n$1 \\le N,Q \\le 2 \\times 10^5$\n$|a_i|,|x_i|\\le 10^9$\n$1 \\le t_i \\le 3$\n输入格式\r$N$\n$a_1~t_1$\n$a_2~t_2$\n$\\vdots$\n$a_N~t_N$\n$Q$\n$x_1~x_2~\\dotsx x_q$\n输出格式\r输出$Q$行。第$i$行应该包含$f_N( \\dots f_2(f_1(x_i)) \\dots )$。\n样例\r样例输入\r1 2 3 4 5 6 3 -10 2 10 1 10 3 5 -15 -10 -5 0 5 样例输出\r1 2 3 4 5 0 0 5 10 10 在这里，$f_1(x) = \\max(x, -10), f_2(x) = x + 10, f_3(x) = \\min(x, 10)$，则有：\n$f_3(f_2(f_1(-15))) = 0$ $f_3(f_2(f_1(-10))) = 0$ $f_3(f_2(f_1(-5))) = 5$ $f_3(f_2(f_1(0))) = 10$ $f_3(f_2(f_1(5))) = 10$ 分析\r（参考AtCoder官方题解）\n很容易想到，我们可以直接照做，即分别计算每个$f_N( \\dots f_2(f_1(x_i)) \\dots )$。但是，这样做的时间复杂度是$\\mathcal O(NQ)$，所以肯定会TLE。\n我们考虑它们的复合函数$F(x)=f_N( \\dots f_2(f_1(x_i)) \\dots )$在图上怎么表示。\n当$t_i=1$，$f_i$是将图整体平移的操作； 当$t_i=2$，$f_i$是将图的最小值设为$a_i$； 当$t_i=3$，$f_i$是将图的最大值设为$a_i$。 所以，我们可以得到下图：\n或者说，存在三个数$a,b,c$使得$F(x)=\\min(c,\\max(b,x+a))$。\n关于$a,b,c$的具体计算请看代码。\n代码\r注意：这里的代码中的$\\infty$（INF）一定不能直接设为long long的最大值，否则会溢出！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; typedef long long LL; const LL INF = LLONG_MAX \u0026gt;\u0026gt; 1LL; int main() { LL l = -INF, r = INF, add = 0LL; int n, q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while(n--) { LL a, t; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a, \u0026amp;t); if(t == 1) l += a, r += a, add += a; else if(t == 2) l = max(l, a), r = max(r, a); else l = min(l, a), r = min(r, a); } scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while(q--) { LL x; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); printf(\u0026#34;%lld\\n\u0026#34;, clamp(x + add, l, r)); } return 0; } ","date":"2021-04-01T19:53:00+08:00","permalink":"https://goodcoder666.github.io/p/abc196/","title":"AtCoder Beginner Contest 196 A~E 题解"},{"content":"A - Health M Death\r题目大意\r有一位魔术师，他正在打一个血量为$H$?的怪兽。\n当怪兽的血量是$M$的倍数时，魔术师能打败怪兽。\n魔术师能打败怪兽吗？\n$1\\le M,H\\le 1000$\n输入格式\r$M~H$\n输出格式\r如果魔术师能打败怪兽，输出Yes；如果不能，输出No。\n样例\r$M$ $H$ 输出 $10$ $120$ Yes $10$ $125$ No 分析\r只需判断$H$是否是$M$的倍数即可。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int m, h; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;m, \u0026amp;h); puts(h % m == 0? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Many Oranges\r题目大意\r我们有很多橙子。每个橙子的重量在$A$克到$B$克之间（包含$A$、$B$克，可能为小数）。\n这些橙子的总重量为$W$千克。\n找到橙子最少和最多的数量。\n$1\\le A\\le B\\le 1000$\n$1\\le W\\le 1000$\n输入格式\r$A~B~W$\n输出格式\r输出橙子最少和最多的数量，用一个空格隔开；如果数据不合法，输出UNSATISFIABLE。\n样例\r$A$ $B$ $W$ 输出 $100$ $200$ $2$ $10~20$ $120$ $150$ $2$ $14~16$ $300$ $333$ $1$ UNSATISFIABLE 分析\r如果要得到最小的结果，那么每个橙子的单价必定要取最大值。所以，我们设$min=\\lceil\\frac WB\\rceil$。\n同理，如果要得到最大的结果，那么每个橙子的单价必定要取最小值。所以，我们设$max=\\lfloor\\frac WA\\rfloor$。\n计算完成后，如果$min \u003e max$，说明数据不合法；否则，输出$min$和$max$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;w); w *= 1000; int min = w % b == 0? w / b: w / b + 1; int max = w / a; if(min \u0026gt; max) puts(\u0026#34;UNSATISFIABLE\u0026#34;); else printf(\u0026#34;%d %d\\n\u0026#34;, min, max); return 0; } C - Comma\r题目大意\r我们写一个整数时，可以从右开始每隔三位写一个逗号。如，$1234567$写作1,234,567、$777$直接写作777。\n如果我们写下$1$到$N$之间的所有整数，一共要用多少个逗号？\n$1\\le N\\le 10^{15}$\n输入格式\r$N$\n输出格式\r输出总共需要的逗号的数量。\n样例\r$N$ 输出 $1010$ $11$ $27182818284590$ $107730272137364$ 分析\r我们可以按位置数逗号的数量。首先，在从右往左数的第一个逗号的位置，只要大于$1000$的数都需要写逗号。以此类推，在从右往左数的第$N$个逗号的位置，只要大于$1000^N$的数都需要写逗号。这样，我们就可以通过上述算法写出代码了。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;cstdio\u0026gt; using namespace std; typedef long long LL; int main() { LL n, ans = 0LL; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for(LL p=1000LL; p\u0026lt;=n; p*=1000LL) ans += n - p + 1; printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } D - Shipping Center\r题目大意\r我们有$N$个包裹（包裹$1$，……，包裹$N$）和$M$个盒子（盒子$1$，……，盒子$N$）。\n第$i$个包裹的大小和价值分别是$W_i$和$V_i$。\n第$i$个盒子最多只能装一个大小为$X_i$的包裹。\n给你$Q$组询问，每组包含两个整数$L$和$R$，请回答下列问题：\n在这$M$个盒子中，盒子$L,L+1,\\dots,R$暂时不可用。请把包裹放进剩余的盒子（不一定要全放）并输出最大可能的总价值。 $1\\le N,M,Q\\le 50$\n$1\\le W_i,V_i,X_i\\le 10^6$\n$1\\le L\\le R\\le M$\n输入格式\r$N~M~Q$\n$W_1~V_1$\n$\\vdots$\n$W_N~V_N$\n$X_1~\\dots~X_M$\n$L_1~R_1$\n$\\vdots$\n$L_Q~R_Q$\n输出格式\r输出$Q$行。第$i$行应该包含$L_i$和$R_i$这个询问对应的答案。\n样例\r样例输入\r1 2 3 4 5 6 7 8 3 4 3 1 9 5 3 7 8 1 8 6 9 4 4 1 4 1 3 样例输出\r1 2 3 20 0 9 分析\r这道题看似很像背包问题，其实不然。我们只需升序排序数组$X$后，再按顺序贪心地为每个盒子选择它能拿到的价值最高的包裹即可。总时间复杂度为$\\mathcal O(NMQ)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 55 using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; pii bags[maxn], boxes[maxn]; bool taken[maxn]; int main() { int n, m, q; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;bags[i].second, \u0026amp;bags[i].first); sort(bags, bags + n, greater\u0026lt;pii\u0026gt;()); for(int i=0; i\u0026lt;m; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;boxes[i].first), boxes[i].second = i; sort(boxes, boxes + m); while(q--) { int l, r, ans = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); l --, r --; fill(taken, taken + n, false); for(int i=0; i\u0026lt;m; i++) { auto [size, idx] = boxes[i]; if(idx \u0026lt; l || idx \u0026gt; r) { int j = 0; for(; j\u0026lt;n; j++) if(!taken[j] \u0026amp;\u0026amp; bags[j].second \u0026lt;= size) break; if(j \u0026lt; n) ans += bags[j].first, taken[j] = true; } } printf(\u0026#34;%d\\n\u0026#34;, ans); } return 0; } E - Lucky 7 Battle\r题目大意\r我们有一个长度为$N$、由数字0~9组成的字符串$S$，和一个长度同样为$N$、由A和T组成的字符串$X$。\nTakahashi和Aoki要用这两个字符串玩一个$N$轮的游戏。最开始，他们有一个空的字符串$T$。在第$i$轮（$1\\le i\\le N$），他们要做下列事情：\n如果$X_i$为A，Aoki执行下面的操作；如果$X_i$为T，则Takahashi执行下面的操作： 将$S_i$或者0加到$T$的后面。 在$N$个操作之后，$T$会变成一个数字0~9组成的字符串。如果我们把它看成一个十进制数（去掉前导$0$），那么如果这个数为$7$的倍数，则Takahashi胜；相反，如果这个数不为$7$的倍数，则Aoki胜。\n判断当两个人都按照最优操作进行游戏时，谁会赢。\n$1\\le N\\le 10^5$\n$|S|=|X|=N$\n输入格式\r$N$\n$S$\n$X$\n输出格式\r输出胜者的名字（Takahashi或者Aoki）。\n样例\r略，请自行前往AtCoder查看\n分析\r这题首先很容易想到使用搜索。我们定义$\\mathrm{winner}(i,r)=~$在第$i$轮$T\\bmod7=r$最终的赢家。\n我们会发现，由于$r$只有$0$~$6$，计算重复率较高，所以这题可以使用记忆化搜索来解决。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define AO 0 #define TA 1 #define maxn 200005 using namespace std; char s[maxn], x[maxn]; int n, dp[maxn][7]; int winner(int i, int r) { if(dp[i][r] != -1) return dp[i][r]; if(i \u0026gt;= n) return dp[i][r] = r == 0; if(winner(i + 1, 10 * r % 7) == TA) { if(x[i] == \u0026#39;T\u0026#39;) return dp[i][r] = TA; } else if(x[i] == \u0026#39;A\u0026#39;) return dp[i][r] = AO; if(winner(i + 1, (10 * r + s[i] - \u0026#39;0\u0026#39;) % 7) == TA) { if(x[i] == \u0026#39;T\u0026#39;) return dp[i][r] = TA; } else if(x[i] == \u0026#39;A\u0026#39;) return dp[i][r] = AO; return dp[i][r] = x[i] == \u0026#39;A\u0026#39;; } int main() { scanf(\u0026#34;%d%s%s\u0026#34;, \u0026amp;n, s, x); memset(dp, -1, sizeof(dp)); puts(winner(0, 0) == TA? \u0026#34;Takahashi\u0026#34;: \u0026#34;Aoki\u0026#34;); return 0; } ","date":"2021-03-25T20:24:00+08:00","permalink":"https://goodcoder666.github.io/p/abc195/","title":"Panasonic Programming Contest (AtCoder Beginner Contest 195) A~E 题解"},{"content":"A - I Scream\r题目大意\r在日本，有如下四种冰淇淋产品：\n至少有$15\\%$的milk solids和$8\\%$的milk fat的产品称为“冰淇淋”； 至少有$10\\%$的milk solids和$3\\%$的milk fat且不是冰淇淋的产品称为“冰奶”； 至少有$3\\%$的milk solids且不是冰淇淋或冰奶**的产品称为“乳冰”； 不是以上三种的产品称为“调味冰”。 在这里，milk solids由milk fat和milk solids-not-fat组成。\n有一种冰淇淋产品，它由$A\\%$的milk solids-not-fat和$B\\%$的milk fat组成。\n这种产品是上述的哪一类？\n$0\\le A,B\\le 100$\n$0\\le A+B\\le 100$\n输入格式\r$A~B$\n输出格式\r请按如下格式输出类别：\n如果这是冰淇淋，输出$1$； 如果这是冰奶，输出$2$； 如果这是乳冰，输出$3$； 如果这是调味冰，输出$4$。 样例\r$A$ $B$ 输出 $10$ $8$ $1$ $1$ $2$ $3$ $0$ $0$ $4$ 分析\r只需将$A$加上$B$（变为milk solids的占比），再按题目所说的判断即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); a += b; if(a \u0026gt;= 15 \u0026amp;\u0026amp; b \u0026gt;= 8) puts(\u0026#34;1\u0026#34;); else if(a \u0026gt;= 10 \u0026amp;\u0026amp; b \u0026gt;= 3) puts(\u0026#34;2\u0026#34;); else if(a \u0026gt;= 3) puts(\u0026#34;3\u0026#34;); else puts(\u0026#34;4\u0026#34;); return 0; } B - Job Assignment\r题目大意\r$$t=\r\\begin{cases}\rA_i+B_i \u0026 (i=j) \\\\\r\\max\\{A_i,B_j\\} \u0026 (i\\ne j) \\\\\r\\end{cases}$$\n求最小的$t$。\n$2\\le N\\le 1000$\n$1\\le A_i,B_i\\le 10^5$\n输入格式\r$N$\n$A_1~B_1$\n$A_2~B_2$\n$\\vdots$\n$A_N~B_N$\n输出格式\r输出答案。\n样例\r略，请自行前往AtCoder查看\n分析\r这题由于$N$最大只有$10^3$，所以枚举是完全可行的，只要枚举所有的$(i,j)$，再根据题目里的公式求出答案取最小值即可，这样做总时间复杂度为$\\mathcal O(n^2)$。\n另外，本题也有贪心的$\\mathcal O(n)$的算法，但是情况太多，代码太麻烦，所以这里不写。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #define maxn 1005 #define INF 2147483647 using namespace std; int a[maxn], b[maxn]; inline void setmin(int\u0026amp; x, int y) { if(y \u0026lt; x) x = y; } inline int max(int x, int y) { return x \u0026gt; y ? x : y; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d%d\u0026#34;, a + i, b + i); int ans = INF; for(int i=0; i\u0026lt;n; i++) { setmin(ans, a[i] + b[i]); // i == j for(int j=i+1; j\u0026lt;n; j++) { setmin(ans, max(a[i], b[j])); setmin(ans, max(a[j], b[i])); } } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } C - Squared Error\r题目大意\r给你一个长度为$N$的序列$A$。\n输出$\\displaystyle \\sum_{i = 2}^{N} \\sum_{j = 1}^{i - 1} (A_i - A_j)^2$。\n$2 \\le N \\le 3 \\times 10^5$\n$|A_i| \\le 200$\n输入格式\r$N$\n$A_1~A_2~A_3~\\dots~A_N$\n输出格式\r输出一行，即$\\displaystyle \\sum_{i = 2}^{N} \\sum_{j = 1}^{i - 1} (A_i - A_j)^2$。\n样例\r样例输入1\r1 2 3 2 8 4 样例输出1\r1 56 通过计算，我们得到$\\displaystyle \\sum_{i = 2}^{N} \\sum_{j = 1}^{i - 1} (A_i - A_j)^2 = (8 - 2)^2 + (4 - 2) ^ 2 + (4 - 8) ^ 2 = 56$。\n样例输入2\r1 2 5 -5 8 9 -4 -3 样例输出2\r1 950 分析\r$$\\sum_{i = 2}^{N} \\sum_{j = 1}^{i - 1} (A_i - A_j)^2$$$$\\sum_{i = 2}^{N} \\sum_{j = 1}^{i - 1} {A_i}^2+{A_j}^2-2A_iA_j$$$$(\\sum_{i = 2}^{N} \\sum_{j = 1}^{i - 1} {A_i}^2)+(\\sum_{i = 2}^{N} \\sum_{j = 1}^{i - 1} {A_j}^2)-(\\sum_{i = 2}^{N} \\sum_{j = 1}^{i - 1} 2A_iA_j)$$$$(n-1)(\\sum_{i = 1}^{N} {A_i}^2)-2(\\sum_{i = 1}^{N} S_iA_i)$$\n这时，计算所有$S_i$的时间复杂度为$\\mathcal O(n)$，求最终结果的时间复杂度也是$\\mathcal O(n)$，所以总时间复杂度为$\\mathcal O(n)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #define maxn 300005 using namespace std; using LL = long long; int main() { int n, s1 = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); LL s2 = 0, m = 0LL; for(int i=0; i\u0026lt;n; i++) { LL x; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); m += x * s1; s1 += x, s2 += x * x; } m \u0026lt;\u0026lt;= 1LL, s2 *= n - 1LL; printf(\u0026#34;%lld\\n\u0026#34;, s2 - m); return 0; } D - Journey\r题目大意\r我们有一个$N$个顶点（称为顶点$1$、顶点$2$、……、顶点$N$）。\n目前，这个图没有任何边。\nTakahashi会重复执行以下操作，直到这个图变为连通图：\n从这$N$个顶点中随机选一个顶点。每个顶点被抽中的概率相等，即$\\frac 1 N$。 在现在站着的点和选中的顶点之间添加一条边，并走到这个点上。 求Takahashi执行操作次数的期望值。\n输入格式\r$N$\n输出格式\r输出答案，最大允许浮点数误差$10^{-6}$。\n样例\r$N$ 输出 $2$ $2$ $3$ $4.5$ 分析\r通过dp分析，我们可以得到$\\sum\\limits_{i=1}^{n-1}\\frac Ni$这个公式。这时，就可以写代码了。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); double res = 0; for(int i=1; i\u0026lt;n; i++) res += double(n) / i; printf(\u0026#34;%.8lf\\n\u0026#34;, res); return 0; } E - Mex Min\r题目大意\r我们定义$\\mathrm{mex}(x_1, x_2, x_3, \\dots, x_k)$为最小的不出现在$x_1, x_2, x_3, \\dots, x_k$中的自然数。\n给你一个长度为$N$的序列$A$：$(A_1, A_2, A_3, \\dots, A_N)$。\n对于每个$0\\le i\\le N-M$的整数$i$，我们计算$\\mathrm{mex}(A_{i + 1}, A_{i + 2}, A_{i + 3}, \\dots, A_{i + M})$。输出这些$N-M+1$个结果中的最小值。\n样例\r略，请自行前往AtCoder查看\n分析\r先用最基本的方法想一下这道题，要求$\\mathrm{mex}(x_1, x_2, x_3, \\dots, x_k)$，只需记录每个$x_i$的出现次数，放进数组$\\text{cnt}$里（$\\text{cnt}_i=i$在$x$中出现的次数）。这时，只要找到$\\text{cnt}$中第一个$0$即可，这样计算$\\mathrm{mex}$的时间复杂度为$\\mathcal O(k)$。我们还可以想到一种优化方法，就是每一次计算$\\mathrm{mex}(A_{i + 1}, A_{i + 2}, A_{i + 3}, \\dots, A_{i + M})$（$1\\le i\\le N-M$）时，将$\\text{cnt}_{A_i}$减少$1$，并且将$\\text{cnt}_{A_{i+M}}$增加$1$，这样就达到了$\\mathcal O(1)$计算$\\text{cnt}$的效果。但是，即使这样还会TLE。所以，我们可以用一个set维护$\\text{cnt}$中所有$0$的位置，这样总时间复杂度就能降至$\\mathcal O(N\\log M)$。\n代码\r这里注意，set中一定要添加$N$！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 1500005 using namespace std; int cnt[maxn], a[maxn]; set\u0026lt;int\u0026gt; s; inline void setmin(int\u0026amp; x, int y) { if(y \u0026lt; x) x = y; } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); for(int i=0; i\u0026lt;m; i++) cnt[a[i]] ++; for(int i=0; i\u0026lt;n; i++) if(cnt[i] == 0) s.insert(i); s.insert(n); int ans = *s.begin(); n -= m; for(int i=0; i\u0026lt;n; i++) { if(cnt[a[i + m]]++ == 0) s.erase(a[i + m]); if(--cnt[a[i]] == 0) s.insert(a[i]); setmin(ans, *s.begin()); } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","date":"2021-03-17T21:25:00+08:00","permalink":"https://goodcoder666.github.io/p/abc194/","title":"AtCoder Beginner Contest 194 A~E 题解"},{"content":"A - Discount\r题目大意\r一件商品原价为$A$元，现价为$B$元，现价优惠了百分之几？\n$1\\le B \u003c A\\le 10^5$\n输入格式\r$A~B$\n输出格式\r输出答案（不加%）。最大允许误差为$10^{-2}$。\n样例\r$A$ $B$ 输出 $100$ $80$ $20.0$ $7$ $6$ $14.285714$ $99999$ $99998$ $0.0010000100001$ 分析\r这里答案可以直接使用$\\frac{A-B}{A}$求得结果。\n代码\r1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;tuple\u0026gt; using namespace std; int main() { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;%.6lf\u0026#34;, (a - b) * 100.0 / a); return 0; } B - Play Snuke\r题目大意\rTakahashi想要买一件商品，它叫Play Snuke。\n有$N$家商店售卖Play Snuke。Takahashi从家到第$i$个商店需要$A_i$分钟，这家商店的卖价是\n$P_i$元且库存$X_i$件Play Snuke。\n现在，Takahashi想要去这$N$家店中的某一家并且买一个Play Snuke。\n但是，每家店的Play Snuke都会在第$0.5,1.5,2.5,\\dots$分钟被买掉一个。\n判断Takahashi到底能不能买到Play Snuke。如果能，请输出他最少要花的钱。\n$1\\le N\\le 10^5$\n$1\\le A_i, P_i, X_i\\le 10^9$\n输入格式\r$N$\n$A_1~P_1~X_1$\n$\\vdots$\n$A_N~P_N~X_N$\n输出格式\r如果Takahashi能买到Play Snuke，输出他最少要花的钱数；否则，输出-1。\n样例\r样例输入1\r1 2 3 4 3 3 9 5 4 8 5 5 7 5 样例输出1\r1 8 Takahashi可以去$2$号商店，需要花$8$元。\n样例输入2\r1 2 3 4 3 5 9 5 6 8 5 7 7 5 样例输出2\r1 -1 无论Takahashi去哪个商店，到达时Play Snuke都卖光了，因此输出-1。\n样例输入3\r1 2 3 4 5 6 7 8 9 10 11 10 158260522 877914575 602436426 24979445 861648772 623690081 433933447 476190629 262703497 211047202 971407775 628894325 731963982 822804784 450968417 430302156 982631932 161735902 880895728 923078537 707723857 189330739 910286918 802329211 404539679 303238506 317063340 492686568 773361868 125660016 样例输出3\r1 861648772 分析\r对于第$i$个商店，如果$X_i \u003e A_i$，则Takahashi到达时商品没有卖光，这时取最大的$P_i$输出即可。如果没有$i$符合条件$X_i \u003e A_i$，则输出-1。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 #define INF 2147483647 using namespace std; int main() { int n, ans = INF; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int a, p, x; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;p, \u0026amp;x); if(x \u0026gt; a \u0026amp;\u0026amp; p \u0026lt; ans) ans = p; } if(ans == INF) puts(\u0026#34;-1\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } C - Unexpressed\r题目大意\r给你一个整数$N$。有多少个在$1$~$N$之间的整数不能表示为$a^b$（$a$和$b$都是不少于$2$的整数）？\n$1\\le N\\le 10^{10}$\n输入格式\r$N$\n输出格式\r输出答案。\n样例\r$N$ 输出 $8$ $6$ $100000$ $99634$ 分析\r其实能表示为$a^b$的整数并不多。我们只要枚举所有的$a$（$2\\le a\\le \\sqrt N$），再把它的不超过$N$的所有整数次方放入一个set中（去重），再用$N-\\text{最终set中的元素个数}$即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; using LL = long long; set\u0026lt;LL\u0026gt; s; int main() { LL n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); LL tmp = sqrt(n); for(LL a=2; a\u0026lt;=tmp; a++) { LL res = a; // res = a ^ b while((res *= a) \u0026lt;= n) s.insert(res); } printf(\u0026#34;%lld\\n\u0026#34;, n - s.size()); return 0; } D - Poker\r题目大意\r略，请自行前往AtCoder查看\n输入格式\r$K$\n$S$\n$T$\n输出格式\r输出一行，即Takahashi的胜率（不要使用百分数，请使用$0$到$1$之间的小数）。最大允许误差$10^{-5}$。\n样例\r$K$ $S$ $T$ 输出 $2$ 1144# 2233# $0.4444444444444$ $2$ 9988# 1122# $1.0$ $6$ 1122# 2228# $0.0019323671498$ $10^5$ 3226# 3597# $0.6296297942426$ 分析\r$$\\begin{cases}\rC_xC_y \u0026 (x \\ne y)\\\\\rC_x(C_x - 1) \u0026 (x = y)\\\\\r\\end{cases}$$\n枚举每一对$(x, y)$，拿最终的结果除以$(9K - 8)(9K - 9)$即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;cstdio\u0026gt; using namespace std; using LL = long long; char s[7], t[7]; int score(const char* cards) { int cnt[10]; for(int i=0; i\u0026lt;10; i++) cnt[i] = i; for(int i=0; i\u0026lt;5; i++) cnt[cards[i] - \u0026#39;0\u0026#39;] *= 10; int res = 0; for(int x: cnt) res += x; return res; } int main() { int k; scanf(\u0026#34;%d%s%s\u0026#34;, \u0026amp;k, s, t); int cnt[10]; for(int i=1; i\u0026lt;10; i++) cnt[i] = k; for(int i=0; i\u0026lt;4; i++) cnt[s[i] - \u0026#39;0\u0026#39;] --, cnt[t[i] - \u0026#39;0\u0026#39;] --; LL win = 0LL; for(int x=1; x\u0026lt;10; x++) if(cnt[x]) { s[4] = \u0026#39;0\u0026#39; + x; int sscore = score(s); for(int y=1; y\u0026lt;10; y++) if(cnt[y]) { t[4] = \u0026#39;0\u0026#39; + y; if(sscore \u0026gt; score(t)) win += cnt[x] * LL(cnt[y] - (x == y)); } } LL tmp = 9LL * k - 8LL; printf(\u0026#34;%.8lf\\n\u0026#34;, double(win) / tmp / double(tmp - 1LL)); return 0; } ","date":"2021-03-08T21:24:00+08:00","permalink":"https://goodcoder666.github.io/p/abc193/","title":"Caddi Programming Contest 2021 (AtCoder Beginner Contest 193) A~D 题解"},{"content":"A - Star\r题目大意\r下一个大于$X$的$100$的倍数与$X$的差是多少？\n$1\\le X\\le 10^5$\n输入格式\r$X$\n输出格式\r输出答案。\n样例\r$X$ 输出 $140$ $60$ $1000$ $100$ 分析\r下一个大于$X$的$100$的倍数是$(\\lfloor X/100\\rfloor+1)\\times 100$。所以，这题我们直接输出$(\\lfloor X/100\\rfloor+1)\\times 100-X$。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); printf(\u0026#34;%d\\n\u0026#34;, (x / 100 + 1) * 100 - x); return 0; } B - uNrEaDaBlE sTrInG\r题目大意\r当一个字符串的奇数位置上（第$1$位、第$3$位、第$5$位……，下标从$1$开始）都是小写英文字母且偶数位置上（第$2$位、第$4$位、第$6$位……）都是大写英文字母时，它是一个难以阅读的字符串。\n字符串$S$难以阅读吗？\n$1\\le |S|\\le 1000$\n$S$由大写字母和小写字母组成。\n输入格式\r$S$\n输出格式\r如果$S$难以阅读，输出Yes；否则，输出No。\n样例\r$S$ 输出 $\\text{dIfFiCuLt}$ Yes $\\text{eASY}$ No $\\text{a}$ Yes 分析\r这题只要照题目说的做即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char c; int n = 0; while((c = getchar()) != \u0026#39;\\n\u0026#39;) { if(n++ % 2 == 0) { if(c \u0026lt; \u0026#39;a\u0026#39; || c \u0026gt; \u0026#39;z\u0026#39;) { puts(\u0026#34;No\u0026#34;); return 0; } continue; } if(c \u0026lt; \u0026#39;A\u0026#39; || c \u0026gt; \u0026#39;Z\u0026#39;) { puts(\u0026#34;No\u0026#34;); return 0; } } puts(\u0026#34;Yes\u0026#34;); return 0; } C - Kaprekar Number\r题目大意\r对于一个自然数$x$，我们对$g1(x),g2(x),f(x)$的定义如下：\n$g1(x)=x$按十进制位降序排序的结果 $g2(x)=x$按十进制位升序排序的结果 $f(x)=g1(x)-g2(x)$ 举几个例子：$g1(314)=431,g2(3021)=123,f(271)=721-127=594$。请注意，前导$0$会被忽略！\n给你两个数$N,K$，请进行$K$次$N:=f(N)$这个操作，并输出最终的$N$。\n$0\\le N\\le 10^9$\n$1\\le K\\le 10^5$\n输入格式\r$N~K$\n输出格式\r输出一行，即最终的$N$。\n样例\r$N$ $K$ 输出 $314$ $2$ $693$ $1000000000$ $100$ $0$ $6174$ $100000$ $6174$ 分析\r这题在计算$f(n)$时可以使用一个桶来排序$n$，从而得到$\\mathcal O(K)$的总复杂度。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int cnt[10]; int f(int x) { for(int i=0; i\u0026lt;10; i++) cnt[i] = 0; while(x \u0026gt; 0) { cnt[x % 10] ++; x /= 10; } int g1 = 0, g2 = 0, t = 1; for(int i=0; i\u0026lt;10; i++) while(cnt[i]--) { g1 += i * t, g2 = g2 * 10 + i; t *= 10; } return g1 - g2; } int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); while(k--) n = f(n); printf(\u0026#34;%d\\n\u0026#34;, n); return 0; } D - Base n\r题目大意\r给你一个大整数$X$（别想得太美，long long存不下）和整数$M$。我们设$d$为$X$中最大的位上的十进制数。\n有多少个符合“将$X$看成（不是转换成）$n$进制的数的十进制表示不超过$M$”这个条件的$n$？\n$X$是一个没有前导$0$的正整数。\n$X$在十进制表示下至少有$1$位、至多有$60$位。\n$1\\le M\\le 10^{18}$\n输入格式\r$X$\n$M$\n输出格式\r输出一行，即符合条件的$n$的个数。\n样例\r略，请自行前往AtCoder查看\n分析\r很明显，这题$n$的范围是$d \u003c n\\le M$。我们可以用二分找到最大可能的$N$，再用这个数减去$d$即可。\n代码\r写这份代码，需要注意如下三个点：\n二分的边界 二分的判断 大整数的处理 废话不多说，我们直接上代码！$\\downarrow~~~~~~\\downarrow~~~~~~\\downarrow$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; using namespace std; typedef unsigned long long ULL; char x[65]; ULL m; inline void setmax(int\u0026amp; x, int y) { if(y \u0026gt; x) x = y; } inline bool check(const ULL\u0026amp; base) { // Returns: (x -\u0026gt; base) \u0026lt;= m? ULL t = 0ULL; for(int i=0; x[i]; i++) { if(t \u0026gt; m / base) return false; t *= base; if((t += x[i] - \u0026#39;0\u0026#39;) \u0026gt; m) return false; } return true; } int main() { scanf(\u0026#34;%s%llu\u0026#34;, x, \u0026amp;m); int d = 0; for(int i=0; x[i]; i++) setmax(d, x[i] - \u0026#39;0\u0026#39;); if(x[1] == \u0026#39;\\0\u0026#39;) { puts(d \u0026gt; m? \u0026#34;0\u0026#34;: \u0026#34;1\u0026#34;); return 0; } ULL l = d, r = m; while(l \u0026lt; r) { ULL mid = l + r + 1ULL \u0026gt;\u0026gt; 1ULL; if(check(mid)) l = mid; else r = mid - 1ULL; } printf(\u0026#34;%llu\\n\u0026#34;, l - d); return 0; } ","date":"2021-02-28T21:33:00+08:00","permalink":"https://goodcoder666.github.io/p/abc192/","title":"AtCoder Beginner Contest 192 A~D 题解"},{"content":"A - Vanishing Pitch\r题目大意\r一个球的速度是$V~\\text{m/s}$，它飞了$T$秒后会隐形，飞了$S$秒时会接触隐形。\n球在飞了$D$米后，人能看见它吗？输出Yes或者No。\n$1\\le V\\le 1000$\n$1\\le T \u003c S\\le 1000$\n$1\\le D\\le 1000$\n输入格式\r$V~T~S~D$\n输出格式\r输出答案。\n样例\r$V$ $T$ $S$ $D$ 输出 $10$ $3$ $5$ $20$ Yes $10$ $3$ $5$ $30$ No 分析\r如果$VT\\le D\\le VS$，则球飞了$D$米后是隐形的，人看不见，输出No；否则，输出Yes。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int v, t, s, d; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;v, \u0026amp;t, \u0026amp;s, \u0026amp;d); puts((v * t \u0026lt;= d \u0026amp;\u0026amp; d \u0026lt;= v * s)? \u0026#34;No\u0026#34;: \u0026#34;Yes\u0026#34;); return 0; } B - Remove It\r题目大意\r给你一个长度为$N$的整数序列$A$，请你将其中所有的$X$都删除并不改变顺序输出。\n$1\\le N\\le 10^5$\n$1\\le X\\le 10^9$\n$1\\le A_i\\le 10^9$\n输入格式\r$N~X$\n$A_1~A_2~\\dots~A_N$\n输出格式\r输出最终序列，两个相邻的元素之间有一个空格。\n样例\r样例输入1\r1 2 5 5 3 5 6 5 4 样例输出1\r1 3 6 4 我们从序列$[3,5,6,5,4]$中删除所有的$5$，得到$[3,6,4]$。\n样例输入2\r1 2 3 3 3 3 3 样例输出2\r当所有元素都被删除时，我们输出一个空行即可。\n分析\r这道题不需要真正删除所有的$X$，只需输出时不输出等于$X$的元素。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n, x; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;x); while(n--) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); if(a != x) printf(\u0026#34;%d \u0026#34;, a); } putchar(\u0026#39;\\n\u0026#39;); return 0; } C - Digital Graffiti\r题目大意\r我们有一张$H\\times W$的方格纸，在$(i,j)$位置上的点是$S_{i,j}$。\n每一个方格都是黑色（#）或白色（.），题目保证最外圈的点都是白色的。\n黑色方格放在一起是一个多边形。求这个多边形的边数。\n$3\\le H,W\\le 10$\n输入格式\r$H~W$\n$S_{1,1}S_{1,2}\\dots S_{1,W}$\n$S_{2,1}S_{2,2}\\dots S_{2,W}$\n$\\vdots$\n$S_{H,1}S_{H,2}\\dots S_{H,W}$\n输出格式\r输出答案。\n样例\r样例输入\r1 2 3 4 5 6 5 5 ..... .###. .###. .###. ..... 样例输出\r1 4 这是一个四边形。\n自制数据\r由于样例太简单，无法全面测试我们的程序。因此，博主再提供一组数据：\n输入\r1 2 3 4 5 6 5 5 ..... ..#.. .###. .#.#. ..... 输出\r1 12 分析\r很多人看到这种图就会想到$\\text{DFS}$、$\\text{BFS}$……其实这道题根本不需要。\n这道题的做法来源于一个很简单的定理：多边形的顶点数=边数。\n再进一步分析，一个点，在这个图上，怎样判断其是否为顶点？\n其实，只要一个点周围四个方格中有一个或三个白方格，那么它就是一个顶点。\n我们只要用一个$2\\times 2$的正方形搜索即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; #define maxn 15 using namespace std; char c[maxn][maxn]; int main() { int h, w, ans = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;h, \u0026amp;w); for(int i=0; i\u0026lt;h; i++) scanf(\u0026#34;%s\u0026#34;, c[i]); for(int i=0; i\u0026lt;h-1; i++) for(int j=0; j\u0026lt;w-1; j++) { int cnt = 0; cnt += c[i][j] == \u0026#39;.\u0026#39;; cnt += c[i][j + 1] == \u0026#39;.\u0026#39;; cnt += c[i + 1][j] == \u0026#39;.\u0026#39;; cnt += c[i + 1][j + 1] == \u0026#39;.\u0026#39;; if(cnt == 1 || cnt == 3) ans ++; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Circle Lattice Points\r题目大意\r有一个中心为$(X,Y)$、半径为$R$的圆。\n这个圆内（圆上的也算）有多少个栅格点（$X,Y$坐标均为整数的点）？\n$|X| \\le 10^5$\n$|Y|\\le 10^5$\n$0\\le R\\le 10^5$\n$X,Y,R$至多是四位小数。\n输入格式\r$X~Y~R$\n输出格式\r输出一行，即园内栅格点的个数。\n样例\r样例输入1\r1 0.2 0.8 1.1 样例输出1\r1 3 这个圆如下图所示。标了红色的是栅格点。\n样例输入2\r1 100 100 1 样例输出2\r1 5 $X,Y$和$R$也有可能是整数。\n注意：正好在圆上的栅格点也计入总数内！\n样例输入3\r1 42782.4720 31949.0192 99999.99 样例输出3\r1 31415920098 分析\r$$(i-X)^2+(j-Y)^2=R^2$$$$(j-Y)^2=R^2-(i-X)^2$$$$j-Y=\\sqrt{R^2-(i-X)^2}$$$$j=\\sqrt{R^2-(i-X)^2}+Y$$$$j=\\lfloor \\sqrt {R^2-(i-X)^2}+Y\\rfloor$$\n对于任意一个$X$坐标，它的$Y_\\text{up}$和$Y_\\text{down}$是以圆心$Y$作为对称轴对称的，所以我们可以使用$2Y-Y_\\text{up}$求得$Y_\\text{down}$。\n可惜的是，$\\sqrt{R^2-(i-X)^2}$的计算结果可能有浮点数精度误差，我们的程序需要完全避开任何浮点数操作，所以这样做行不通。\n其实，这道题可以二分。我们利用二分找到$X$坐标对应的最上面的点，再求出最下面的点和对应的栅格点即可。\n代码\r前面都是干货，下面上代码~\n注意：long long不能忘！一定要判断各种负数的情况！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include \u0026lt;cstdio\u0026gt; #define DIV 10000LL using namespace std; typedef long long LL; LL x, y, R; inline LL read() { // Returns: input * 10000. LL res = 0LL; int num = 0; bool flag = false, negative = false; for(char c=getchar(); c != \u0026#39; \u0026#39; \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;; c=getchar()) { if(c == \u0026#39;-\u0026#39;) negative = true; else if(c == \u0026#39;.\u0026#39;) flag = true; else { res *= 10LL; res += c - \u0026#39;0\u0026#39;; if(flag) num ++; } } for(int i=num; i\u0026lt;4; i++) res *= 10LL; return negative? -res: res; } inline LL in_circle(const LL\u0026amp; dx, const LL\u0026amp; dy) { return dx * dx + dy * dy \u0026lt;= R * R; } inline LL findtop(LL i) { i *= DIV; LL l = y, r = y + R; while(l \u0026lt; r) { LL mid = l + r + 1LL \u0026gt;\u0026gt; 1LL; if(in_circle(i - x, mid - y)) l = mid; else r = mid - 1LL; } return l; } inline LL ceildiv(const LL\u0026amp; a) { // Returns: ceil(a / DIV). if(a \u0026lt; 0LL) return a / DIV; if(a % DIV == 0LL) return a / DIV; return a / DIV + 1LL; } inline LL floordiv(const LL\u0026amp; a) { // Returns: floor(a / DIV). if(a \u0026gt;= 0LL) return a / DIV; if(a % DIV == 0LL) return a / DIV; return a / DIV - 1LL; } int main() { x = read(), y = read(), R = read(); LL ans = 0LL, left = ceildiv(x - R), right = floordiv(x + R); for(LL i=left; i\u0026lt;=right; i++) { LL top = findtop(i); LL bottom = (y \u0026lt;\u0026lt; 1LL) - top; ans += floordiv(top) - ceildiv(bottom) + 1LL; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2021-02-09T19:03:00+08:00","permalink":"https://goodcoder666.github.io/p/abc191/","title":"AtCoder Beginner Contest 191 A~D 题解"},{"content":"A - Very Very Primitive Game\r题目大意\rTakahashi和Aoki在玩一个游戏。\n游戏规则是这样的：\n最开始，Takahashi和Aoki分别有$A$和$B$颗糖。 他们将轮流吃一颗糖，第一个无法吃糖的人算输。如果$C=0$，那么Takahashi先吃；如果$C=1$，那么Aoki先吃。 请输出最终胜者的名字。\n$0\\le A,B\\le 100$\n$C \\in \\{0,1\\}$\n输入格式\r$A~B~C$\n输出格式\r输出答案。\n样例\rA B C 输出 2 1 0 Takahashi 2 2 0 Aoki 2 2 1 Takahashi 分析\r可以看出，如果是Aoki先吃（$C=1$），那么当$B \u003e A$时，Aoki会赢。那么如果Takahashi先吃（$C=1$），我们可以先将$B$加上$1$，这时就变成了前一种情况，再判断$B \u003e A$是否成立即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); if(c == 0) b ++; puts(b \u0026gt; a? \u0026#34;Aoki\u0026#34;: \u0026#34;Takahashi\u0026#34;); return 0; } B - Magic 3\r题目大意\r一位魔术师要与怪兽战斗。\n他可以使用$N$种咒语。\n第$i$个咒语的冷却时间是$X_i$秒、伤害是$Y_i$。\n但是，这个怪兽可以免疫冷却时间不少于$S$或伤害不超过$D$的任何咒语的伤害。\n这位魔术师能伤害到怪兽吗？\n$1\\le N\\le 100$\n$1\\le X_i, Y_i\\le 10^9$\n$1\\le S, D\\le 10^9$\n输入格式\r$N~S~D$\n$X_1~Y_1$\n$X_2~Y_2$\n$\\vdots$\n$X_N~Y_N$\n输出格式\r如果魔术师能伤害到怪物，输出Yes；否则，输出No。\n样例\r样例输入1\r1 2 3 4 5 4 9 9 5 5 15 5 5 15 15 15 样例输出1\r1 Yes $S=D=9$，则：\n咒语编号 冷却时间 伤害 能否伤害到怪物 $1$ $5$秒$~~~\\checkmark$ $5~~~\\bm\\times$ $\\bm\\times$ $2$ $15$秒$~~~\\bm\\times$ $5~~~\\bm\\times$ $\\bm\\times$ $3$ $5$秒$~~~\\checkmark$ $15~~~\\checkmark$ $\\checkmark$ $4$ $15$秒$~~~\\bm\\times$ $15~~~\\checkmark$ $\\bm\\times$ 样例输入2\r1 2 3 4 3 691 273 691 997 593 273 691 273 样例输出2\r1 No 样例输入3\r1 2 3 4 5 6 7 8 7 100 100 10 11 12 67 192 79 154 197 142 158 20 25 17 108 样例输出3\r1 Yes 只有第七个咒语能伤害怪兽。\n分析\r这题可以遍历每一个 $i$，并判断如果 $X_i \u003c S$ 和 $Y_i \u003e D$ 同时成立，输出Yes；当所有$i$都不符合条件时，输出No。\n代码\r我写的这个代码是在输入时处理的，当然也可以输入之后再处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n, s, d; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;s, \u0026amp;d); while(n--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); if(x \u0026lt; s \u0026amp;\u0026amp; y \u0026gt; d) { puts(\u0026#34;Yes\u0026#34;); return 0; } } puts(\u0026#34;No\u0026#34;); return 0; } C - Bowls and Dishes\r题目大意\r有$N$个编号为$1,2,\\dots,N$的盘子和$M$个编号为$1,2,\\dots,M$的条件。\n当编号为$A_i$和$B_i$的盘子中都有（至少一个）球时，第$i$个条件就被满足了。\n有$K$个编号为$1,2,\\dots,K$的人。第$i$个人会将一个球放入编号为$C_i$或$D_i$的盘子中。\n最多能有多少个条件被满足？\n$2\\le N\\le 100$\n$1\\le M\\le 100$\n$1\\le A_i \u003c B_i\\le N$\n$1\\le K\\le 16$\n$1\\le C_i \u003c D_i\\le N$\n输入格式\r$N~M$\n$A_1~B_1$\n$\\vdots$\n$A_M~B_M$\n$K$\n$C_1~D_1$\n$\\vdots$\n$C_K~D_K$\n输出格式\r输出答案。\n样例\r样例输入1\r1 2 3 4 5 6 7 8 9 4 4 1 2 1 3 2 4 3 4 3 1 2 1 3 2 3 样例输出1\r1 2 如果编号为$1,2,3$的人将他们的球分别放入编号为$1,3,2$的盘子中，则条件$1$和$2$将被满足。\n样例输入2\r1 2 3 4 5 6 7 8 9 10 4 4 1 2 1 3 2 4 3 4 4 3 4 1 2 2 4 2 4 样例输出2\r1 4 如果编号为$1,2,3,4$的人将他们的球分别放入编号为$3,1,2,4$的盘子中，则所有条件将被满足。\n样例输入3\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 6 12 2 3 4 6 1 2 4 5 2 6 1 5 4 5 1 3 1 2 2 6 2 3 2 5 5 3 5 1 4 2 6 4 6 5 6 样例输出3\r1 9 分析\r这个题数据范围很小，所以我们考虑枚举。\n我们可以按人枚举，枚举第$i$个人是将自己的球放入编号为$C_i$还是$D_i$的盘子。\n每个人有选$C_i$和$D_i$两种情况，所以枚举次数为$2^K$，而题目保证$1\\le K\\le16$，所以不会超时。\n我们可以使用二进制法来枚举：\n有$K$个二进制位。 第$i$个二进制位如果是$1$，则第$i$个人将球放入编号为$C_i$的盘子；否则，他会把球放入编号为$D_i$的盘子。 总时间复杂度为$\\mathcal O(M2^K)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int a[105], b[105], c[20], d[20]; int main() { int n, m, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;m; i++) { scanf(\u0026#34;%d%d\u0026#34;, a + i, b + i); a[i] --, b[i] --; } scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); for(int i=0; i\u0026lt;k; i++) { scanf(\u0026#34;%d%d\u0026#34;, c + i, d + i); c[i] --, d[i] --; } int limit = 1 \u0026lt;\u0026lt; k, ans = 0; for(int st=0; st\u0026lt;limit; st++) { bool hasdish[105] = {false}; for(int i=0; i\u0026lt;k; i++) if(st \u0026amp; (1 \u0026lt;\u0026lt; i)) hasdish[c[i]] = true; else hasdish[d[i]] = true; int cnt = 0; for(int i=0; i\u0026lt;m; i++) cnt += hasdish[a[i]] \u0026amp;\u0026amp; hasdish[b[i]]; if(cnt \u0026gt; ans) ans = cnt; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Staircase Sequences\r题目大意\r有多少个和为$N$、公差为$1$的等差数列？\n$1\\le N\\le 10^{12}$\n输入格式\r$N$\n输出格式\r输出答案。\n样例\rN 输出 $12$ $4$ $1$ $2$ $63761198400$ $1920$ 分析\r$$\\frac {(a+b)(b-a+1)} 2=N$$$${(a+b)(b-a+1)}=2N$$\n所以，我们求$2N$的奇偶性不同的因子对数即可。这里注意，题目里的等差数列是可以有负数的，所以最终结果一定要乘$2$！\n代码总时间复杂度为$\\mathcal O(\\sqrt n)$。\n代码\r请注意一定要使用long long。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;cstdio\u0026gt; using namespace std; typedef long long LL; int main() { LL n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); n \u0026lt;\u0026lt;= 1LL; int cnt = 0; for(LL i=1; i*i\u0026lt;=n; i++) if(n % i == 0 \u0026amp;\u0026amp; i % 2 != n / i % 2) cnt ++; printf(\u0026#34;%d\\n\u0026#34;, cnt \u0026lt;\u0026lt; 1); return 0; } ","date":"2021-02-01T18:44:00+08:00","permalink":"https://goodcoder666.github.io/p/abc190/","title":"AtCoder Beginner Contest 190 A~D 题解"},{"content":"A - Slots\r题目大意\r给定三个大写英文字母$C_1,C_2,C_3$，判断它们是否相同。\n输入格式\r$C_1C_2C_3$\n输出格式\r如果$C_1,C_2,C_3$相等，输出Won；否则，输出Lost。\n样例\r输入 输出 SSS Won WVW Lost 分析\r这题如果不会做，就等于没学过C++吧……\n代码\r注意：请不要将Won和Lost写成Yes和No！\n1 2 3 4 5 6 7 8 9 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { char a = getchar(), b = getchar(), c = getchar(); puts((a == b \u0026amp;\u0026amp; b == c)? \u0026#34;Won\u0026#34;: \u0026#34;Lost\u0026#34;); return 0; } B - Alcoholic\r题目大意\r一个人要按顺序喝$N$杯酒。第$i$杯酒有$V_i$毫升，酒精含量为$P_i\\%$（$1\\le i\\le N$）。\n他喝的酒精总含量超过$X$毫升时将会醉酒。（如果正好喝了$X$毫升也不会喝醉）\n他喝完第几杯酒后会第一次喝醉？\n$1\\le N\\le 10^3$\n$0\\le X\\le 10^6$\n$1\\le V_i\\le 10^3$\n$0\\le P_i\\le 100$\n输入格式\r$N~X$\n$V_1~P_1$\n$\\vdots$\n$V_N~P_N$\n输出格式\r如果这个人在喝完第$i$杯酒后第一次喝醉，输出$i$。如果他直到最后都没有喝醉，输出-1。\n样例\r样例输入1\r1 2 3 2 15 200 5 350 3 样例输出1\r1 2 第$1$杯酒含有$200\\times5\\%=10$毫升的酒精。\n第$2$杯酒含有$350\\times3\\%=10.5$毫升的酒精。\n他喝完第二杯酒后一共喝了$20.5$毫升的酒精，高于最大可承受量（$15$），所以我们输出$2$。\n样例输入2\r1 2 3 2 10 200 5 350 3 样例输出2\r1 2 当他正好喝了$X$毫升的酒精时，他还没有喝醉。\n样例输入3\r1 2 3 4 3 1000000 1000 100 1000 100 1000 100 样例输出3\r1 -1 他似乎免疫酒精了……\n分析\r第$i$杯酒中酒精的量是$V_i\\times P_i\\%$，即$V_i\\times P_i/100$。\n这时，我们将题目转化一下，就是求符合$V_1\\times P_1/100+V_2\\times P_2/100+...+V_i\\times P_i/100 \u003e X$的最小$i$。所以，我们很容易想到在输入的同时计算$V_1\\times P_1/100+V_2\\times P_2/100+...+V_i\\times P_i/100$，当它大于$X$时输出$i$。\n但是，这里有一个问题。\n由于C++存在浮点数精度误差，所以这样算可能会得到错误的结果。\n例如，下面一组数据：（数据来自AtCoder官方题解）\n1 2 3 4 3 13 30 13 35 13 35 13 $$V_1\\times P_1/100+V_2\\times P_2/100+...+V_i\\times P_i/100 \u003e X$$$$(V_1\\times P_1+V_2\\times P_2+...+V_i\\times P_i)/100 \u003e X$$$$V_1\\times P_1+V_2\\times P_2+...+V_i\\times P_i \u003e 100X$$\n这时，我们就可以用前面的思路写代码了。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { int n, x; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;x); x *= 100; for(int i=1; i\u0026lt;=n; i++) { int v, p; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;v, \u0026amp;p); x -= v * p; if(x \u0026lt; 0) { printf(\u0026#34;%d\\n\u0026#34;, i); return 0; } } puts(\u0026#34;-1\u0026#34;); return 0; } C - Mandarin Orange\r题目大意\rTakahashi面前有$N$个碗排成一行，从左数第$i$个碗中装有$A_i$个橙子。\n他会选出以个符合下列所有条件的三元组$(l,r,x)$：\n$1\\le l\\le r\\le N$ $1\\le x\\le A_i$（$l\\le i\\le r$） 然后，他在第$l$个到第$r$个盘子（包含$l$和$r$）中每个吃掉$x$个橙子。\n通过选择三元组$(l,r,x)$以最大化此数目，Takahashi最多可以吃多少个橙子？\n$1\\le N\\le 10^4$\n$1\\le A_i\\le 10^5$\n输入格式\r$N$\n$A_1~\\dots~A_N$\n输出格式\r输出一行，即Takahashi最多可以吃的橙子的个数。\n样例\r样例输入1\r1 2 6 2 4 4 9 4 9 样例输出1\r1 20 他可以选择$(l,r,x)=(2,6,4)$，能吃$20$个橙子。\n样例输入2\r1 2 6 200 4 4 9 4 9 样例输出2\r1 200 他可以选择$(l,r,x)=(1,1,200)$，能吃$200$个橙子。\n分析\r很明显，如果我们选择$(l,r,x)$，则Takahashi能吃$(l-r+1)x$个橙子。\n我们要让吃的橙子个数最大化，那么选择$(l,r)$后，$x$必定为$\\min\\{A_l,A_{l+1},...,A_r\\}$。这样一来，我们就可以枚举$(l,r)$，并记录$\\min\\{A_l,A_{l+1},...,A_r\\}$作为$x$，最终输出最小的$(l-r+1)x$。\n这个算法的时间复杂度为$\\mathcal O(n^2)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #define maxn 10005 #define INF 2147483647 using namespace std; int a[maxn]; inline void setmin(int\u0026amp; a, int b) {if(b \u0026lt; a) a = b;} inline void setmax(int\u0026amp; a, int b) {if(b \u0026gt; a) a = b;} int main(int argc, char** argv) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); int ans = 0; for(int l=0; l\u0026lt;n; l++) { int m = INF; for(int r=l; r\u0026lt;n; r++) { setmin(m, a[r]); setmax(ans, (r - l + 1) * m); } } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Logical Expression\r题目大意\r给你$N$个字符串$S_1,S_2,...,S_N$，每个是AND或者OR。\n找到符合下列条件的长度为$(N+1)$的元组$(x_0,x_1,...,x_N)$的数量：\n$x_i$是$\\text{True}$或者$\\text{False}$； $y_0=x_0$； 当$i\\ge 1$时：如果$S_i$为AND，$y_i=y_{i-1}\\land x_i$；如果$S_i$为OR，则$y_i=y_{i-1}\\lor x_i$。 在这里，$a\\land b$表示$a$与$b$，$a\\lor b$表示$a$或$b$。\n$1\\le N\\le 60$\n输入格式\r$N$\n$S_1$\n$\\vdots$\n$S_N$\n输出格式\r输出答案。\n样例\r略，请自行前往AtCoder查看\n分析\r其实，题目解释得有些复杂了 :(\n理解时例如样例$1$：\n我们将$f(N)$定义为本题$S=\\{S_1,S_2,\\dots,S_N\\}$的答案，则\n$f(N)=\\begin{cases} f(N-1) \u0026 (S_N=\\text{AND})\\\\\rf(N-1)\\times2^N \u0026 (S_N=\\text{OR})\r\\end{cases}$\n这时，我们就可以在输入时处理答案了。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); char c[4]; long long ans = 1LL, x = 1LL; while(n--) { x \u0026lt;\u0026lt;= 1LL; scanf(\u0026#34;%s\u0026#34;, c); if(c[0] == \u0026#39;O\u0026#39;) ans ^= x; // 等同于ans += x;这样写速度更快 } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2021-01-25T15:47:00+08:00","permalink":"https://goodcoder666.github.io/p/abc189/","title":"AtCoder Beginner Contest 189 A~D 题解"},{"content":"A - Don\u0026rsquo;t be late\r题目大意\rTakahashi要和Aoki见面。\n他们计划在距离Takahashi家$D$米的地方$T$分钟后见面。\nTakahashi将立即出门并以$S$米/分钟的速度朝见面地点走去。\nTakahashi能按时到达吗？\n$1\\le D\\le 10000$\n$1\\le T\\le 10000$\n$1\\le S\\le 10000$\n输入格式\r$D~T~S$\n输出格式\r如果Takahashi提前或准时到达此地，输出Yes；否则输出No。\n样例\rD T S 输出 1000 15 80 Yes 2000 20 100 Yes 10000 1 1 No 分析\r判断$\\frac D S\\le T$（简化后为 $TS\\ge D$）即可。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { int d, t, s; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;d, \u0026amp;t, \u0026amp;s); puts(t * s \u0026gt;= d? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Substring\r题目大意\r给你两个字符串$S$和$T$。\n请你修改$S$中的一些字符（可以不修改）使得$T$是$S$的字串。\n至少需要修改多少个字符？\n子串：如，xxx是yxxxy的子串，但不是xxyxx的子串。\n$1\\le |T|\\le |S|\\le 1000$\n$S$和$T$都由小写英文字母组成。\n输入格式\r$S~T$\n输出格式\r一行，即至少需要修改的字符个数。\n样例\r样例输入1\r1 2 cabacc abc 样例输出1\r1 1 样例输入2\r1 2 codeforces atcoder 样例输出2\r1 6 分析\r我们只要将$T$在$S$中滚动匹配，寻找不同的字母数量的最小值即可。\n代码\r其实这就是枚举 :)\n注意：如果按下面的代码写，最开始一定要特判$S$和$T$长度相等的情况！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;cstdio\u0026gt; #define maxn 1005 using namespace std; char s[maxn], t[maxn]; int main(int argc, char** argv) { scanf(\u0026#34;%s%s\u0026#34;, s, t); int tlen = 0, ans = maxn; for(; t[tlen]; tlen++); if(s[tlen] == \u0026#39;\\0\u0026#39;) { ans = 0; for(int i=0; i\u0026lt;tlen; i++) if(s[i] != t[i]) ans ++; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } for(int i=0; s[i+tlen]; i++) { int cnt = 0; for(int j=0; j\u0026lt;tlen; j++) if(s[i + j] != t[j]) cnt ++; if(cnt \u0026lt; ans) ans = cnt; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } C - Sum of product of pairs\r题目大意\r给定$N$个整数$A_1,A_2,\\dots,A_N$。\n输出${\\sum\\limits_{i=1}^{N-1}\\sum\\limits_{j=i+1}^NA_iA_j} \\mod {(10^9+7)}$，即符合$1\\le i \\lt j\\le N$的所有$(i,j)$的$A_iA_j$的和，对$(10^9 + 7)$取模。\n输入格式\r$N$\n$A_1~A_2~\\dots~A_N$\n输出格式\r输出一行，即${\\sum\\limits_{i=1}^{N-1}\\sum\\limits_{j=i+1}^NA_iA_j} \\mod {(10^9+7)}$。\n样例\r样例输入1\r1 2 3 1 2 3 样例输出1\r1 11 $1\\times2+1\\times3+2\\times3=11$。\n样例输入2\r1 2 4 141421356 17320508 22360679 244949 样例输出2\r1 437235829 不要忘记对$(10^9 + 7)$取模！\n分析\r$${\\sum\\limits_{i=1}^{N-1}\\sum\\limits_{j=i+1}^NA_iA_j} \\mod {(10^9+7)}$$$${(\\sum\\limits_{i=2}^{N}\\sum\\limits_{j=0}^{i-1}A_iA_j)} \\mod {(10^9+7)}$$$${\\sum\\limits_{i=2}^{N}A_i(\\sum\\limits_{j=0}^{i-1}A_j)} \\mod {(10^9+7)}$$\n这时，我们只需循环遍历$i$，再设置一个变量记录$\\sum\\limits_{j=0}^{i-1}A_j$即可。\n代码\r可以输入时直接处理。\n虽然要取模，但是还要使用long long：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 #define MOD 1000000007LL using namespace std; typedef long long LL; int main(int argc, char** argv) { int n; LL sum, res = 0LL; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;sum); while(--n) // 循环 (n-1) 次 { LL x; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); res += sum * x; sum += x; res %= MOD, sum %= MOD; } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } D - Friends\r题目大意\r有$N$个人，编号分别为$1$到$N$。\n给你$M$个关系，第$i$个关系为“$A_i$号人和$B_i$号人是朋友。”（关系可能会重复给出）。\n如果$X$和$Y$是朋友、$Y$和$Z$是朋友，则$X$和$Z$也是朋友。\nTakahashi大坏蛋想把这$N$个人进行分组，使得每组中的人互不为朋友。他至少要分多少组？\n$2\\le N\\le 2\\times10^5$\n$0\\le M\\le 2\\times10^5$\n$1\\le A_i,B_i\\le N$\n$A_i \\ne B_i$\n输入格式\r$N~M$\n$A_1~B_1$\n$A_2~B_2$\n$\\vdots$\n$A_M~B_M$\n输出格式\r输出答案。\n样例\r样例输入1\r1 2 3 4 5 3 1 2 3 4 5 1 样例输出1\r1 3 分为三组：$\\{1,3\\}$、$\\{2,4\\}$、$\\{5\\}$可以达到目标。\n样例输入2\r1 2 3 4 5 6 7 8 9 10 11 4 10 1 2 2 1 1 2 2 1 1 2 1 3 1 4 2 3 2 4 3 4 样例输出2\r1 4 请注意重复的关系。\n样例输入3\r1 2 3 4 5 10 4 3 1 4 1 5 9 2 6 样例输出3\r1 3 分析\r这道题可以先分出一个个朋友圈，再从朋友圈的人数中取最大值并输出即可。\n代码\r“分出朋友圈”这个操作可以使用dfs/bfs（不需要去重），当然，并查集也是可以的（需要去重）。我选择的是bfs。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 200005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; bool vis[maxn]; int bfs(int x) { queue\u0026lt;int\u0026gt; q; q.push(x); int cnt = 0; while(!q.empty()) { x = q.front(); q.pop(); if(vis[x]) continue; vis[x] = true, cnt ++; for(int v: G[x]) q.push(v); } return cnt; } int main(int argc, char** argv) { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;m; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G[x].push_back(y); G[y].push_back(x); } int ans = bfs(0); for(int i=1; i\u0026lt;n; i++) if(!vis[i]) { int cnt = bfs(i); if(cnt \u0026gt; ans) ans = cnt; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","date":"2021-01-13T21:16:00+08:00","permalink":"https://goodcoder666.github.io/p/abc177/","title":"AtCoder Beginner Contest 177 A~D 题解"},{"content":"A - Three-Point Shot\r题目大意\r有两个球队，分别得到$X$分和$Y$分，问得分较少的球队能否在获得三分后超越对方。\n$0\\le X,Y\\le 100$\n$X \\ne Y$\n$X$和$Y$都是整数。\n输入格式\r$X~Y$\n输出格式\r如果能，输出Yes；否则，输出No。\n样例\rX Y 输出 3 5 Yes 分析\r这个不用说了吧，就是求两个数的差是否小于$3$……\n代码\r1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(int argc, char** argv) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); puts((abs(a - b) \u0026lt; 3)? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Orthogonality\r题目大意\r给定两个长度为$N$的数组$A=\\{A_1,A_2,A_3,...,A_N\\}$和$B=\\{B_1,B_2,B_3,...,B_N\\}$。请判定$A$和$B$的内项积是否为$0$。换句话说，判断$\\sum\\limits_{i=1}^NA_iB_i$是否为$0$。\n$1\\le N\\le 10^5$\n$-100\\le A_i,B_i\\le 100$ 注意：可能会出现负数！\n输入格式\r$N$\n$A_1~A_2~A_3~\\dots~A_N$\n$B_1~B_2~B_3~\\dots~B_N$\n输出格式\r如果$A$和$B$的内项积为$0$，输出Yes；否则，输出No。\n样例\r样例输入1\r1 2 3 2 -3 6 4 2 样例输出1\r1 Yes $N = 2$\n$A = \\{-3,6\\}$\n$B = \\{4,2\\}$\n$A$和$B$的内项积为：$\\sum\\limits_{i=1}^NA_iB_i = (-3)\\times4+6\\times2=0$，所以输出Yes。\n样例输入2\r1 2 3 2 4 5 -1 -3 样例输出2\r1 No $N = 2$\n$A = \\{4,5\\}$\n$B = \\{-1,-3\\}$\n$A$和$B$的内项积为：$\\sum\\limits_{i=1}^NA_iB_i = 4\\times(-1)+5\\times(-3)=19$，所以输出No。\n样例输入3\r1 2 3 3 1 3 5 3 -6 3 样例输出3\r1 Yes $N = 3$\n$A = \\{1,3,5\\}$\n$B = \\{3,-6,3\\}$\n$A$和$B$的内项积为：$\\sum\\limits_{i=1}^NA_iB_i = 1\\times3+3\\times(-6)+5\\times3=0$，所以输出Yes。\n分析\r只需按题目说的照做即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 using namespace std; int a[maxn]; int main(int argc, char** argv) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); int res = 0; for(int i=0; i\u0026lt;n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); res += x * a[i]; } puts(res == 0? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } C - ABC Tournament\r题目大意\r有$2^N$个玩家，每个玩家的编号是$i$且有一个排名$A_i$，举行$N$场淘汰赛。\n淘汰赛可以看作一棵二叉树，制度如下：\n如，$N=3$，有$8$个玩家，排名分别为$1,6,7,10,5,13,8,9$：\n1,6,7,10,5,13,8,9 两两比较，淘汰1,7,5,8；（排名越高的玩家越厉害） 6,10,13,9 两两比较，淘汰6,9； 10,13 $13$最大，胜利！ 请输出比赛的第二名（即在最后一轮被淘汰的玩家，如上面的$13$）的编号。\n$1\\le N\\le 16$\n$1\\le A_i \\le 10^9$\n$A_i$互不相同。\n输入格式\r$N$\n$A_1~A_2~A_3~\\dots~A_{2^N}$\n输出格式\r输出最终获得第二名的玩家的编号。\n样例\r样例输入1\r1 2 2 1 4 2 5 样例输出1\r1 2 $4$个玩家，排名分别为$1,4,2,5$：\n1,4,2,5 4,5（$2$号玩家在这里被淘汰了） 所以，我们输出$2$。\n样例输入2\r1 2 2 3 1 5 4 样例输出2\r1 1 $4$个玩家，排名分别为$3,1,5,4$：\n3,1,5,4 3,5（$1$号玩家在这里被淘汰了） 所以，我们输出$1$。\n样例输入3\r1 2 4 6 13 12 5 3 7 10 11 16 9 8 15 2 1 14 4 样例输出3\r1 2 博主提示：在这个样例上手算，就可以知道不能将输入排序后取第二大的值！！！\n分析\r首先，题目不允许偷懒（要求第二名的编号），不能将输入排序后取第二大的值。\n我们考虑别的方法。\n很容易想到，可以直接模拟。不过，模拟时不能直接删除元素，会TLE。可以采取利用循环队列的$\\mathcal O(1)$进出，每次出队两个元素，再将其中较大的再放入队列即可。最后，当队列中只剩两个元素时，输出其中较小的编号即可。\n代码\r写代码时要注意两点：\n一定要使用long long！ 要在进行队列操作时记录编号，可以用pair实现。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; using LL = long long; using pli = pair\u0026lt;LL, int\u0026gt;; int main(int argc, char** argv) { queue\u0026lt;pli\u0026gt; q; int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); n = 1 \u0026lt;\u0026lt; n; for(int i=1; i\u0026lt;=n; i++) { LL x; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); q.emplace(x, i); } while(q.size() \u0026gt; 2) { pli x = q.front(); q.pop(); pli y = q.front(); q.pop(); if(x \u0026lt; y) q.push(y); else q.push(x); } pli x = q.front(); q.pop(); pli y = q.front(); printf(\u0026#34;%d\\n\u0026#34;, x \u0026lt; y? x.second: y.second); return 0; } D - Snuke Prime\r题目大意\rTakahashi需要使用$N$种服务。\n每种服务的价格是$c_i$元（原题中钱币单位是日元，翻译时使用人民币作单位），他需要从第$a_i$天的开始（0:00）用到第$b_i$天的结束（23:59）。有一种特殊的服务，它可以使你无限次使用任意其它服务，每天收费$C$元（需要从一天的开始订阅到一天的结束，订阅结束时失效，可以多次订阅）。\nTakahashi使用这些服务至少需要多少元？\n$1\\le N\\le 2\\times 10^5$\n$1\\le C\\le 10^9$\n$1\\le a_i\\le b_i\\le 10^9$\n$1\\le c_i\\le 10^9$\n输入格式\r$N~C$\n$a_1~b_1~c_1$\n$a_2~b_2~c_2$\n$...$\n$a_N~b_N~c_N$\n输出格式\r输出一行，即最少需要的钱数。\n样例\r样例输入1\r1 2 3 2 6 1 2 4 2 2 4 样例输出1\r1 10 样例输入2\r1 2 3 4 5 6 5 1000000000 583563238 820642330 44577 136809000 653199778 90962 54601291 785892285 50554 5797762 453599267 65697 468677897 916692569 87409 样例输出2\r1 163089627821228 最优方案是不订阅特殊服务。\n样例输入3\r1 2 3 4 5 6 5 100000 583563238 820642330 44577 136809000 653199778 90962 54601291 785892285 50554 5797762 453599267 65697 468677897 916692569 87409 样例输出3\r1 88206004785464 自制样例\r博主在这里再提供一组样例，方便手算后面的代码以及理解题目的意思。\n输入：\n1 2 3 2 7 1 3 5 2 6 4 输出：\n1 31 在这组数据中，我们在第$2$、$3$天订阅特殊服务。\n分析\r参考：AtCoder官方题解\n我们可以把每一个服务的订阅拆分成两个事件$(a_i-1,c_i)$和$(b_i,-c_i)$。每个事件有两个参数，分别是时间（某一天的最后一刻）和每天增加的钱数（可以为负数，表示减少需要花的钱）。然后，再按时间排序这些事件。\n我们可以用变量fee记录每天需要花的钱，用ans记录答案。循环遍历每个事件，当这个事件的事件与上一次不同时，将ans加上计算最划算的付钱方法（分开付，要花fee元或一起付，花$C$元）乘以与上一次差的天数，最后加上当前事件的增加钱数。\n最后，输出ans即可。\n代码\r作为一个优先队列爱好者，排序当然是用priority_queue实现了~\n以下代码要注意三点：\n必须使用long long； 建议使用pair存储； 拆分事件时第一个事件$(a_i-1,c_i)$中的$a_i$一定不能忘记$-1$（因为$a_i$表示的是一天的开始，应该转换为前一天的结束）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long LL; typedef pair\u0026lt;LL, LL\u0026gt; pll; int main(int argc, char** argv) { int n; LL c; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;c); priority_queue\u0026lt;pll, vector\u0026lt;pll\u0026gt;, greater\u0026lt;pll\u0026gt; \u0026gt; q; while(n--) { LL x, y, z; scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); q.emplace(--x, z); q.emplace(y, -z); } LL ans = 0LL, fee = 0LL, last = 0LL; while(!q.empty()) { auto [day, cost] = q.top(); q.pop(); if(last != day) { ans += min(c, fee) * (day - last); last = day; } fee += cost; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } 上面的代码使用了C++17新特性，如果上面的代码无法通过本地编译，请使用下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long LL; typedef pair\u0026lt;LL, LL\u0026gt; pll; int main(int argc, char** argv) { int n; LL c; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;c); priority_queue\u0026lt;pll, vector\u0026lt;pll\u0026gt;, greater\u0026lt;pll\u0026gt; \u0026gt; q; while(n--) { LL x, y, z; scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); q.push(pll(--x, z)); q.push(pll(y, -z)); } LL ans = 0LL, fee = 0LL, last = 0LL; while(!q.empty()) { LL day = q.top().first, cost = q.top().second; q.pop(); if(last != day) { ans += min(c, fee) * (day - last); last = day; } fee += cost; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2021-01-13T16:25:00+08:00","permalink":"https://goodcoder666.github.io/p/abc188/","title":"AtCoder Beginner Contest 188 A~D 题解"},{"content":"A - Large Digits\r题目大意\r给定两个三位整数$A$和$B$，求它们数位和的最大值。\n数位和：例如，$123$的数位和是$1+2+3=6$。\n$100\\le A,B\\le 999$\n输入格式\r$A~~B$\n输出格式\r一行，即$A$和$B$数位和的最大值。\n样例\r输入 输出 123 234 9 593 953 17 100 999 27 分析\r直接按题目照做即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(int argc, char** argv) { char a[10], b[10]; scanf(\u0026#34;%s%s\u0026#34;, a, b); int as = 0, bs = 0; for(int i=0; a[i]; i++) as += a[i] - \u0026#39;0\u0026#39;; for(int i=0; b[i]; i++) bs += b[i] - \u0026#39;0\u0026#39;; printf(\u0026#34;%d\\n\u0026#34;, max(as, bs)); return 0; } B - Gentle Pairs\r题目大意\r有$N$个点，每个点的坐标是$(x_i,y_i)$，$x$坐标互不相同。\n有多少对符合“$-1\\le斜率\\le1$”的点？\n$1\\le N\\le 10^3$\n$|x_i|,|y_i|\\le 10^3$\n$x_i \\ne x_j$ ($i \u003c j$)\n输入格式\r$N$\n$x_1~y_1$\n$\\vdots$\n$x_n~y_n$\n输出格式\r输出答案。\n样例\r样例输入1\r1 2 3 4 3 0 0 1 2 2 1 样例输出1\r1 2 有三个点$(0,0)$、$(1,2)$、$(2,1)$。\n$(0,0)$到$(1,2)$，斜率为$2$； $(0,0)$到$(2,1)$，斜率为$\\frac12$； $(1,2)$到$(2,1)$，斜率为$-1$。 有$2$对符合条件的点。\n样例输入2\r1 2 1 -691 273 样例输出2\r1 0 只有$1$个点，无法组成对，输出$0$。\n样例输入3\r1 2 3 4 5 6 7 8 9 10 11 10 -31 -35 8 -36 22 64 5 73 -14 8 18 -58 -41 -85 1 -88 -21 -85 -11 82 样例输出3\r1 11 分析\r$$-1 \\le \\frac{y_1-y_2}{x_1-x_2} \\le 1$$$$|\\frac{y_1-y_2}{x_1-x_2}| \\le 1$$$$\\frac{|y_1-y_2|}{|x_1-x_2|}\\le 1$$$$|y_1-y_2|\\le|x1-x2|$$\n这时，就可以写代码了。\n代码\r枚举所有对点即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #define maxn 1005 using namespace std; int x[maxn], y[maxn]; inline bool slope_check(int x1, int y1, int x2, int y2) { int dx = abs(x1 - x2), dy = abs(y1 - y2); return dy \u0026lt;= dx; } int main(int argc, char** argv) { int n, cnt = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d%d\u0026#34;, x + i, y + i); for(int i=0; i\u0026lt;n-1; i++) for(int j=i+1; j\u0026lt;n; j++) if(slope_check(x[i], y[i], x[j], y[j])) cnt ++; printf(\u0026#34;%d\\n\u0026#34;, cnt); return 0; } C - 1-SAT\r题目大意\r给你$N$个字符串$S_1,S_2,...,S_N$。每个字符串都由小写字母组成，前面有至多$1$个!。\n找到$S_1,S_2,...,S_N$中任意一个字符串，使$S$中出现了“!+这个字符串”（没有引号）。如果没有符合条件的字符串，输出satisfiable。\n$1\\le N\\le 10^5$\n$1\\le |S_i|\\le 10$\n输入格式\r$N$\n$S_1$\n$\\vdots$\n$S_N$\n输出格式\r如果有符合条件的字符串，输出任意一个；\n否则，输出satisfiable。\n样例\r样例输入1\r1 2 3 4 5 6 7 6 a !a b !c d !d 样例输出1\r1 a $S_1$为a，$S_2$为!a，所以$S_1$符合条件；\n$S_5$为d，$S_6$为!d，所以$S_5$也符合条件，输出d也会被判为正确。\n样例输入2\r1 2 3 4 5 6 7 8 9 10 11 10 red red red !orange yellow !blue cyan !green brown !gray 样例输出2\r1 satisfiable 没有符合条件的字符串。\n分析\r如果暴力去枚举两个字符串（如，a和!a），需要两重循环，复杂度为$\\mathcal O(N^2)$（由于字符串太短可以忽略字符串比较），这里$N$最大为$10^5$，所以，枚举法不可用。\n我们再考虑$\\mathcal O(n\\log n)$。\n可以每次输入字符串时判断一下，如果它以!开头将它的!后面的内容放入set中，否则将整个字符串放入vector中。最后，循环遍历vector（$\\mathcal O(n)$），每次在set中查找这个字符串（$\\mathcal O(\\log n)$）。总时间复杂度为$\\mathcal O(n\\log n)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;string\u0026gt; v; set\u0026lt;string\u0026gt; s; int main(int argc, char** argv) { ios::sync_with_stdio(false); cin.tie(0); int n; cin \u0026gt;\u0026gt; n; while(n--) { string x; cin \u0026gt;\u0026gt; x; if(x[0] == \u0026#39;!\u0026#39;) s.insert(x.substr(1)); else v.push_back(x); } for(int i=0; i\u0026lt;v.size(); i++) if(s.find(v[i]) != s.end()) { cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; \u0026#34;satisfiable\\n\u0026#34;; return 0; } D - Choose Me\r题目大意\r题目大意略，请自行前往AtCoder查看。\n数据范围：\n$1\\le N\\le 10^5$\n$1\\le A_i,B_i\\le 10^9$\n输入格式\r$N$\n$A_1~B_1$\n$\\vdots$\n$A_N~B_N$\n输出格式\r输出答案。\n样例\r样例输入1\r1 2 3 4 5 4 2 1 2 2 5 1 1 3 样例输出1\r1 1 Takahashi在第三个城市演讲后，Aoki和Takahashi将分别得到$5$和$6$个投票。\n样例输入2\r1 2 3 4 5 6 5 2 1 2 1 2 1 2 1 2 1 样例输出2\r1 3 在任意三个城市演讲后，Aoki和Takahashi将分别得到$4$和$9$个投票。\n样例输入3\r1 2 1 273 691 样例输出3\r1 1 分析\r换句话说，我们的目的就是使得Aoki和Takahashi的票数差距逐渐减少。\n最开始，票数的差距是Aoki票数的和，也就是$\\sum\\limits_{i=1}^nA_i$。\n每去第$i$个城市，差距减少$2A_i+B_i$，因此，我们可以贪心地先前往差距减少多的城市。这一点可以用数组+排序、set、priority_queue三种方法实现（我选择的是priority_queue，set和priority_queue更快一些）。\n代码\r注意：一定不能忘记使用long long！！！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; typedef long long LL; priority_queue\u0026lt;LL\u0026gt; q; int main(int argc, char** argv) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); LL diff = 0; while(n--) { LL ao, ta; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;ao, \u0026amp;ta); diff += ao; q.push(ao + ao + ta); } int ans = 0; while(!q.empty()) { ans ++; if((diff -= q.top()) \u0026lt; 0) { printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } q.pop(); } return 0; } ","date":"2021-01-03T14:06:00+08:00","permalink":"https://goodcoder666.github.io/p/abc187/","title":"AtCoder Beginner Contest 187 A~D 题解"},{"content":"A - Payment\r题目大意\r如果使用价值$1000$元的纸币（假设有）支付$N$元，服务员会找多少钱？\n$1\\le N\\le 10000$\n输入格式\r$N$\n输出格式\r一行，即服务员找的钱数。\n样例\r输入 输出 1900 100 3000 0 分析\r特判：\n如果$N$除以$1000$能整除，那么不需要找钱，输出$0$；\n如果有余，输出$1000 - (n\\mod1000)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if(n % 1000 == 0) puts(\u0026#34;0\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, 1000 - n % 1000); return 0; } B - Judge Status Summary\r题目大意\r某人完成了某道算法竞赛题，有AC、WA、TLE、RE四种结果（status）。题目有$N$个测试样例，测试结果分别为$S_1, S_2, \\dots, S_N$，请分别统计并输出AC、WA、TLE、RE的个数。（格式详见输出格式）\n$1\\le N\\le 10^5$\n$S_i$是AC、WA、TLE或RE。\n输入格式\r$N$\n$S_1$\n$S_2$\n$:$\n$S_N$\n输出格式\r1 2 3 4 AC x [AC的个数] WA x [WA的个数] TLE x [TLE的个数] RE x [RE的个数] 注意：这里的“乘号”不是“×”，而是英文字母“x”！\n样例\r样例输入1\r1 2 3 4 5 6 7 6 AC TLE AC AC WA TLE 样例输出1\r1 2 3 4 AC x 3 WA x 1 TLE x 2 RE x 0 AC、WA、TLE、RE分别有$3, 1, 2, 0$个。\n样例输入2\r1 2 3 4 5 6 7 8 9 10 11 10 AC AC AC AC AC AC AC AC AC AC 样例输出2\r1 2 3 4 AC x 10 WA x 0 TLE x 0 RE x 0 他全都AC了……\n分析\r要统计个数，可以用别的方法，但我个人喜欢偷懒，使用了map（似乎大材小用了……）\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; map\u0026lt;string, int\u0026gt; cnt; int main(int argc, char** argv) { ios::sync_with_stdio(false); int n; cin\u0026gt;\u0026gt;n; for(int i=0; i\u0026lt;n; i++) { string s; cin\u0026gt;\u0026gt;s; cnt[s] ++; } cout\u0026lt;\u0026lt;\u0026#34;AC x \u0026#34;\u0026lt;\u0026lt;cnt[\u0026#34;AC\u0026#34;]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;WA x \u0026#34;\u0026lt;\u0026lt;cnt[\u0026#34;WA\u0026#34;]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;TLE x \u0026#34;\u0026lt;\u0026lt;cnt[\u0026#34;TLE\u0026#34;]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;RE x \u0026#34;\u0026lt;\u0026lt;cnt[\u0026#34;RE\u0026#34;]\u0026lt;\u0026lt;endl; return 0; } C - H and V\r题目大意\r给定$H$行$W$列的方格。在第$i$行$j$列（$1\\le i\\le H$, $1\\le j\\le W$）的方格是$c_i$$_,$$_j$。它可能是#（黑色）或.（白色）。\n可以选某些行和列（都可以不选），将行和列上的方格全部涂成红色。\n给定整数$K$。有多少种选法使图中只剩$K$个黑方格？\n$1\\le H, W\\le 6$\n$1\\le K\\le HW$\n$c_i$$_,$$_j$是#或.。\n输入格式\r$H~W~K$\n$c_{1,1}~c_{1,2}~\\dots~c_{1,W}$\n$c_{2,1}~c_{2,2}~\\dots~c_{2,W}$\n$\\vdots$\n$c_{H,1}~c_{H,2}~\\dots~c_{1,W}$\n输出格式\r一行，即符合条件的选法数量。\n样例\r样例输入1\r1 2 3 2 3 2 ..# ### 样例输出1\r1 5 有五种方法：\n第$1$行和第$1$列 第$1$行和第$2$列 第$1$行和第$3$列 第$1$、$2$列 第$3$列 样例输入2\r1 2 3 2 3 4 ..# ### 样例输出2\r1 1 只有一种方法：啥也不干！\n样例输入3\r1 2 3 2 2 3 ## ## 样例输出3\r1 0 无解。\n样例输入4\r1 2 3 4 5 6 7 6 6 8 ..##.. .#..#. #....# ###### #....# #....# 博主提示：这是最大的数据，如果程序在本地运行此样例没有超时，则提交后不会TLE！\n样例输出4\r1 208 分析\r本题没有巧妙的方法，且数据范围较小，所以使用二进制法枚举行和列。\n因为输入颜色只有黑或白，所以题目中“涂成红色”只要涂成白色（.）即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define maxn 6 using namespace std; char c[maxn][maxn]; int h, w, k; int cnt = 0; int main(int argc, char** argv) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;h, \u0026amp;w, \u0026amp;k); for(int i=0; i\u0026lt;h; i++) scanf(\u0026#34;%s\u0026#34;, c[i]); int m1 = 1 \u0026lt;\u0026lt; h, m2 = 1 \u0026lt;\u0026lt; w, ans = 0; for(int hs=0; hs\u0026lt;m1; hs++) for(int ws=0; ws\u0026lt;m2; ws++) { char tmp[maxn][maxn]; // 不能修改原数组，所以复制一个数组 memcpy(tmp, c, sizeof(c)); for(int i=0; i\u0026lt;h; i++) // 行 if(hs \u0026amp; (1 \u0026lt;\u0026lt; i)) for(int j=0; j\u0026lt;w; j++) // 列 tmp[i][j] = \u0026#39;.\u0026#39;; for(int i=0; i\u0026lt;w; i++) // 列 if(ws \u0026amp; (1 \u0026lt;\u0026lt; i)) for(int j=0; j\u0026lt;h; j++) // 行 tmp[j][i] = \u0026#39;.\u0026#39;; // 注意：绝对不能写成tmp[i][j]! int cnt = 0; for(int i=0; i\u0026lt;h; i++) for(int j=0; j\u0026lt;w; j++) if(tmp[i][j] == \u0026#39;#\u0026#39;) cnt ++; if(cnt == k) ans ++; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Chat in a Circle\r题目大意\r有$N$个人要在某地会和，编号为$i$的人的友情值为整数$A_i$。这些人要围成一圈，每人到达该地后会在某个位置插入圈子。每个人的舒适度是入圈时相邻两个人的友情值中较小的一个（第一个人的舒适度为$0$）。现在，由你决定他们的入圈顺序和插入位置，问：$N$个人的最大舒适度之和是多少？\n$2\\le N\\le 2\\times10^5$\n$1\\le A_i\\le 10^9$\n输入格式\r$N$\n$A_1~A_2~\\dots~A_N$\n输出格式\r一行，即$N$个人的最大舒适度之和。\n样例\r样例输入1\r1 2 4 2 2 1 3 样例输出1\r1 7 最大的舒适度之和为$0+3+2+2=7$。\n样例输入2\r1 2 7 1 1 1 1 1 1 1 样例输出2\r1 6 分析\r贪心算法。先从大到小排序（这是顺序），再将每个人在舒适度最大的地方入圈。\npriority_queue搞定。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 200005 using namespace std; int a[maxn], n; struct Position { int lf, rf, comfort; inline Position(int l, int r) { lf = l, rf = r; comfort = min(l, r); } inline bool operator\u0026lt;(const Position\u0026amp; p) const { return comfort \u0026lt; p.comfort; } }; priority_queue\u0026lt;Position\u0026gt; q; inline bool cmp(int x, int y) {return x \u0026gt; y;} int main(int argc, char** argv) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); sort(a, a + n, cmp); q.push(Position(a[0], a[1])); long long res = a[0]; for(int i=2; i\u0026lt;n; i++) { Position p = q.top(); if(q.size() \u0026gt; 1) q.pop(); res += p.comfort; q.push(Position(a[i], p.lf)); q.push(Position(a[i], p.rf)); } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } ","date":"2020-07-20T11:59:00+08:00","permalink":"https://goodcoder666.github.io/p/abc173/","title":"AtCoder Beginner Contest 173 A~D 题解"},{"content":"问题分析\r可能是升级或卸载了spyder依赖的包，导致spyder无法正常运行。\n我升级了PyQt5，spyder要求PyQt5\u0026lt;5.13，而安装的最新版本为5.15，导致spyder启动时出现问题。\n解决方法\r打开Anaconda Prompt，执行：\n1 pip install spyder 解释：\npip会自动根据要安装的包（spyder也是一个包）安装依赖的包，如spyder要求PyQt5\u0026lt;5.13，安装PyQt5 5.15后pip会自动识别，并安装PyQt5 5.12.3（低于5.13的最高版本）。\n20210926 EDIT：\n如出现“拒绝访问”一类的错误，加上--user选项即可。\n","date":"2020-07-12T16:03:00+08:00","permalink":"https://goodcoder666.github.io/p/spyderfix/","title":"Anaconda Spyder点击无响应解决"},{"content":"python的包管理工具pip速度太慢，经常下载时报错，可以使用清华镜像代替默认下载源。以下两种方法任何电脑都可以使用，演示电脑为Windows 10 版本1909。\n临时方法\r使用pip下载时，临时使用镜像（命令行）：\n1 pip install \u0026lt;包名称\u0026gt; -i https://pypi.tuna.tsinghua.edu.cn/simple 永久方法\r打开命令行，执行：\n1 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 1.1MB/s 2.2MB/s 6.8MB/s\nP. S. 网上搜了$N$篇文章都说自己创建pip.ini文件\u0026hellip;\n","date":"2020-07-12T14:56:00+08:00","permalink":"https://goodcoder666.github.io/p/pypi-tsmirror/","title":"pip速度太慢解决（使用清华镜像）"},{"content":"A - αlphabet\r题目大意\r输入一个英文字母$a$，判断它是大写还是小写。\n输入格式\r$a$\n输出格式\r如果$a$为小写，输出a；\n如果$a$为大写，输出A。\n样例输入1\r1 B 样例输出1\r1 A B为大写，所以输出A。\n样例输入2\r1 a 样例输出2\r1 a a为小写，所以输出a。\n代码\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { char a = getchar(); if(\u0026#39;a\u0026#39; \u0026lt;= a \u0026amp;\u0026amp; a \u0026lt;= \u0026#39;z\u0026#39;) putchar(\u0026#39;a\u0026#39;); else putchar(\u0026#39;A\u0026#39;); return 0; } B - Mix Juice\r题目大意\r给定一个长度为$N$的数组$p_1, p_2, p_3, ..., p_N$，要求从其中选出$K$个数，使它们的和最小。\n$1\\le K\\le N\\le 1000$\n$1\\le p_i\\le 1000$ ($1\\le i\\le N$)\n输入格式\r$N K$\n$p_1~p_2~p_3~\\dots~p_N$\n输出格式\r一行，即最小的和。\n样例输入1\r1 2 5 3 50 100 80 120 80 最小的和是$50+80+80=210$。\n样例输出1\r1 210 B为大写，所以输出A。\n样例输入2\r1 2 1 1 1000 样例输出2\r1 1000 因为只有一个数，所以最小的和就是$1000$。（此注释为笔者所加）\n代码\r题目要求和最小，其实只要找到数组中最小的$K$个数字的和即可。可以使用\u0026lt;algorithm\u0026gt;库中的sort()函数对p数组进行升序排序，再取前$K$个数字之和作为结果输出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 1005 using namespace std; int a[maxn]; int main(int argc, char** argv) { int n, k, sum = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); sort(a, a + n); for(int i=0; i\u0026lt;k; i++) sum += a[i]; printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; } C - One Quadrillion and One Dalmatians\r题目大意\r有$1000000000000001$（$10^{15}+1$）只狗，它们的名字分别为：\na, b, .., z, aa, ab, .., az, ba, bb, .., bz, .., za, zb, .., zz, aaa, aab, .., aaz, aba, abb, .., abz, ., zzz, aaaa, ..\n问题：第$N$只狗的名字是什么？\n$1\\le N\\le 10^{15}+1$\n输入格式\r$N$\n输出格式\r一行，即第$N$只狗的名字。\n样例\r样例较多，为了节省文章篇幅，所以直接整合成表格：\n输入 输出 2 b 27 aa 123456789 jjddja 代码\r其实就是把十进制转换成二十六进制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define BASE 26LL using namespace std; int main(int argc, char** argv) { char s[12]; int cnt = 0; long long n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); while(n \u0026gt; 0) { n --; s[cnt++] = n % BASE + \u0026#39;a\u0026#39;; n /= BASE; } for(int i=cnt-1; i\u0026gt;=0; i--) putchar(s[i]); putchar(\u0026#39;\\n\u0026#39;); return 0; } D - Replacing\r题目大意\r有一个数组$A_1, A_2, \\dots, A_N$。\n执行如下$Q$个操作：\n在第$i$个操作中，将数组中所有的$B_i$替换成$C_i$。 输出操作后$A$中所有数之和（记为$S_i$）。 $1\\le N, Q, A_i, B_i, C_i\\le 10^5$ ($1\\le i\\le N$)\n$B_i\\ne C_i$\n输入格式\r$N$\n$A_1~A_2~...~A_N$\n$Q$\n$B_1~C_1$\n$B_2~C_2$\n$:$\n$B_Q~C_Q$\n输出格式\r$S_1$\n$S_2$\n$:$\n$S_N$\n样例输入1\r1 2 3 4 5 6 4 1 2 3 4 3 1 2 3 4 2 4 样例输出1\r1 2 3 11 12 16 时间 数组$A$ 开始 $\\{1, 2, 3, 4\\}$ $i=1$ $\\{2, 2, 3, 4\\}$ $i=2$ $\\{2, 2, 4, 4\\}$ $i=3$ $\\{4, 4, 4, 4\\}$ 样例输入2\r1 2 3 4 5 6 4 1 1 1 1 3 1 2 2 1 3 5 注意：$B_i$不一定存在列表中。\n样例输出2\r1 2 3 8 4 4 样例输入3\r1 2 3 4 5 6 2 1 2 3 1 100 2 100 100 1000 样例输出3\r1 2 3 102 200 2000 代码\r可以用数组记录$A$中每个值出现的次数。这里由于题目原因，还需要记录数组$A$每个数之和。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 using namespace std; typedef long long LL; int cnt[maxn]; LL sum = 0; inline LL s(const LL\u0026amp; i) { return cnt[i] * i; } int main(int argc, char** argv) { int n, q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); sum += t; cnt[t] ++; } scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while(q--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); sum -= s(x) + s(y); cnt[y] += cnt[x]; cnt[x] = 0; sum += s(y); printf(\u0026#34;%lld\\n\u0026#34;, sum); } return 0; } ","date":"2020-06-22T15:50:00+08:00","permalink":"https://goodcoder666.github.io/p/abc171/","title":"AtCoder Beginner Contest 171 A~D 题解"},{"content":"最近（文章撰写时间为2020/6/1 18:40）疫情在中国情况好转，却在美国暴虐。\n本篇文章将爬取腾讯提供的美国疫情数据并制表。\n爬取数据\r调用API接口\r接口：https://api.inews.qq.com/newsqa/v1/automation/modules/list?modules=FAutoCountryMerge\n观察得到的数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { ..., \u0026#34;data\u0026#34;: { \u0026#34;FAutoCountryMerge\u0026#34;: { ..., \u0026#34;美国\u0026#34;: { \u0026#34;showDash\u0026#34;:false, \u0026#34;list\u0026#34;: [ {\u0026#34;date\u0026#34;:\u0026#34;01.28\u0026#34;,\u0026#34;confirm_add\u0026#34;:0,\u0026#34;confirm\u0026#34;:5,\u0026#34;heal\u0026#34;:0,\u0026#34;dead\u0026#34;:0}, ..., {\u0026#34;date\u0026#34;:\u0026#34;05.29\u0026#34;,\u0026#34;confirm_add\u0026#34;:25069,\u0026#34;confirm\u0026#34;:1768461,\u0026#34;heal\u0026#34;:510713,\u0026#34;dead\u0026#34;:103330}, {\u0026#34;date\u0026#34;:\u0026#34;05.30\u0026#34;,\u0026#34;confirm_add\u0026#34;:23290,\u0026#34;confirm\u0026#34;:1793530,\u0026#34;heal\u0026#34;:519569,\u0026#34;dead\u0026#34;:104542}, {\u0026#34;date\u0026#34;:\u0026#34;05.31\u0026#34;,\u0026#34;confirm_add\u0026#34;:20350,\u0026#34;confirm\u0026#34;:1816820,\u0026#34;heal\u0026#34;:535238,\u0026#34;dead\u0026#34;:105557}, {\u0026#34;date\u0026#34;:\u0026#34;06.01\u0026#34;,\u0026#34;confirm_add\u0026#34;:20350,\u0026#34;confirm\u0026#34;:1837170,\u0026#34;heal\u0026#34;:599867,\u0026#34;dead\u0026#34;:106195} ] }, ... } } } 由如上代码所示，对于一个国家，获取其疫情数据只需要使用：\n1 json[\u0026#39;data\u0026#39;][\u0026#39;FAutoCountryMerge\u0026#39;][\u0026#39;\u0026lt;国名\u0026gt;\u0026#39;][\u0026#39;list\u0026#39;] 对于美国的数据，使用：\n1 json[\u0026#39;data\u0026#39;][\u0026#39;FAutoCountryMerge\u0026#39;][\u0026#39;美国\u0026#39;][\u0026#39;list\u0026#39;] 代码\r上面都是干货，下面才是真正的code：\n1 2 3 4 from requests import get url = \u0026#39;https://api.inews.qq.com/newsqa/v1/automation/modules/list?modules=FAutoCountryMerge\u0026#39; data = get(url).json()[\u0026#39;data\u0026#39;][\u0026#39;FAutoCountryMerge\u0026#39;][\u0026#39;美国\u0026#39;][\u0026#39;list\u0026#39;] 处理数据\r在python中，其结果是一个list对象：\n1 2 3 4 5 6 7 8 [ {\u0026#34;date\u0026#34;:\u0026#34;01.28\u0026#34;,\u0026#34;confirm_add\u0026#34;:0,\u0026#34;confirm\u0026#34;:5,\u0026#34;heal\u0026#34;:0,\u0026#34;dead\u0026#34;:0}, ..., {\u0026#34;date\u0026#34;:\u0026#34;05.29\u0026#34;,\u0026#34;confirm_add\u0026#34;:25069,\u0026#34;confirm\u0026#34;:1768461,\u0026#34;heal\u0026#34;:510713,\u0026#34;dead\u0026#34;:103330}, {\u0026#34;date\u0026#34;:\u0026#34;05.30\u0026#34;,\u0026#34;confirm_add\u0026#34;:23290,\u0026#34;confirm\u0026#34;:1793530,\u0026#34;heal\u0026#34;:519569,\u0026#34;dead\u0026#34;:104542}, {\u0026#34;date\u0026#34;:\u0026#34;05.31\u0026#34;,\u0026#34;confirm_add\u0026#34;:20350,\u0026#34;confirm\u0026#34;:1816820,\u0026#34;heal\u0026#34;:535238,\u0026#34;dead\u0026#34;:105557}, {\u0026#34;date\u0026#34;:\u0026#34;06.01\u0026#34;,\u0026#34;confirm_add\u0026#34;:20350,\u0026#34;confirm\u0026#34;:1837170,\u0026#34;heal\u0026#34;:599867,\u0026#34;dead\u0026#34;:106195} ] 该对象中存放美国每天的疫情数据，\ndate：从1月28日至今的日期；\nconfirm_add：该日新增确诊；\nconfirm：该日累计确诊；\nheal：该日累计治愈；\ndead：该日累计死亡。\n筛选数据\r数据的筛选很重要。\nconfirm_add（该日新增确诊）明显没有用，去掉 应该增加一个now_confirm（该日现存确诊），这样能清楚地看到美国治疗中人数。\n该值可以通过confirm - heal - head得到。 date：从1月28日至今的日期\nconfirm_add：该日新增确诊\nconfirm：该日累计确诊\nheal：该日累计治愈\ndead：该日累计死亡\nnow_confirm: 该日现存确诊\n代码\r由于最前面人数太少，数据会影响到最终绘图质量。\n所以，我从第35个开始保存数据，当然如果您想使用所有数据，将data[35:]改为data即可。\n1 2 3 4 5 6 7 8 9 10 11 12 dates = [] confirms = [] now_confirms = [] heals = [] deads = [] for day_data in data[35:]: dates.append(day_data[\u0026#39;date\u0026#39;]) confirms.append(day_data[\u0026#39;confirm\u0026#39;]) heals.append(day_data[\u0026#39;heal\u0026#39;]) deads.append(day_data[\u0026#39;dead\u0026#39;]) now_confirms.append(confirms[-1] - heals[-1] - deads[-1]) 绘图\r参考文章：https://www.cnblogs.com/lone5wolf/p/10870200.html\n由于我在绘图方面还是个小白，所以直接贴出代码，敬请谅解。。。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import matplotlib.pyplot as plt from matplotlib.font_manager import FontProperties # 绘制文本 plt.figure(figsize=(11.4, 7.7)) confirm_line, = plt.plot(dates, confirms, color=\u0026#39;#8B0000\u0026#39;) now_confirm_line, = plt.plot(dates, now_confirms, color=\u0026#39;red\u0026#39;, linestyle=\u0026#39;:\u0026#39;) heal_line, = plt.plot(dates, heals, color=\u0026#39;green\u0026#39;, linestyle=\u0026#39;--\u0026#39;) dead_line, = plt.plot(dates, deads, color=\u0026#39;black\u0026#39;, linestyle=\u0026#39;-.\u0026#39;) # 绘制图形 my_font = FontProperties(fname=r\u0026#39;fonts\\msyh.ttc\u0026#39;) plt.legend(handles=[confirm_line, now_confirm_line, heal_line, dead_line], labels=[\u0026#39;累计确诊\u0026#39;, \u0026#39;现存确诊\u0026#39;, \u0026#39;治愈\u0026#39;, \u0026#39;死亡\u0026#39;], prop=my_font) plt.xlabel(\u0026#39;日期\u0026#39;, fontproperties=my_font) plt.ylabel(\u0026#39;人数\u0026#39;, fontproperties=my_font) plt.title(\u0026#39;美国2019-nCov疫情情况\u0026#39;, fontproperties=my_font) plt.gca().xaxis.set_major_locator(plt.MultipleLocator(7)) # 保存并显示统计图 plt.savefig(\u0026#39;AmericaNCovData.png\u0026#39;) plt.show() 结果图片\r完整代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # -*- coding: utf-8 -*- from requests import get import matplotlib.pyplot as plt from matplotlib.font_manager import FontProperties url = \u0026#39;https://api.inews.qq.com/newsqa/v1/automation/modules/list?modules=FAutoCountryMerge\u0026#39; data = get(url).json()[\u0026#39;data\u0026#39;][\u0026#39;FAutoCountryMerge\u0026#39;][\u0026#39;美国\u0026#39;][\u0026#39;list\u0026#39;] dates = [] confirms = [] now_confirms = [] heals = [] deads = [] for day_data in data[35:]: dates.append(day_data[\u0026#39;date\u0026#39;]) confirms.append(day_data[\u0026#39;confirm\u0026#39;]) heals.append(day_data[\u0026#39;heal\u0026#39;]) deads.append(day_data[\u0026#39;dead\u0026#39;]) now_confirms.append(confirms[-1] - heals[-1] - deads[-1]) # 绘制文本 plt.figure(figsize=(11.4, 7.7)) confirm_line, = plt.plot(dates, confirms, color=\u0026#39;#8B0000\u0026#39;) now_confirm_line, = plt.plot(dates, now_confirms, color=\u0026#39;red\u0026#39;, linestyle=\u0026#39;:\u0026#39;) heal_line, = plt.plot(dates, heals, color=\u0026#39;green\u0026#39;, linestyle=\u0026#39;--\u0026#39;) dead_line, = plt.plot(dates, deads, color=\u0026#39;black\u0026#39;, linestyle=\u0026#39;-.\u0026#39;) # 绘制图形 my_font = FontProperties(fname=r\u0026#39;fonts\\msyh.ttc\u0026#39;) plt.legend(handles=[confirm_line, now_confirm_line, heal_line, dead_line], labels=[\u0026#39;累计确诊\u0026#39;, \u0026#39;现存确诊\u0026#39;, \u0026#39;治愈\u0026#39;, \u0026#39;死亡\u0026#39;], prop=my_font) plt.xlabel(\u0026#39;日期\u0026#39;, fontproperties=my_font) plt.ylabel(\u0026#39;人数\u0026#39;, fontproperties=my_font) plt.title(\u0026#39;美国2019-nCov疫情情况\u0026#39;, fontproperties=my_font) plt.gca().xaxis.set_major_locator(plt.MultipleLocator(7)) # 保存并显示统计图 plt.savefig(\u0026#39;AmericaNCovData.png\u0026#39;) plt.show() 代码下载：GitHub\n","date":"2020-06-03T13:35:00+08:00","permalink":"https://goodcoder666.github.io/p/pws-tencent-us-19ncov/","title":"【python爬虫】从腾讯API爬取美国疫情数据+制表"},{"content":"这次比赛的题名很特殊，是由符号+(+英文+)组成的 :)\nC - : (Colon)\r题目大意\r在$A$时$B$分，长度为$H$厘米的时针和长度为$M$厘米的分针的顶点的距离是多少？\n$1\\le A, B\\le 1000$\n$0\\le H\\le 11$\n$0\\le M\\le 59$\n（浮点数精度误差最多允许$10^{-9}$）\n输入格式\r$A~B~H~M$\n输出格式\r一行，即两点之间的距离。\n样例\r样例输入1\r1 3 4 9 0 样例输出1\r1 5.00000000000000000000 样例输入2\r1 3 4 10 40 样例输出2\r1 4.56425719433005567605 分析\r$$C^2=A^2+B^2-2AB\\cos\\theta$$\n需要注意的是：C/C++中的cos函数的参数应是弧度，如$\\theta$是角度请使用cos(theta / 180 * PI)\n代码\r终于上代码了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #define PI 3.1415926535897932 using namespace std; int main(int argc, char** argv) { int a, b, h, m; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;h, \u0026amp;m); int mangle = m * 6; double hangle = h * 30 + m * 0.5; double theta = abs(hangle - mangle); if(theta \u0026gt; 180) theta = 360 - theta; theta = theta / 180 * PI; printf(\u0026#34;%.13lf\\n\u0026#34;, sqrt(double(a * a + b * b) - 2.0 * a * b * cos(theta))); return 0; } D - . . (Double Dots)\r题目大意\r有一个山洞，它有$N$个房间和$M$条通道。\n房间的编号是$1$ ~ $N$，通道的编号是$1$ ~ $M$，每条通道双向连接$A_i$和$B_i$ ($1\\le i\\le M$)。房间$1$是山洞的出口。\n现在要给每个房间标一个路标，指向一个和本房间被通道连接的房间。\n每个房间（房间$1$除外）如果一直按照路标走向指示的房间，那么走的路径一定是最短的到出口的路径。\n$2\\le N\\le 10^5$\n$1\\le M\\le 2 * 10^5$\n$1\\le A_i, B_i\\le N$ ($1\\le i\\le M$)\n$A_i≠B_i$ ($1\\le i\\le M$)\n输入格式\r$N~M$\n$A_1~B_1$\n$\\vdots$\n$A_M~B_M$\n输出格式\r如果无解，输出No；\n如果有解，第一行输出Yes，第$i$行输出房间$i$的路标指向的房间序号。($2\\le i\\le N$)\n分析\r明显bfs题目..\n说明一点：如果给定山洞不连通，则无解。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #define UNVISITED -1 #define maxn 100005 using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; vector\u0026lt;int\u0026gt; G[maxn]; int par[maxn]; int main(int argc, char** argv) { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;n; i++) par[i] = UNVISITED; for(int i=0; i\u0026lt;m; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G[--x].push_back(--y); G[y].push_back(x); } queue\u0026lt;pii\u0026gt; q; q.push(pii(0, -1)); while(!q.empty()) { int room = q.front().first, p = q.front().second; q.pop(); if(par[room] != UNVISITED) continue; par[room] = p; for(int i=0; i\u0026lt;G[room].size(); i++) q.push(pii(G[room][i], room)); } for(int i=1; i\u0026lt;n; i++) if(par[i] == UNVISITED) { puts(\u0026#34;No\u0026#34;); return 0; } puts(\u0026#34;Yes\u0026#34;); for(int i=1; i\u0026lt;n; i++) printf(\u0026#34;%d\\n\u0026#34;, par[i] + 1); return 0; } ","date":"2020-05-19T19:24:00+08:00","permalink":"https://goodcoder666.github.io/p/abc168/","title":"AtCoder Beginner Contest 168 C~D 题解"},{"content":"温馨提示：如果读者没有学过def定义函数，请先看这里\n定义形式\r1 \u0026lt;函数名\u0026gt; = lambda \u0026lt;参数列表\u0026gt;: \u0026lt;返回值\u0026gt; 等同于：\n1 2 def \u0026lt;函数名\u0026gt;(\u0026lt;参数列表\u0026gt;): return \u0026lt;返回值\u0026gt; 也可以定义为匿名函数（没有名字的函数）：\n1 lambda \u0026lt;参数列表\u0026gt;: \u0026lt;返回值\u0026gt; 可以确认lambda函数对象的类型与def定义的一样，都是function：\n调用\r如果是匿名函数，调用形式为：\n1 (lambda \u0026lt;参数列表\u0026gt;: \u0026lt;返回值\u0026gt;)(\u0026lt;参数列表\u0026gt;) 如果不是，调用形式为：\n1 \u0026lt;函数名\u0026gt;(\u0026lt;参数列表\u0026gt;) 计算$a+b$的函数：\n无返回值\rlambda函数也可无返回值。\n如：\n无返回值的lambda函数一般用于做事，如print('Hello World')等。\n","date":"2020-04-21T18:32:00+08:00","permalink":"https://goodcoder666.github.io/p/python-lambda-functions/","title":"Python函数之lambda函数"},{"content":"链接\r想研究Python函数？看这里\n函数怎样取名？看这里\n有参数的函数还可以怎么传参？看这里\n一、无参数函数\r结构\r1 2 3 def \u0026lt;函数名\u0026gt;(): # 强制要求 \u0026lt;函数体\u0026gt; # 可省略 return \u0026lt;返回值\u0026gt; # 可省略 程序举例\r用函数的Hello world程序：\n1 2 3 4 5 6 7 8 9 10 11 # prints \u0026#39;Hello World\\nDone\u0026#39; # Author: GoodCoder666 def getHelloWorldString(): return \u0026#39;Hello World\u0026#39; def print_hello_world(): print(getHelloWorldString()) print_hello_world() print(\u0026#39;Done\u0026#39;) # 输出： # Hello World # Done 程序流程\r1 2 3 4 5 6 7 8 9 flowchat st=\u0026gt;start: 开始，调用print_hello_world() e=\u0026gt;end: 结束 get_str_call=\u0026gt;operation: print_hello_world()调用getHelloWorldString() return_str=\u0026gt;operation: getHelloWorldString()返回 \u0026#39;Hello world\u0026#39; print_hi=\u0026gt;inputoutput: 回到print_hello_world()，输出Hello world done=\u0026gt;inputoutput: 回到主程序，输出Done st-\u0026gt;get_str_call-\u0026gt;return_str-\u0026gt;print_hi-\u0026gt;done-\u0026gt;e 二、有参数函数\r补充知识\r参数 (parameter)：给函数的值，在函数中相当于变量：\n1 2 3 4 def param_test(a, b): a, b = b, a print(a, b) param_test(5, 6) # 输出：6 5 以上程序等同于：\n1 2 3 4 5 6 def param_test(): a, b = 5, 6 #-----以下部分相同-----# a, b = b, a print(a, b) param_test() # 输出：6 5 结构\r1 2 3 def \u0026lt;函数名\u0026gt;(\u0026lt;参数列表\u0026gt;): # 强制要求 \u0026lt;函数体\u0026gt; # 可省略 return \u0026lt;返回值\u0026gt; # 可省略 其中，参数列表中的参数用,隔开，例如a, b 、c（如果只有一个参数直接写）\n程序举例\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 # prints \u0026#39;Hi, {name}!\u0026#39; # Author: GoodCoder666 def get_greet_str(name): return \u0026#39;Hi, \u0026#39; + name + \u0026#39;!\u0026#39; def greet(name): print(get_greet_str(name)) greet(input(\u0026#34;What\u0026#39;s your name? \u0026#34;)) print(\u0026#39;Done\u0026#39;) # 输入: GoodCoder666 # 输出 # Hi, GoodCoder666! # Done 程序流程\r1 2 3 4 5 6 7 8 9 flowchat st=\u0026gt;start: 开始，调用input(\u0026#34;What\u0026#39;s your name?\u0026#34;) e=\u0026gt;end: 结束 call_greet=\u0026gt;operation: input返回用户名，调用greet(\u0026lt;用户名\u0026gt;) call_get_greet_str=\u0026gt;operation: greet调用get_greet_str(\u0026lt;用户名\u0026gt;) print_hi=\u0026gt;inputoutput: 回到get_greet_str，输出get_greet_str的返回值 done=\u0026gt;inputoutput: 回到主程序，输出Done st-\u0026gt;call_greet-\u0026gt;call_get_greet_str-\u0026gt;print_hi-\u0026gt;done-\u0026gt;e 函数也是对象\r一个函数也是一个对象。\n证明\r先定义两个函数：\n1 2 3 4 def a(a, b): return a + b def b(): return a(1, 2) 项目 是否支持/存在 证明 赋值 Y c = a可执行；执行后c可被调用 属性 Y 执行type(a)，返回class \u0026lt;'function'\u0026gt; 类型 Y ","date":"2020-04-21T13:22:00+08:00","permalink":"https://goodcoder666.github.io/p/python-def-functions/","title":"Python函数之def定义函数"},{"content":"先上干货，通用的：\n字母：A-Z a-z\n下划线：_\n数字：0-9（注意：数字不能在开头）\n==理论上可以使用中文变量名，但强烈不建议使用。==\n合法名字举例\r1 2 3 abcdef\tGoodCoder\tAD_fhrygfuigfr A_a_007\t__NAME123\t_P_T_ _123456\tCc_Dd\t_ 不合法名字举例\r1 2 3 666Code\tC++\t1+1=2\t(5)4 654ty54F\t0.123\t123456@qq.com ccf-csp\tatcoder\u0026amp;codeforces 取名风格\r首字母一般（类除外）小写。\n由于对象名称中不能有空格，所以有两种风格：\n1 2 helloWorldStr = \u0026#39;Hello World\u0026#39; hello_world_str = \u0026#39;Hello World\u0026#39; 取名为helloWorldStr，将每个单词（除第一个hello）首字母大写； 取名为hello_world_str，将每两个单词之间加一个下划线（_）。 特例：类\r举个例子：\n1 2 3 class AppleTree: def dropApple(): print(\u0026#39;Apple dropped to the ground.\u0026#39;) AppleTree是将每个单词（第一个apple也不例外）首字母大写。\n","date":"2020-04-20T22:03:00+08:00","permalink":"https://goodcoder666.github.io/p/python-naming-standards/","title":"【Python】对象（包括类、函数）取名方法"},{"content":" 最近开始学习Java，使用经典的Eclipse IDE，结果发现下载太慢……\n问题分析\rEclipse的下载依赖于其他镜像，（在我这里）默认为朝鲜的镜像（可能在不同电脑中默认不同）：\n点击Select Another Mirror：\n选择中国的镜像：\n","date":"2020-04-10T19:48:00+08:00","permalink":"https://goodcoder666.github.io/p/eclipseinstmirrors/","title":"Eclipse安装包下载慢解决方法"},{"content":"最近想用流行的Java IDE —— Eclipse的Help -\u0026gt; Check For Updates更新Eclipse，结果总是说未找到更新：\n检查是否有更新\r首先，访问Eclipse下载地址获得最新版本（目前为2020-06）：\n再看看系统中的Eclipse版本（Help -\u0026gt; About Eclipse IDE）：\n如果网上版本和当前版本相等（像图中），那就System.exit(0);吧。。。别冤枉Eclipse了。。。\n有更新但检测不到解决\r打开“Available Software Sites”窗口：\n方法一：在提示窗口中，点击“available software sites”链接：\n方法二： 点击Window -\u0026gt; Prefrences -\u0026gt; Install/Update -\u0026gt; available software sites：\n找到Latest Eclipse Release，在红点处勾上，点击Apply and Close，重新检查更新即可。\n","date":"2020-04-08T22:12:00+08:00","permalink":"https://goodcoder666.github.io/p/eclipseupdmirror/","title":"Eclipse Check For Updates总是检查不到更新-解决方法"},{"content":"对于\u0026lt;\u0026lt;, \u0026gt;\u0026gt;两种运算符，可以这样说：\n$a\u003c","date":"2020-04-04T10:41:00+08:00","permalink":"https://goodcoder666.github.io/p/java-binmove/","title":"Java中的整数移位运算符"},{"content":"一、final类和方法\r英文文档\r原文：Java官方文档 -\u0026gt; Writing Final Classes and Methods\nYou can declare some or all of a class\u0026rsquo;s methods final. You use the final keyword in a method declaration to indicate that the method cannot be overridden by subclasses. The Object class does this—a number of its methods are final.\nYou might wish to make a method final if it has an implementation that should not be changed and it is critical to the consistent state of the object. For example, you might want to make the getFirstPlayer method in this ChessAlgorithm class final:\n1 2 3 4 5 6 7 8 class ChessAlgorithm { enum ChessPlayer { WHITE, BLACK } ... final ChessPlayer getFirstPlayer() { return ChessPlayer.WHITE; } ... } Methods called from constructors should generally be declared final. If a constructor calls a non-final method, a subclass may redefine that method with surprising or undesirable results.\nNote that you can also declare an entire class final. A class that is declared final cannot be subclassed. This is particularly useful, for example, when creating an immutable class like the String class.\n总结\r一个final的Java类或方法不能被继承。\n例子\r类（Integer源代码）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package java.lang; import java.lang.annotation.Native; // import ... import static java.lang.String.UTF16; public final class Integer extends Number // Final类不能被继承，但是可以extend或implement别的非final类 implements Comparable\u0026lt;Integer\u0026gt;, Constable, ConstantDesc { @Native public static final int MIN_VALUE = 0x80000000; @Native public static final int MAX_VALUE = 0x7fffffff; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static final Class\u0026lt;Integer\u0026gt; TYPE = (Class\u0026lt;Integer\u0026gt;) Class.getPrimitiveClass(\u0026#34;int\u0026#34;); // 此处省略n行 /** use serialVersionUID from JDK 1.0.2 for interoperability */ @Native private static final long serialVersionUID = 1360826667806852920L; } 方法：\n1 2 3 4 5 6 7 8 class ChessAlgorithm { enum ChessPlayer { WHITE, BLACK } // ... final ChessPlayer getFirstPlayer() { // 不能被继承，但是可以被调用 return ChessPlayer.WHITE; } // ... } 二、final属性/变量\rJava中的final属性或变量类似于C/C++中的const变量，不能改变。\n例子：\n1 2 3 4 5 6 7 8 9 public class Information { private static final int WIDTH = 170, HEIGHT = 135; // final属性，可以为private public static final int SIZE = WIDTH * HEIGHT; // 也可以为public public int getDifference() { final int difference = WIDTH - HEIGHT; // 函数中的final变量 return difference; } } ","date":"2020-04-01T14:40:00+08:00","permalink":"https://goodcoder666.github.io/p/java-final-syntax/","title":"java final关键字语法"},{"content":"最近在编一个Java游戏，处理图片时遇到如下问题：\n完整错误信息\r1 2 3 Exception in thread \u0026#34;AWT-EventQueue-0\u0026#34; java.lang.IllegalArgumentException: input == null! at java.desktop/javax.imageio.ImageIO.read(ImageIO.java:1356) at ImageIOTest.main.\u0026lt;init\u0026gt;(main.java:23) 代码片段\r1 BufferedImage img = ImageIO.read(getClass().getResourceAsStream(FILENAME)); 解决方法\r在网上搜了好多都是说图片路径不对，但是我已经把图片路径检查了$555n$遍了，还没发现问题\nso？没路了？\n其实改成这样就对了：\n1 BufferedImage img = ImageIO.read(new File(FILENAME)); ","date":"2020-03-29T17:39:00+08:00","permalink":"https://goodcoder666.github.io/p/java-image-iaein-solve/","title":"java.lang.IllegalArgumentException: input == null! 解决方法"},{"content":"问题\rtkinter.Text调用edit_undo()和edit_redo()没反应。\n问题分析\r这是因为没有设置Text的undo参数为True，设置后才能“激活”edit_undo()和edit_redo()。\n这个错误难发现是因为它没有报错，查了好多资料才发现……\n希望以后python官方能改进这点。\n解决方法\r1 2 3 4 5 6 7 8 9 10 11 12 from tkinter import * root = Tk() root.title(\u0026#39;Undo/redo test\u0026#39;) text = Text(root, undo=True) # ^^^^^^^^^ # 重要！ text.insert(END, \u0026#39;Hello tkinter!\u0026#39;) text.edit_undo() text.edit_redo() root.mainloop() ","date":"2020-03-24T19:37:00+08:00","permalink":"https://goodcoder666.github.io/p/tkinter-text-undo-redo/","title":"tkinter Text edit_undo()/edit_redo() 没反应解决方法"},{"content":"题目大意\r输入三个整数$a$，$b$，$c$，如果 $\\sqrt a + \\sqrt b \u003c \\sqrt c$ 成立，输出Yes，否则输出No。\n样例\r输入 #1\r1 2 3 9 输出 #1\r1 No $\\sqrt 2 + \\sqrt 3 \u003c \\sqrt 9$ 不成立。\n输入 #2\r1 2 3 10 输出 #2\r1 Yes $\\sqrt 2 + \\sqrt 3 \u003c \\sqrt 10$ 成立。\n分析\r错误思路\r首先，由于系统sqrt函数的浮点数精度误差，下面这个代码明显会WA:\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main(int argc, char** argv) { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); double d = sqrt(double(a)) + sqrt(double(b)); puts(d * d \u0026lt; c? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } 所以，这个题一定需要特殊思路！！！\n正确思路\r下面是正确方法的推导过程：\n$\\sqrt a + \\sqrt b \u003c \\sqrt c$\n$(\\sqrt a + \\sqrt b)^2 \u003c (\\sqrt c)^2$\n$a + b + 2\\sqrt ab \u003c c$\n$2\\sqrt ab \u003c c - a - b$\n$(2\\sqrt ab)^2 \u003c (c - a - b)^2$\n$4ab \u003c (c - a - b)^2$\n注意：还有一种情况，就是$c - a - b \u003c 0$或$c \u003c a + b$，答案应该是No。这种情况不考虑到会WA，因为$(c - a - b)^2$会“直接忽略负数”！\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { long long a, b, c; scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); long long d = c - a - b; if(d \u0026lt; 0) puts(\u0026#34;No\u0026#34;); // 特殊情况c - a - b \u0026lt; 0直接输出No else puts((d * d \u0026gt; 4LL * a * b)? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } ","date":"2020-03-16T14:17:00+08:00","permalink":"https://goodcoder666.github.io/p/panasonic2020-c/","title":"Panasonic Programming Contest 2020 C (Sqrt Inequality) 题解"},{"content":"一、*[参数名]\r调用\r合法调用\r普通调用\r*参数名一般写成*args, 如：\n1 2 def func(*args): print(args) 可以试着调用func：\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; func(1) (1,) \u0026gt;\u0026gt;\u0026gt; func() () \u0026gt;\u0026gt;\u0026gt; func(1, 2, 3) (1, 2, 3) \u0026gt;\u0026gt;\u0026gt; func(dict(), set(), str(), int()) ({}, set(), \u0026#39;\u0026#39;, 0) 所以，我们发现，这样的函数可以传任意个参数（包括0），*会把参数打包成一个tuple，如(1,) () (1, 2, 3) ({}, set(), '', 0)。\n特殊调用\r如果已经有一个tuple对象，想传进去作为args呢？\n首先定义一个tuple对象：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; tuple_object = (1, 2, 3) \u0026gt;\u0026gt;\u0026gt; print(tuple_object) (1, 2, 3) 错误方法\r一般想到的都是这样的方法：\n1 2 \u0026gt;\u0026gt;\u0026gt; func(tuple_object) ((1, 2, 3),) ((1, 2, 3),)? 不应该是(1, 2, 3)吗？\n因为系统把它识别为一个args中的参数，所以args就是“tuple中有tuple”，不对。OH NO!\n正确方法\r给tuple_object前面打个*，OK：\n1 2 \u0026gt;\u0026gt;\u0026gt; func(*tuple_object) (1, 2, 3) 这就是“解包”。\n非法调用\r如果调用func(a=1, b=2)呢？请看：\n1 \u0026gt;\u0026gt;\u0026gt; func(a=1, b=2) 得到TypeError:\n1 2 3 4 Traceback (most recent call last): File \u0026#34;\u0026lt;*args test file\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; func(a=1, b=2) TypeError: func() got an unexpected keyword argument \u0026#39;a\u0026#39; 错误中，keyword argument是什么？\nkeyword argument是像a=1 b=2 c='Hi'这样的传参形式。 简单地说，keyword argument就是name=value形式的传参。 所以，应该用value形式的传参（英文是positional argument），而不应该使用name=value的传参。\n默认参数\r*[参数名]的参数不能有默认参数：\n如上图，尝试设置默认参数会报SyntaxError，如果真要设置默认参数，应该用一种类似“手动设置默认值”的办法：\n1 2 3 4 5 6 # 手动设置*args的参数默认值 DEFAULT_VALUE = (1, 2, 3) # 默认值，可自行改变 def func(*args): if args == (): # 如果为空（用户没有传递参数）: args = DEFAULT_VALUE # 设为默认值 print(args) 这样，就有默认值了：\n1 2 \u0026gt;\u0026gt;\u0026gt; func() # 无参数调用 (1, 2, 3) 总结\r*[参数名]表示应使用value形式传参，参数个数不限，传入后会打包成tuple，供函数体使用。 特殊传参方法：*[tuple object] 这种方法不能设置默认值，只能用“手动设置默认值”。 二、**[参数名]\r调用\r合法调用\r普通调用\r**参数名一般写成**kwargs, 如：\n1 2 def func(**kwargs): # kwargs = keyword arguments print(kwargs) 然后调用func，但是这个跟上一个相反，必须是name=value式传参 （这也是为什么它叫kwargs (keyword arguments)）：\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; func(a=1, b=2, c=3, d=4) {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3, \u0026#39;d\u0026#39;: 4} \u0026gt;\u0026gt;\u0026gt; func(_tuple_obj=tuple(), _set_obj=set(), _dict_obj=dict()) {\u0026#39;_tuple_obj\u0026#39;: (), \u0026#39;_set_obj\u0026#39;: set(), \u0026#39;_dict_obj\u0026#39;: {}} \u0026gt;\u0026gt;\u0026gt; func() {} 这样的函数可以传任意个keyword argument（包括0），这里也与上一个相反，会把参数打包成一个dict，如{'a': 1, 'b': 2, 'c': 3, 'd': 4} {'_tuple_obj': (), '_set_obj': set(), '_dict_obj': {}} {}。\n特殊调用\r如果已经有一个dict对象，想传进去作为kwargs呢？\n首先定义一个这样的对象：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; dict_object = {\u0026#39;a\u0026#39;: 666, \u0026#39;b\u0026#39;: 888} \u0026gt;\u0026gt;\u0026gt; print(dict_object) {\u0026#39;a\u0026#39;: 666, \u0026#39;b\u0026#39;: 888} 然后，跟上次相似：\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; func(dict_object) # 因为不能传positional argument, 这下还报错了（马上会讲到）： Traceback (most recent call last): File \u0026#34;\u0026lt;**kwargs test program\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; func(dict_object) TypeError: func() takes 0 positional arguments but 1 was given \u0026gt;\u0026gt;\u0026gt; func(**dict_object) # 正确方法 {\u0026#39;a\u0026#39;: 666, \u0026#39;b\u0026#39;: 888} 非法调用\r如果传递positional argument呢？请看：\n1 \u0026gt;\u0026gt;\u0026gt; func(1, 2) 得到TypeError:\n1 2 3 4 Traceback (most recent call last): File \u0026#34;\u0026lt;**kwargs test program\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; func(1, 2) TypeError: func() takes 0 positional arguments but 2 were given 所以，这里应该用key=value形式的传参（英文是keyword argument），而不应该使用value的传参方法。\n默认参数\r与*args的方法类似，应该用手动设置默认值”的方法：\n1 2 3 4 5 6 # 手动设置**kwargs的参数默认值 DEFAULT_VALUE = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} # 默认值，可自行改变 def func(**kwargs): if kwargs == {}: # 如果为空（用户没有传递参数）: kwargs = DEFAULT_VALUE # 设为默认值 print(kwargs) 这样，就有默认值了：\n1 2 \u0026gt;\u0026gt;\u0026gt; func() # 无参数调用 {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} 总结\r**[参数名]表示应使用key=value形式传参，参数个数不限，传入后会打包成dict。 特殊传参方法：**[dict object] 这种方法不能设置默认值，也只能用“手动设置默认值”。 ","date":"2020-03-03T19:19:00+08:00","permalink":"https://goodcoder666.github.io/p/python-functions-argpack/","title":"Python函数之*[参数名]和**[参数名]的用处"},{"content":"A. Cow and Haybales\r题面\rThe USA Construction Operation (USACO) recently ordered Farmer John to arrange a row of n haybale piles on the farm. The $i$-th pile contains $a_i$ haybales.\nHowever, Farmer John has just left for vacation, leaving Bessie all on her own. Every day, Bessie the naughty cow can choose to move one haybale in any pile to an adjacent pile. Formally, in one day she can choose any two indices $i$ and $j$ ($1\\le i,j\\le n$) such that $|i−j|=1$ and $a_i \u003e 0$ and apply $a_i=a_i−1$, $a_j = a_j + 1$. She may also decide to not do anything on some days because she is lazy.\nBessie wants to maximize the number of haybales in pile $1$ (i.e. to maximize $a_1$), and she only has $d$ days to do so before Farmer John returns. Help her find the maximum number of haybales that may be in pile $1$ if she acts optimally!\n输入\rThe input consists of multiple test cases. The first line contains an integer $t$ ($1\\le t\\le 100$) — the number of test cases. Next $2t$ lines contain a description of test cases — two lines per test case.\nThe first line of each test case contains integers $n$ and $d$ ($1\\le n,d\\le 100$) — the number of haybale piles and the number of days, respectively.\nThe second line of each test case contains $n$ integers $a_1,a_2,\\dots,a_n$ $(0\\le a_i\\le 100)$ — the number of haybales in each pile.\n输出\rFor each test case, output one integer: the maximum number of haybales that may be in pile $1$ after $d$ days if Bessie acts optimally.\n样例\r输入\r1 2 3 4 5 6 7 3 4 5 1 0 3 2 2 2 100 1 1 8 0 输出\r1 2 3 3 101 0 注释\rIn the first test case of the sample, this is one possible way Bessie can end up with $3$ haybales in pile $1$:\nOn day one, move a haybale from pile $3$ to pile $2$ On day two, move a haybale from pile $3$ to pile $2$ On day three, move a haybale from pile $3$ to pile $1$ On day four, move a haybale from pile $2$ to pile $1$ On day five, do nothing In the second test case of the sample, Bessie can do nothing on the first day and move a haybale from pile $2$ to pile $1$ on the second day.\n解题思路\r贪心算法：先把第二堆的移到第一堆，再把第三堆的移到第一堆，……\n题目中的样例解释有点误导（:(）\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;cstdio\u0026gt; #define maxn 105 using namespace std; inline int min(int a, int b) { return a \u0026lt; b? a: b; } int main(int argc, char** argv) { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while(T--) { int n, d, first; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;d, \u0026amp;first); for(int i=1; i\u0026lt;n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if(d \u0026gt;= i) { int num = min(d / i, x); // The max number of haybales bessie can take to pile 1 d -= num * i; first += num; } } printf(\u0026#34;%d\\n\u0026#34;, first); } return 0; } B. Cow and Friend\r题面\rBessie has way too many friends because she is everyone\u0026rsquo;s favorite cow! Her new friend Rabbit is trying to hop over so they can play!\nMore specifically, he wants to get from $(0,0)$ to $(x,0)$ by making multiple hops. He is only willing to hop from one point to another point on the 2D plane if the Euclidean distance between the endpoints of a hop is one of its n favorite numbers: $a_1,a_2,…,a_n$. What is the minimum number of hops Rabbit needs to get from $(0,0)$ to $(x,0)$? Rabbit may land on points with non-integer coordinates. It can be proved that Rabbit can always reach his destination.\nRecall that the Euclidean distance between points $(x_i,y_i)$ and $(x_j,y_j)$ is $\\sqrt{(x_i−x_j)^2+(y_i−y_j)^2}$.\nFor example, if Rabbit has favorite numbers 1 and 3 he could hop from $(0,0)$ to $(4,0)$ in two hops as shown below. Note that there also exists other valid ways to hop to $(4,0)$ in $2$ hops (e.g. $(0,0)\\to(2, \\sqrt 5)\\to(4,0)$).\nHere is a graphic for the first example. Both hops have distance $3$, one of Rabbit\u0026rsquo;s favorite numbers.\nIn other words, each time Rabbit chooses some number $a_i$ and hops with distance equal to $a_i$ in any direction he wants. The same number can be used multiple times.\n输入\rThe input consists of multiple test cases. The first line contains an integer $t$ ($1\\le t\\le 1000$) — the number of test cases. Next $2t$ lines contain test cases — two lines per test case.\nThe first line of each test case contains two integers $n$ and $x$ ($1\\le n\\le 10^5$, $1\\le x\\le 10^9$) — the number of favorite numbers and the distance Rabbit wants to travel, respectively.\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1\\le a_i \\le 10^9$) — Rabbit\u0026rsquo;s favorite numbers. It is guaranteed that the favorite numbers are distinct.\nIt is guaranteed that the sum of $n$ over all the test cases will not exceed $10^5$.\n输出\rFor each test case, print a single integer — the minimum number of hops needed.\n样例\r输入\r1 2 3 4 5 6 7 8 9 4 2 4 1 3 3 12 3 4 5 1 5 5 2 10 15 4 输出\r1 2 3 4 2 3 1 2 注释\rThe first test case of the sample is shown in the picture above. Rabbit can hop to $(2, \\sqrt 5)$, then to $(4,0)$ for a total of two hops. Each hop has a distance of $3$, which is one of his favorite numbers.\nIn the second test case of the sample, one way for Rabbit to hop $3$ times is: $(0,0) → (4,0) → (8,0) → (12,0)$.\nIn the third test case of the sample, Rabbit can hop from $(0,0)$ to $(5,0)$.\nIn the fourth test case of the sample, Rabbit can hop: $(0,0) → (5,10\\sqrt2) → (10,0)$.\n解题思路\r纯数学！！！\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 using namespace std; int fav[maxn], n, d; int calc(int x) { int tm = d / x, leftdist = d % x; if(leftdist == 0) return tm; if(tm == 0) { for(int i=0; i\u0026lt;n; i++) if(fav[i] == leftdist) return 1; return 2; } return tm + 1; } int main(int argc, char** argv) { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while(T--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;d); int maxf = -1; for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d\u0026#34;, fav + i); if(fav[i] \u0026gt; maxf) maxf = fav[i]; } printf(\u0026#34;%d\\n\u0026#34;, calc(maxf)); } return 0; } C. Cow and Message\r题面\rBessie the cow has just intercepted a text that Farmer John sent to Burger Queen! However, Bessie is sure that there is a secret message hidden inside.\nThe text is a string $S$ of lowercase Latin letters. She considers a string $t$ as hidden in string $S$ if $t$ exists as a subsequence of $S$ whose indices form an arithmetic progression. For example, the string aab is hidden in string aaabb because it occurs at indices $1$, $3$, and $5$, which form an arithmetic progression with a common difference of $2$. Bessie thinks that any hidden string that occurs the most times is the secret message. Two occurrences of a subsequence of $S$ are distinct if the sets of indices are different. Help her find the number of occurrences of the secret message!\nFor example, in the string aaabb, a is hidden $3$ times, b is hidden $2$ times, ab is hidden $6$ times, aa is hidden $3$ times, bb is hidden $1$ time, aab is hidden $2$ times, aaa is hidden $1$ time, abb is hidden $1$ time, aaab is hidden $1$ time, aabb is hidden $1$ time, and aaabb is hidden $1$ time. The number of occurrences of the secret message is $6$.\n输入\rThe first line contains a string $S$ of lowercase Latin letters ($1\\le |S|\\le 105$) — the text that Bessie intercepted.\n输出\rOutput a single integer — the number of occurrences of the secret message.\n样例\r输入 #1\r1 aaabb 输出 #1\r1 6 输入 #2\r1 usaco 输出 #2\r1 1 输入 #3\r1 lol 输出 #3\r1 2 注释\rIn the first example, these are all the hidden strings and their indice sets:\na occurs at $(1), (2), (3)$ b occurs at $(4), (5)$ ab occurs at $(1,4), (1,5), (2,4), (2,5), (3,4), (3,5)$ aa occurs at $(1,2), (1,3), (2,3)$ bb occurs at $(4,5)$ aab occurs at $(1,3,5), (2,3,4)$ aaa occurs at $(1,2,3)$ abb occurs at $(3,4,5)$ aaab occurs at $(1,2,3,4)$ aabb occurs at $(2,3,4,5)$ aaabb occurs at $(1,2,3,4,5)$\nNote that all the sets of indices are arithmetic progressions.\nIn the second example, no hidden string occurs more than once. In the third example, the hidden string is the letter l.\n解题思路\r动态规划\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 #define let 26 using namespace std; typedef long long LL; char s[maxn], c; LL cnt1[let][maxn], cnt2[let][let]; int main(int argc, char** argv) { cnt1[(s[0] = getchar()) - \u0026#39;a\u0026#39;][0] ++; int slen = 1; while((c = getchar()) != \u0026#39;\\n\u0026#39;) { s[slen] = c; for(int i=0; i\u0026lt;let; i++) cnt1[i][slen] = cnt1[i][slen - 1]; cnt1[c - \u0026#39;a\u0026#39;][slen++] ++; } int last = slen - 1; for(int i=0; i\u0026lt;let; i++) if(cnt1[i][last]) { cnt2[i][i] = cnt1[i][last] * (cnt1[i][last] - 1) \u0026gt;\u0026gt; 1; for(int j=0; j\u0026lt;slen; j++) if(s[j] != i + \u0026#39;a\u0026#39;) cnt2[i][s[j] - \u0026#39;a\u0026#39;] += cnt1[i][last] - cnt1[i][j]; } LL maxcnt = -1; for(int i=0; i\u0026lt;let; i++) { if(cnt1[i][last] \u0026amp;\u0026amp; cnt1[i][last] \u0026gt; maxcnt) maxcnt = cnt1[i][last]; for(int j=0; j\u0026lt;let; j++) if(cnt2[i][j] \u0026amp;\u0026amp; cnt2[i][j] \u0026gt; maxcnt) maxcnt = cnt2[i][j]; } printf(\u0026#34;%lld\\n\u0026#34;, maxcnt); return 0; } ","date":"2020-02-22T23:20:00+08:00","permalink":"https://goodcoder666.github.io/p/cf1307/","title":"CodeForces Round #621 ABC (1307A+1307B+1307C) 题解"},{"content":" 产生 $[0,1)$ 之间的随机实数，即 $0\\le\\text{Math.random()} \u003c 1$ 1 2 3 4 5 Math.random() // 返回值样例： // #1：0.60958701902852 // #2：0.16182155144292465 // #3：0.30126821448898133 随机产生 $[0, n]$ 之间的整数 1 2 3 4 5 6 7 8 9 10 11 function randint1(n) { // 各数产生概率较平均 return Math.round(Math.random() * n); } function randint2(n) { // 不可能出现n return Math.floor(Math.random() * n); } function randint3(n) { // 0的概率极小，与Math.random()产生0的概率相同 return Math.ceil(Math.random() * n); } 产生 $[0, n]$ 之间的随机一位小数 1 2 3 4 // 可能有浮点数精度误差，如：0.30000000000000004，0.7999999999999999 function randf(n) { return Math.round(Math.random() * n * 10) / 10; } ","date":"2020-02-09T20:01:00+08:00","permalink":"https://goodcoder666.github.io/p/js-random/","title":"js产生随机数"},{"content":"完整错误\r1 2 3 4 5 jsEnginScriptError: Component is not found in path \u0026#34;components/comp/comp.js\u0026#34; (using by pages/index/index); onAppRoute Error: Component is not found in path \u0026#34;components/comp/comp.js\u0026#34; (using by pages/index/index) in e(...) ... 错误代码（json）\r1 2 3 4 5 6 7 8 9 { \u0026#34;backgroundTextStyle\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;navigationBarBackgroundColor\u0026#34;: \u0026#34;#fff\u0026#34;, \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;WeApp\u0026#34;, \u0026#34;navigationBarTextStyle\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;usingComponents\u0026#34;: { \u0026#34;MyComp\u0026#34;: \u0026#34;../../components/comp/comp.js\u0026#34; } } 解决\r去掉.js, 改为../../components/comp/comp：\n1 2 3 4 5 6 7 8 { \u0026#34;backgroundTextStyle\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;navigationBarBackgroundColor\u0026#34;: \u0026#34;#fff\u0026#34;, \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;WeApp\u0026#34;, \u0026#34;navigationBarTextStyle\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;usingComponents\u0026#34;: { \u0026#34;MyComp\u0026#34;: \u0026#34;../../components/comp/comp\u0026#34; } ","date":"2020-02-05T12:26:00+08:00","permalink":"https://goodcoder666.github.io/p/wmp-component-not-found/","title":"微信小程序报错：Component is not found in path \u0026quot;components/comp/comp.js\u0026quot;"},{"content":"Collection.orderBy / Query.orderBy\n指定查询排序条件\n方法签名如下：\n1 function orderBy(fieldName: string, order: string): Collection | Query 方法接受一个必填字符串参数fieldName用于定义需要排序的字段，一个字符串参数order定义排序顺序。order只能取asc或desc。\n如果需要对嵌套字段排序，需要用 \u0026ldquo;点表示法\u0026rdquo; 连接嵌套字段，比如style.color表示字段style里的嵌套字段color。\n同时也支持按多个字段排序，多次调用orderBy即可，多字段排序时的顺序会按照orderBy调用顺序先后对多个字段排序\n示例代码：\n按一个字段排序：按进度排升序取待办事项 1 2 3 4 5 const db = wx.cloud.database() db.collection(\u0026#39;todos\u0026#39;).orderBy(\u0026#39;progress\u0026#39;, \u0026#39;asc\u0026#39;) .get() .then(console.log) .catch(console.error) 按多个字段排序：\n先按progress排降序（progress越大越靠前）、再按description排升序（字母序越前越靠前）取待办事项： 1 2 3 4 5 6 7 const db = wx.cloud.database() db.collection(\u0026#39;todos\u0026#39;) .orderBy(\u0026#39;progress\u0026#39;, \u0026#39;desc\u0026#39;) .orderBy(\u0026#39;description\u0026#39;, \u0026#39;asc\u0026#39;) .get() .then(console.log) .catch(console.error) 原文：微信官方文档 · 小程序 -\u0026gt; 云开发 -\u0026gt; 数据库 -\u0026gt; Collection.orderBy / Query.orderBy\n","date":"2020-02-04T15:53:00+08:00","permalink":"https://goodcoder666.github.io/p/wmp-cloud-orderby/","title":"微信小程序 云数据库 Collection/Query .orderBy 用法"},{"content":"因为仅有onPullDownRefresh是不行的，需要配置：\r如果是单个页面需要onPullDownRefresh，在对应页面的json文件中设置\u0026quot;enablePullDownRefresh\u0026quot;: true，如： 1 2 3 4 5 6 7 { \u0026#34;backgroundTextStyle\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;navigationBarBackgroundColor\u0026#34;: \u0026#34;#fff\u0026#34;, \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;演示页面\u0026#34;, \u0026#34;navigationBarTextStyle\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;enablePullDownRefresh\u0026#34;: true } 如果每个页面都需要onPullDownRefresh，可以给每个页面都设置\u0026quot;enablePullDownRefresh\u0026quot;: true，也可以在app.json中设置: 1 2 3 4 5 6 { ... window: { \u0026#34;enablePullDownRefresh\u0026#34;: true } } ","date":"2020-02-04T13:10:00+08:00","permalink":"https://goodcoder666.github.io/p/wmp-enable-onpulldownrefresh/","title":"为什么微信小程序设置的onPullDownRefresh无效"},{"content":"报错：\r1 -501007 invalid parameters | errMsg: Invalid Key Name: _openid 原因：\r不能设置_openid，它是云服务器根据用户的openID自动设置的\n解决：\r不要设置openID\n错误代码\r1 2 3 4 5 6 7 8 wx.cloud.database().collection(\u0026#39;people\u0026#39;).add({ data: { \u0026#39;_openid\u0026#39;: openID, \u0026#39;name\u0026#39;: nickName, \u0026#39;avatarUrl\u0026#39;: avatarUrl, \u0026#39;score\u0026#39;: score } }) 正确代码\r1 2 3 4 5 6 7 wx.cloud.database().collection(\u0026#39;people\u0026#39;).add({ data: { \u0026#39;name\u0026#39;: nickName, \u0026#39;avatarUrl\u0026#39;: avatarUrl, \u0026#39;score\u0026#39;: score } }) ","date":"2020-02-03T21:07:00+08:00","permalink":"https://goodcoder666.github.io/p/wmp-cloud-invalidkey-openid/","title":"微信小程序-云开发-数据库 报错：-501007 invalid parameters | errMsg: Invalid Key Name: _openid"},{"content":" 如未开通云开发，请看这篇\n基础库版本需为2.3.3以上，建议设为最新版本\n新建云函数：\n右击cloudfunctions，选择新建Node.js云函数\n输入login\n现在云开发控制台的样子：\n此函数会保存openID至本地存储，并在出错时调用error：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function saveOpenID(error) { if (!wx.getStorageSync(\u0026#39;openID\u0026#39;)) { wx.cloud.callFunction({ name: \u0026#39;login\u0026#39;, data: {}, success: res =\u0026gt; { console.log(\u0026#39;Got user openid: \u0026#39;, res.result.openid) wx.setStorageSync(\u0026#39;openID\u0026#39;, res.result.openid) }, fail: err =\u0026gt; { console.error(err) error() } }) } } ","date":"2020-02-03T17:57:00+08:00","permalink":"https://goodcoder666.github.io/p/wmp-cloud-getopenid/","title":"使用云函数获取小程序用户openId"},{"content":" 1 2 3 4 5 6 wx.showToast({ title: \u0026#39;成功\u0026#39;, icon: \u0026#39;fail\u0026#39;, duration: 2000, success: func }) 1 2 3 4 5 6 7 8 wx.showToast({ title: \u0026#39;成功\u0026#39;, icon: \u0026#39;fail\u0026#39;, duration: 2000, success: res =\u0026gt; { func() } }) 使用以上两种语句都会“马上”执行func, WHY?\r因为只要成功弹出了窗口就会调用success, 所以如果要在duration毫秒后执行func, 代码如下：\n1 2 3 4 5 6 wx.showToast({ title: \u0026#39;成功\u0026#39;, icon: \u0026#39;fail\u0026#39;, duration: 2000, }) setTimeout(func, 2000) ","date":"2020-02-02T15:43:00+08:00","permalink":"https://goodcoder666.github.io/p/wx-showtoast-problem/","title":"wx.showToast中的一个问题"},{"content":"错误\r1 2 3 4 5 Uncaught (in promise) thirdScriptError errCode: -401003 api parameter type error | errMsg: parameter.data should be object instead of undefined; Error: errCode: -401003 api parameter type error | errMsg: parameter.data should be object instead of undefined; at new u (...) ... 错误原因\r错误写法\r1 2 3 4 5 6 7 8 9 10 11 12 wx.cloud.init({ env: \u0026#39;我的云ID\u0026#39;, traceUser: true }) const db = wx.cloud.database() const people = db.collection(\u0026#39;people\u0026#39;) people.add({ // \u0026lt;- 报错 \u0026#39;name\u0026#39;: \u0026#39;OnePerson\u0026#39;, \u0026#39;score\u0026#39;: 15 }) 正确写法\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 wx.cloud.init({ env: \u0026#39;我的云ID\u0026#39;, traceUser: true }) const db = wx.cloud.database() const people = db.collection(\u0026#39;people\u0026#39;) people.add({ data: { // 必须加上data! \u0026#39;name\u0026#39;: \u0026#39;OnePerson\u0026#39;, \u0026#39;score\u0026#39;: 15 } }) ","date":"2020-02-02T11:17:00+08:00","permalink":"https://goodcoder666.github.io/p/wmp-cloud-errcode-401003/","title":"使用微信小程序-云开发时报错: Error: errCode: -401003 api parameter type error | errMsg: parameter.data should ..."},{"content":" 1 2 Date.now() // 获取1970.1.1到当前的毫秒数 Date.UTC(2000, 1, 1) // 获取1970.1.1到2000.1.1的毫秒数 ","date":"2020-01-31T17:06:00+08:00","permalink":"https://goodcoder666.github.io/p/js-utc/","title":"js获取1970.1.1到当前的毫秒数"},{"content":"为什么要自制键盘？\r我最近在开发一款微信小程序，现在需要用户输入一个数字。\n使用系统键盘带来的不便\r如果使用系统键盘，有以下几个问题：\n数字键太小，不方便； 无法阻止用户输入不合法字符（如：“\u0026amp;”）； 小数点在一些手机上很难找到； 用户需要点击输入框； 无法控制按钮样式。 理想的自制键盘效果\r123\n456\n789\n.0提交\n退格清空\n怎样自制键盘？\r把每一行按钮捆绑成一个view:\nWXML\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!--pages/a/a.wxml--\u0026gt; \u0026lt;!--输入键盘--\u0026gt; \u0026lt;!--五行，每行一个view--\u0026gt; \u0026lt;view class=\u0026#39;keyboard-row\u0026#39;\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;one\u0026#39; data-key=\u0026#39;1\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;1\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;two\u0026#39; data-key=\u0026#39;2\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;2\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;three\u0026#39; data-key=\u0026#39;3\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;3\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#39;keyboard-row\u0026#39;\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;four\u0026#39; data-key=\u0026#39;4\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;4\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;five\u0026#39; data-key=\u0026#39;5\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;5\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;six\u0026#39; data-key=\u0026#39;6\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;6\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#39;keyboard-row\u0026#39;\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;seven\u0026#39; data-key=\u0026#39;7\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;7\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;eight\u0026#39; data-key=\u0026#39;8\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;8\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;nine\u0026#39; data-key=\u0026#39;9\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;9\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#39;keyboard-row\u0026#39;\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;dot\u0026#39; data-key=\u0026#39;.\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;.\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;zero\u0026#39; data-key=\u0026#39;0\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;0\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;submit\u0026#39; bindtap=\u0026#39;tapSubmit\u0026#39;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;!--clear\u0026amp;delete--\u0026gt; \u0026lt;view class=\u0026#39;keyboard-row\u0026#39;\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;del\u0026#39; bindtap=\u0026#39;tapDel\u0026#39;\u0026gt;退格\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;clear\u0026#39; bindtap=\u0026#39;tapClear\u0026#39;\u0026gt;清除\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; WXSS\n1 2 3 4 5 6 7 8 9 10 /*pages/a/a.wxss*/ .keyboard-row { width: 100%; height: 35%; border-radius: 98rpx; display: flex; flex-direction: row; align-items: center; justify-content: center; } JS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // pages/a/a.js Page({ data: { num: 0, hasDot: false // 防止用户多次输入小数点 }, tapKey: function(evt) { var x = evt.currentTarget.dataset.key if(x == \u0026#39;.\u0026#39;) { if(this.data.hasDot) return this.setData({ hasDot: true }) } this.setData({ num: this.data.num == \u0026#39;0\u0026#39;? x: this.data.num + x }) }, tapSubmit: function() { // 用户已提交 console.log(\u0026#39;res =\u0026#39;, this.data.num) }, tapDel: function() { if(this.data.num == \u0026#39;0\u0026#39;) return if(this.data.num[this.data.num.length - 1] == \u0026#39;.\u0026#39;) this.setData({ hasDot: false }) this.setData({ num: this.data.num.length == 1? \u0026#39;0\u0026#39;: this.data.num.substring(0, this.data.num.length - 1) }) }, tapClear: function() { this.setData({ num: \u0026#39;0\u0026#39;, hasDot: false }) } }) 键盘的效果\r","date":"2020-01-31T10:30:00+08:00","permalink":"https://goodcoder666.github.io/p/wmp-diy-nkeyboard/","title":"在微信小程序中做自己的数字键盘"}]