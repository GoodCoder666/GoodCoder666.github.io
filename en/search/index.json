[{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Preface\rWolfram Mathematica (abbreviated as MMA) is a scientific computing software developed by Wolfram Research. This article introduces Mathematica\u0026rsquo;s interface, syntax, and basic applications. Similar software includes MATLAB and Maple.\nOfficial MMA website: https://www.wolfram.com/mathematica/\nInstallation and activation guide: Mathematica Installation and Activation Tutorial - ÁßëÁ†îÂ∞èÈ£û (Zhihu)\nThis article is suitable for readers with basic programming knowledge. However, you can skip programming-related sections if needed. All screenshots are taken from Windows 11, Mathematica 13.3. (The latest version 14.0 was released in December 2023 with backward compatibility)\nInterface\rAfter installation and activation, create a new notebook to see the following interface:\nQuick overview of MMA interface:\nKey points:\nEnter creates new lines; use Shift+Enter to execute code. The red triangle on the left palette also executes code; the gray square stops computations. MMA\u0026rsquo;s Notebook feature is primarily for computation rather than note-taking. Refer to official documentation for details. Use Ctrl+Shift+I to show input form (code) and Ctrl+Shift+N for mathematical form. Detailed explanations follow.\nSyntax\rMathematica is essentially a Wolfram Language (WL) interpreter. Let\u0026rsquo;s explore basic syntax and common commands.\nHelp Documentation\rQuery function documentation using ? Solve:\nThe ? operator displays brief help for any function. Click the i icon for detailed documentation (prioritizes offline docs, falls back to online docs). Access full documentation via Help -\u0026gt; Wolfram Documentation.\nComments\r1 (* Comment *) Comments use (* and *), similar to C/C++ /* */. Examples:\n1 2 1 + 1 (*Hello*) 1 + (*World*)1 Both lines execute as 1 + 1:\nBrackets\rMaster bracket usage before learning functions!\nOfficial reference: Using Brackets and Braces Correctly\nFour bracket types in MMA:\nParentheses ()\rGroup expressions and set operation precedence:\nSquare Brackets []\rFunction calls and parameters:\nCurly Braces {}\rCreate lists:\nList operations will be explained later.\nDouble Brackets [[]]\rAccess list elements (shorthand for Part function):\nOperations and Expressions\rMMA supports basic mathematical operations:\nName Symbol Function Form Math Form Addition a + b Plus[a, b] $a+b$ Subtraction a - b Subtract[a, b] $a-b$ Multiplication a * b1 Times[a, b] $a\\times b$ Division a / b Divide[a, b] $\\frac ab$ Power a ^ b Power[a, b] $a^b$ Modulo - Mod[a, b] $a\\bmod b$ Examples with numbers and symbols:\nExpressions combine operations/function calls. MMA automatically reduces fractions and combines like terms but doesn\u0026rsquo;t expand expressions. Use Simplify or FullSimplify:\nBoolean Expressions\rComparisons return True/False:\nUse == for equality checks. Single = assigns variables.\nUse \u0026amp;\u0026amp; for AND and || for OR. Simplify with Simplify, FullSimplify, or solve with Solve/Reduce:\nVariables and Constants\rDeclare variables with variable = value:\nAll declared variables in expressions get substituted. Variables can reference other variables:\nUse Clear[variable] to unset variables:\nBuilt-in constants:\nConstant Name Approx. Value Math Form Pi Pi 3.141592654 $\\pi$ E Euler\u0026rsquo;s number 2.718281828 $\\mathrm e$ I Imaginary unit - $i$ Infinity Infinity - $\\infty$ Degree Degree - $\\degree$ Functions\rInvocation\rCall functions using FunctionName[param1, param2, ...]:\nSingle-parameter functions can use postfix notation param // FunctionName:\nSupports chaining:\nDefinition\rDefine functions with FunctionName[param1_, param2_, ...] := returnValue. Each parameter requires trailing underscore:\nExtension - Recursive Functions\nFibonacci sequence example:\nBuilt-in Functions\rMMA has nearly 6000 built-in functions2. Common ones include:\nNumerical Evaluation N\rN[expr]: Numerical value N[expr, n]: n-digit precision Trigonometric Functions\rAll trigonometric functions use radians. Add Degree for angles:\nEquation Solving Solve/Reduce\rSolve equations with Solve:\nSolve inequalities with Reduce:\nReduce handles complex expressions:\nAlternative Solvers NSolve/FindInstance\rNSolve: Numerical solutions FindInstance: Find specific solution instances Optimization Maximize/Minimize\rMinimize finds minima with conditions:\nMaximize works similarly.\nDifferentiation D\rD[f, x]: First derivative D[f, {x, n}]: nth derivative f'[x]: Shorthand Integration Integrate\rIntegrate[f, x]: Indefinite integral Integrate[f, {x, min, max}]: Definite integral Multiple integrals supported Expansion Expand/ExpandAll\rExpand: Expands products and powers ExpandAll: Expands nested expressions Factorization Factor\rFactor[poly]: Factor polynomials over integers.\nPlotting Plot/Plot3D\rBasic plotting examples:\nConclusion\rWhen learning MMA, I struggled with fragmented tutorials online. This guide consolidates essential syntax and common pitfalls into one resource. Originally intended as a concise tutorial, it grew to 8000+ characters. Thanks for reading!\nFuture articles may explore Mathematica applications in mathematics and real-world problems. Stay tuned!\nMultiplication can be written as a b (with space). Most spaces are optional in MMA, but multiplication spaces are mandatory (ab would be a single variable).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.wolfram.com/language/fast-introduction-for-programmers/en/built-in-functions/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-01-26T17:12:00+08:00","permalink":"https://goodcoder666.github.io/en/p/mathematica-intro/","title":"Getting Started with Mathematica"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Christmas Present\rProblem Summary\rGiven two positive integers $B,G$ ($1\\le B,G\\le 1000$ and $B\\ne G$), determine which is larger.\nAnalysis\rJust simulate.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int b, g; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;b, \u0026amp;g); puts(b \u0026gt; g? \u0026#34;Bat\u0026#34;: \u0026#34;Glove\u0026#34;); return 0; } B - Christmas Trees\rProblem Summary\rGiven $A,M,L,R$.\nFor any integer $k$, Snuke places a Christmas tree at position $A+kM$ on the number line.\nFind the number of trees in the interval $[L,R]$.\n$-10^{18}\\le A\\le 10^{18}$\n$1\\le M\\le 10^9$\n$-10^{18}\\le L\\le R\\le 10^{18}$\nAnalysis\rNotice that for any integer $x$, there\u0026rsquo;s a tree at $x$ if and only if $x \\equiv A \\ (\\bmod \\ M)$. This can be transformed to $(x-A) \\mid M$. Therefore, shift coordinates by $A$ and count multiples of $M$ in $[L-A, R-A]$.\nCode\rNote the handling of negative numbers in C++.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;cstdio\u0026gt; using namespace std; using LL = long long; int main() { LL a, l, r; int m; scanf(\u0026#34;%lld%d%lld%lld\u0026#34;, \u0026amp;a, \u0026amp;m, \u0026amp;l, \u0026amp;r); l -= a, r -= a; if(l \u0026lt; 0) l = -((-l) / m * m); else l = (l + m - 1) / m * m; if(r \u0026lt; 0) r = -((-r + m - 1) / m * m); else r = r / m * m; printf(\u0026#34;%lld\\n\u0026#34;, (r - l) / m + 1); return 0; } C - Socks 2\rProblem Summary\rGiven a sequence $S=(1,1,2,2,\\dots,N,N)$ of length $2N$.\nRemove one occurrence of each $A_1,\\dots,A_K$ from $S$, leaving $2N-K$ numbers.\nPair these remaining numbers (possibly with one unpaired) to minimize the sum of absolute differences. Output this minimum sum.\n$1\\le K\\le N\\le 2\\times 10^5$\n$1\\le A_1 \u003c A_2 \u003c \\dots \u003c A_K\\le N$\nAnalysis\rThe $N-K$ complete pairs can be optimally matched as self-pairs. The remaining $K$ single elements must be paired optimally.\nFor even $K$, pair adjacent elements. For odd $K$, precompute prefix and suffix sums to efficiently find the optimal single element to exclude.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; inline void setmin(int\u0026amp; x, int y) { if(y \u0026lt; x) x = y; } int a[maxn], pre[maxn], suf[maxn]; int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=1; i\u0026lt;=k; i++) scanf(\u0026#34;%d\u0026#34;, a + i); if(!(k \u0026amp; 1)) { int ans = 0; for(int i=1; i\u0026lt;=k; i+=2) ans += a[i + 1] - a[i]; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } for(int i=1; i\u0026lt;k; i+=2) pre[i] = pre[i + 1] = pre[i - 1] + a[i + 1] - a[i]; for(int i=k-1; i\u0026gt;0; i-=2) suf[i] = suf[i + 1] = suf[i + 2] + a[i + 1] - a[i]; int ans = 1e9; for(int i=1; i\u0026lt;=k; i++) { int cur = i \u0026amp; 1? pre[i - 1] + suf[i + 1] : a[i + 1] - a[i - 1] + pre[i - 2] + suf[i + 2]; setmin(ans, cur); } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Reindeer and Sleigh\rProblem Summary\rGiven $N$ sleighs with reindeer requirements $R_i$ and $Q$ queries, each asking the maximum number of sleighs that can be pulled with $X$ reindeer.\nAnalysis\rSort $R_i$ and compute prefix sums. For each query, use binary search to find the largest prefix sum ‚â§ $X$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 200005 using namespace std; using LL = long long; LL s[maxn]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%lld\u0026#34;, s + i); sort(s, s + n); for(int i=1; i\u0026lt;n; i++) s[i] += s[i - 1]; while(q--) { LL x; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); printf(\u0026#34;%d\\n\u0026#34;, int(upper_bound(s, s + n, x) - s)); } return 0; } E - Christmas Color Grid 1\rProblem Summary\rA grid has red (.) and green (#) cells. Randomly paint one red cell green and compute the expected number of green connected components modulo 998244353.\nAnalysis\rUse Union-Find to precompute green components. For each red cell, count adjacent distinct green components. The contribution to the expectation is the original count minus (adjacent components - 1).\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;atcoder/modint\u0026gt; #define maxn 1005 using namespace std; using modint = atcoder::modint998244353; int n, m, fa[maxn * maxn]; char s[maxn][maxn]; int find(int x) { return fa[x] == x? fa[x]: fa[x] = find(fa[x]); } inline int calc(int x, int y) { return x * m + y; } inline int fc(int x, int y) { return find(calc(x, y)); } inline void merge(int x, int y) { fa[find(x)] = find(y); } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%s\u0026#34;, s[i]); int k = n * m; for(int i=0; i\u0026lt;k; i++) fa[i] = i; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;m; j++) { if(s[i][j] != \u0026#39;#\u0026#39;) continue; if(i \u0026amp;\u0026amp; s[i - 1][j] == \u0026#39;#\u0026#39;) merge(calc(i, j), calc(i - 1, j)); if(j \u0026amp;\u0026amp; s[i][j - 1] == \u0026#39;#\u0026#39;) merge(calc(i, j), calc(i, j - 1)); } int cnt = 0, tot = 0; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;m; j++) if(s[i][j] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; fc(i, j) == calc(i, j)) cnt ++; modint ans = 0; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;m; j++) if(s[i][j] == \u0026#39;.\u0026#39;) { set\u0026lt;int\u0026gt; S; if(i \u0026amp;\u0026amp; s[i - 1][j] == \u0026#39;#\u0026#39;) S.insert(fc(i - 1, j)); if(s[i + 1][j] == \u0026#39;#\u0026#39;) S.insert(fc(i + 1, j)); if(j \u0026amp;\u0026amp; s[i][j - 1] == \u0026#39;#\u0026#39;) S.insert(fc(i, j - 1)); if(s[i][j + 1] == \u0026#39;#\u0026#39;) S.insert(fc(i, j + 1)); int cur = cnt - (int)S.size() + 1; ans += cur, tot ++; } printf(\u0026#34;%d\\n\u0026#34;, (ans / tot).val()); return 0; } F - Christmas Present 2\rProblem Summary\rSanta delivers gifts in sequence, carrying up to $K$ gifts. Find the minimal travel distance starting and ending at home.\nAnalysis\rDynamic programming optimized with a deque and prefix sums. Maintain the minimal distance for each possible remaining gift count.\nCode\rImplementation 1: deque + multiset\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 200005 using namespace std; using ld = long double; const ld INF = 2e18l; int x[maxn], y[maxn]; inline ld dis(int i, int j) { return __builtin_hypotl(x[i] - x[j], y[i] - y[j]); } int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;=n; i++) scanf(\u0026#34;%d%d\u0026#34;, x + i, y + i); deque\u0026lt;ld\u0026gt; f; multiset\u0026lt;ld\u0026gt; s; k --; for(int i=0; i\u0026lt;k; i++) f.push_back(INF), s.insert(INF); f.push_back(dis(0, 1)), s.insert(dis(0, 1)); ld dt = 0; for(int i=2; i\u0026lt;=n; i++) { ld lt = *s.begin() + dis(i - 1, 0) + dis(0, i) + dt; s.erase(s.find(f.front())), f.pop_front(); dt += dis(i - 1, i), lt -= dt; f.push_back(lt), s.insert(lt); } printf(\u0026#34;%.15Lf\\n\u0026#34;, dt + *s.begin() + dis(n, 0)); return 0; } Implementation 2: Monotonic Queue\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;deque\u0026gt; #define maxn 200005 using namespace std; int x[maxn], y[maxn]; inline double dis(int i, int j) { return __builtin_hypotl(x[i] - x[j], y[i] - y[j]); } int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;=n; i++) scanf(\u0026#34;%d%d\u0026#34;, x + i, y + i); deque\u0026lt;pair\u0026lt;double, int\u0026gt;\u0026gt; f; f.emplace_back(dis(0, 1), 1); double dt = 0; for(int i=2; i\u0026lt;=n; i++) { double lt = f.front().first + dis(i - 1, 0) + dis(0, i) + dt; if(f.front().second == i - k) f.pop_front(); dt += dis(i - 1, i), lt -= dt; while(!f.empty() \u0026amp;\u0026amp; f.back().first \u0026gt;= lt) f.pop_back(); f.emplace_back(lt, i); } printf(\u0026#34;%.15lf\\n\u0026#34;, dt + f.front().first + dis(n, 0)); return 0; } G - Christmas Color Grid 2\rProblem Summary\rRandomly paint a green cell red and compute the expected number of green connected components modulo 998244353.\nAnalysis\rUse Tarjan\u0026rsquo;s algorithm to identify articulation points. The removal of a non-articulation point increases the component count by its degree minus one.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;atcoder/modint\u0026gt; #define maxn 1000005 using namespace std; using modint = atcoder::modint998244353; inline void setmin(int\u0026amp; x, int y) { if(y \u0026lt; x) x = y; } vector\u0026lt;int\u0026gt; G[maxn]; inline void add(int x, int y) { G[x].push_back(y); G[y].push_back(x); } int root, low[maxn], cnt, dfn[maxn], ncut[maxn]; void tarjan(int v) { low[v] = dfn[v] = ++cnt; ncut[v] = v != root; for(int u: G[v]) if(!dfn[u]) { tarjan(u); if(low[u] \u0026gt;= dfn[v]) ncut[v] ++; setmin(low[v], low[u]); } else setmin(low[v], dfn[u]); } char s[1005][1005]; int id[1005][1005]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%s\u0026#34;, s[i] + 1); int num = 0; for(int i=1; i\u0026lt;=n; i++) for(int j=1; j\u0026lt;=m; j++) if(s[i][j] == \u0026#39;#\u0026#39;) { id[i][j] = ++num; if(s[i - 1][j] == \u0026#39;#\u0026#39;) add(num, id[i - 1][j]); if(s[i][j - 1] == \u0026#39;#\u0026#39;) add(num, id[i][j - 1]); } int cc = -1; for(int i=1; i\u0026lt;=num; i++) if(!dfn[i]) tarjan(root = i), cc ++; modint ans = 0; for(int i=1; i\u0026lt;=num; i++) ans += cc + ncut[i]; printf(\u0026#34;%d\\n\u0026#34;, (ans / num).val()); return 0; } Postscript\rFirst, wishing everyone a Merry Christmas in advance üéâ! From the title to the problem settings, this contest is intricately tied to Christmas, showing AtCoder\u0026rsquo;s meticulous preparation for this festive event üéÑ.\nRegrettably, during the contest, I solved A~E and G, submitting F just 51 seconds after the contest ended, which was AC. A near AK, but narrowly missed by under a minute üòÖ. Hoping to perform better next time, and best wishes to all contestants. Keep striving! üí™\n","date":"2023-12-24T12:05:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc334/","title":"UNIQUE VISION Programming Contest 2023 Christmas (AtCoder Beginner Contest 334) A~G Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Problem Link\nLuogu Blog Blog Garden\nBasic Approach\rThis problem tests coding implementation skills. The core ideas are:\nRecursive element creation allows up to $100^{100}$ distinct base-type elements. Even considering address limits, elements can reach $10^{18}$. Iteratively constructing each element is infeasible in time and space. However, queries are limited. Only a small subset of elements are accessed during queries. Thus, maintain a list of top-level elements (not nested within others) and traverse hierarchically based on query addresses/names. Specific handling for four operations: For $op=1$: Store type info, compute size and alignment requirements, then output. For $op=2$: Track the first allocatable address. Align, compute, then output. For $op=3$: Start from top-level, traverse layers to compute address. For $op=4$: Start from top-level, compare current address ranges with target, then output element name. Based on this, three storage approaches emerge:\nType names as identifiers: Intuitive but inefficient, discarded. Map type names to indices: More efficient but cumbersome, discarded. Store types as structs with pointers: Efficient and intuitive. Adopted. Step-by-Step Explanation\rPreparation\rDefine LL as long long, setmax(x, y) as x = max(x, y):\n1 2 3 4 5 6 inline void setmax(int\u0026amp; x, int y) { if(x \u0026lt; y) x = y; } using LL = long long; Data Type Storage\rDefine struct DataType:\n1 2 3 4 5 6 7 struct DataType { const string name; // Type name LL size, actual_size; // Aligned size and actual data length int indent; // Alignment requirement vector\u0026lt;pair\u0026lt;DataType*, string\u0026gt;\u0026gt; members; // Members stored as \u0026lt;type pointer, name\u0026gt; }; $$\r{aligned\\_addr} = \\lceil \\frac {addr} {indent} \\rceil \\times indent\r$$ 1 2 3 4 inline LL shift(LL addr) { return addr % indent? (addr / indent + 1) * indent: addr; } Maintenance after type definition:\n1 2 3 4 5 6 7 8 9 10 11 inline void maintain() { size = indent = 0; for(const auto\u0026amp; m: members) { setmax(indent, m.first-\u0026gt;indent); size = m.first-\u0026gt;shift(size) + m.first-\u0026gt;size; } actual_size = size; size = shift(size); } Store types via unordered_map:\n1 unordered_map\u0026lt;string, DataType*\u0026gt; types; Add base types:\n1 2 3 4 5 6 7 8 9 auto add_base_type = [\u0026amp;](string name, int size) -\u0026gt; void { DataType* t = new DataType(name); t-\u0026gt;size = t-\u0026gt;indent = t-\u0026gt;actual_size = size; types[name] = t; }; add_base_type(\u0026#34;byte\u0026#34;, 1); add_base_type(\u0026#34;short\u0026#34;, 2); add_base_type(\u0026#34;int\u0026#34;, 4); add_base_type(\u0026#34;long\u0026#34;, 8); Operation 1: Define Type\rProcess input and compute alignment:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 string s; int k; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; DataType* type = new DataType(s); types[s] = type; type-\u0026gt;members.resize(k); for(auto\u0026amp; m: type-\u0026gt;members) { string t; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; m.second; m.first = types[t]; } type-\u0026gt;maintain(); cout \u0026lt;\u0026lt; type-\u0026gt;size \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; type-\u0026gt;indent \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; Operation 2: Define Element\rTrack current address and top-level elements:\n1 2 LL cur_addr = 0LL; vector\u0026lt;Object\u0026gt; toplevel_objects; Object definition:\n1 2 3 4 5 6 struct Object { DataType* type; // Element type string name; // Element name LL addr; // Start address }; Compute and save element:\n1 2 3 4 5 6 7 8 Object obj; string t; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; obj.name; obj.type = types[t]; obj.addr = obj.type-\u0026gt;shift(cur_addr); cur_addr = obj.addr + obj.type-\u0026gt;size; toplevel_objects.push_back(obj); cout \u0026lt;\u0026lt; obj.addr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; Operation 3: Access Element\rSplit path and traverse layers:\n1 2 3 4 5 6 7 8 9 inline void split(const string\u0026amp; s, char sep, vector\u0026lt;string\u0026gt;\u0026amp; res) { string t; for(char c: s) if(c == sep) res.push_back(t), t.clear(); else t += c; res.push_back(t); } Locate top-level element:\n1 2 3 4 5 6 7 8 9 10 11 12 13 string s; cin \u0026gt;\u0026gt; s; vector\u0026lt;string\u0026gt; ord; split(s, \u0026#39;.\u0026#39;, ord); LL addr; DataType* type; for(auto\u0026amp; obj: toplevel_objects) if(obj.name == ord[0]) { addr = obj.addr; type = obj.type; break; } Traverse members:\n1 2 3 4 5 6 7 8 9 10 11 12 13 ord.erase(ord.begin()); for(string\u0026amp; s: ord) for(auto\u0026amp; m: type-\u0026gt;members) { addr = m.first-\u0026gt;shift(addr); if(m.second == s) { type = m.first; break; } addr += m.first-\u0026gt;size; } cout \u0026lt;\u0026lt; addr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; Operation 4: Access Address\rLocate containing top-level element:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 LL addr; cin \u0026gt;\u0026gt; addr; if(addr \u0026gt;= cur_addr) { cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; } DataType* type = nullptr; LL f_addr = 0LL; string res; for(auto\u0026amp; obj: toplevel_objects) { if(addr \u0026lt; obj.addr) goto bad; if(addr \u0026lt; obj.addr + obj.type-\u0026gt;size) { type = obj.type; res = obj.name; f_addr = obj.addr; break; } } Traverse nested members:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 while(addr \u0026lt; f_addr + type-\u0026gt;actual_size \u0026amp;\u0026amp; !type-\u0026gt;members.empty()) for(auto\u0026amp; m: type-\u0026gt;members) { f_addr = m.first-\u0026gt;shift(f_addr); if(addr \u0026lt; f_addr) goto bad; if(addr \u0026lt; f_addr + m.first-\u0026gt;size) { type = m.first; res.push_back(\u0026#39;.\u0026#39;); res += m.second; break; } f_addr += m.first-\u0026gt;size; } if(addr \u0026lt; f_addr + type-\u0026gt;actual_size) cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; bad: cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; Full Code\rContest code (as explained):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; inline void setmax(int\u0026amp; x, int y) { if(x \u0026lt; y) x = y; } using LL = long long; struct DataType { const string name; LL size, actual_size; int indent; vector\u0026lt;pair\u0026lt;DataType*, string\u0026gt;\u0026gt; members; inline DataType(const string\u0026amp; n): name(n) {} inline LL shift(LL addr) { return addr % indent? (addr / indent + 1) * indent: addr; } inline void maintain() { size = indent = 0; for(const auto\u0026amp; m: members) { setmax(indent, m.first-\u0026gt;indent); size = m.first-\u0026gt;shift(size) + m.first-\u0026gt;size; } actual_size = size; size = shift(size); } }; struct Object { DataType* type; string name; LL addr; }; inline void split(const string\u0026amp; s, char sep, vector\u0026lt;string\u0026gt;\u0026amp; res) { string t; for(char c: s) if(c == sep) res.push_back(t), t.clear(); else t += c; res.push_back(t); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); unordered_map\u0026lt;string, DataType*\u0026gt; types; auto add_base_type = [\u0026amp;](string name, int size) -\u0026gt; void { DataType* t = new DataType(name); t-\u0026gt;size = t-\u0026gt;indent = t-\u0026gt;actual_size = size; types[name] = t; }; add_base_type(\u0026#34;byte\u0026#34;, 1); add_base_type(\u0026#34;short\u0026#34;, 2); add_base_type(\u0026#34;int\u0026#34;, 4); add_base_type(\u0026#34;long\u0026#34;, 8); int q; cin \u0026gt;\u0026gt; q; vector\u0026lt;Object\u0026gt; toplevel_objects; LL cur_addr = 0LL; while(q--) { int op; cin \u0026gt;\u0026gt; op; if(op == 1) { string s; int k; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; DataType* type = new DataType(s); types[s] = type; type-\u0026gt;members.resize(k); for(auto\u0026amp; m: type-\u0026gt;members) { string t; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; m.second; m.first = types[t]; } type-\u0026gt;maintain(); cout \u0026lt;\u0026lt; type-\u0026gt;size \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; type-\u0026gt;indent \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else if(op == 2) { Object obj; string t; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; obj.name; obj.type = types[t]; obj.addr = obj.type-\u0026gt;shift(cur_addr); cur_addr = obj.addr + obj.type-\u0026gt;size; toplevel_objects.push_back(obj); cout \u0026lt;\u0026lt; obj.addr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else if(op == 3) { string s; cin \u0026gt;\u0026gt; s; vector\u0026lt;string\u0026gt; ord; split(s, \u0026#39;.\u0026#39;, ord); LL addr; DataType* type; for(auto\u0026amp; obj: toplevel_objects) if(obj.name == ord[0]) { addr = obj.addr; type = obj.type; break; } ord.erase(ord.begin()); for(string\u0026amp; s: ord) for(auto\u0026amp; m: type-\u0026gt;members) { addr = m.first-\u0026gt;shift(addr); if(m.second == s) { type = m.first; break; } addr += m.first-\u0026gt;size; } cout \u0026lt;\u0026lt; addr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else // op == 4 { LL addr; cin \u0026gt;\u0026gt; addr; if(addr \u0026gt;= cur_addr) { cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; } DataType* type = nullptr; LL f_addr = 0LL; string res; for(auto\u0026amp; obj: toplevel_objects) { if(addr \u0026lt; obj.addr) goto bad; if(addr \u0026lt; obj.addr + obj.type-\u0026gt;size) { type = obj.type; res = obj.name; f_addr = obj.addr; break; } } while(addr \u0026lt; f_addr + type-\u0026gt;actual_size \u0026amp;\u0026amp; !type-\u0026gt;members.empty()) for(auto\u0026amp; m: type-\u0026gt;members) { f_addr = m.first-\u0026gt;shift(f_addr); if(addr \u0026lt; f_addr) goto bad; if(addr \u0026lt; f_addr + m.first-\u0026gt;size) { type = m.first; res.push_back(\u0026#39;.\u0026#39;); res += m.second; break; } f_addr += m.first-\u0026gt;size; } if(addr \u0026lt; f_addr + type-\u0026gt;actual_size) cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; bad: cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; } } for(auto it=types.begin(); it!=types.end(); it++) delete it-\u0026gt;second; return 0; } Total: 180 lines (4.64KB), runtime 73ms.\nOptimized version:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using LL = long long; struct DataType { const string name; LL size, actual_size; int indent; vector\u0026lt;pair\u0026lt;DataType*, string\u0026gt;\u0026gt; members; inline DataType(const string\u0026amp; n): name(n) {} inline LL shift(LL addr) { return addr % indent? (addr / indent + 1) * indent: addr; } inline void maintain() { size = indent = 0; for(const auto\u0026amp; m: members) { indent = max(indent, m.first-\u0026gt;indent); size = m.first-\u0026gt;shift(size) + m.first-\u0026gt;size; } actual_size = size; size = shift(size); } }; inline void split(const string\u0026amp; s, char sep, vector\u0026lt;string\u0026gt;\u0026amp; res) { string t; for(char c: s) if(c == sep) res.push_back(t), t.clear(); else t += c; res.push_back(t); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); unordered_map\u0026lt;string, DataType*\u0026gt; types; auto add_base_type = [\u0026amp;](string name, int size) -\u0026gt; void { DataType* t = new DataType(name); t-\u0026gt;size = t-\u0026gt;indent = t-\u0026gt;actual_size = size; types[name] = t; }; add_base_type(\u0026#34;byte\u0026#34;, 1); add_base_type(\u0026#34;short\u0026#34;, 2); add_base_type(\u0026#34;int\u0026#34;, 4); add_base_type(\u0026#34;long\u0026#34;, 8); int q; cin \u0026gt;\u0026gt; q; vector\u0026lt;pair\u0026lt;DataType*, string\u0026gt;\u0026gt; toplevel_objects; LL cur_addr = 0LL; while(q--) { int op; cin \u0026gt;\u0026gt; op; if(op == 1) { string s; int k; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; DataType* type = new DataType(s); types[s] = type; type-\u0026gt;members.resize(k); for(auto\u0026amp; m: type-\u0026gt;members) { string t; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; m.second; m.first = types[t]; } type-\u0026gt;maintain(); cout \u0026lt;\u0026lt; type-\u0026gt;size \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; type-\u0026gt;indent \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else if(op == 2) { string t, name; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; name; DataType* type = types[t]; cur_addr = type-\u0026gt;shift(cur_addr); cout \u0026lt;\u0026lt; cur_addr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cur_addr += type-\u0026gt;size; toplevel_objects.emplace_back(type, name); } else if(op == 3) { string s; cin \u0026gt;\u0026gt; s; vector\u0026lt;string\u0026gt; ord; split(s, \u0026#39;.\u0026#39;, ord); LL addr = 0LL; DataType* type; for(auto\u0026amp; obj: toplevel_objects) { addr = obj.first-\u0026gt;shift(addr); if(obj.second == ord[0]) { type = obj.first; break; } addr += obj.first-\u0026gt;size; } ord.erase(ord.begin()); for(string\u0026amp; s: ord) for(auto\u0026amp; m: type-\u0026gt;members) { addr = m.first-\u0026gt;shift(addr); if(m.second == s) { type = m.first; break; } addr += m.first-\u0026gt;size; } cout \u0026lt;\u0026lt; addr \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { LL addr; cin \u0026gt;\u0026gt; addr; if(addr \u0026gt;= cur_addr) { cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; } DataType* type = nullptr; LL f_addr = 0LL; string res; for(auto\u0026amp; obj: toplevel_objects) { f_addr = obj.first-\u0026gt;shift(f_addr); if(addr \u0026lt; f_addr) goto bad; if(addr \u0026lt; f_addr + obj.first-\u0026gt;size) { type = obj.first; res = obj.second; break; } f_addr += obj.first-\u0026gt;size; } while(addr \u0026lt; f_addr + type-\u0026gt;actual_size \u0026amp;\u0026amp; !type-\u0026gt;members.empty()) for(auto\u0026amp; m: type-\u0026gt;members) { f_addr = m.first-\u0026gt;shift(f_addr); if(addr \u0026lt; f_addr) goto bad; if(addr \u0026lt; f_addr + m.first-\u0026gt;size) { type = m.first; res.push_back(\u0026#39;.\u0026#39;); res += m.second; break; } f_addr += m.first-\u0026gt;size; } if(addr \u0026lt; f_addr + type-\u0026gt;actual_size) cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; bad: cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; } } for(auto it=types.begin(); it!=types.end(); it++) delete it-\u0026gt;second; return 0; } 146 lines (4.51KB).\nPrefer Object struct for clarity, but optimized code is concise.\nPostscript\rAlgorithms matter, but coding skills are equally crucial! OIers should practice heavy implementation problems to avoid penalties.\nKey points for large simulations:\nClear variable names: Avoid unreadable single-letter names. Use pointers confidently: They simplify type associations. Structs over arrays: Improve readability when possible. Readability over micro-optimizations: Unless necessary for time constraints. Best wishes for NOIP 2023! Please give a like qwq\n","date":"2023-12-02T22:21:00+08:00","permalink":"https://goodcoder666.github.io/en/p/csps2023-t3/","title":"Luogu P9754 [CSP-S 2023] Struct Solution"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed G - Typical Path Problem\rProblem Statement\rGiven a simple undirected graph $G$ with $N$ vertices and $M$ edges, and three integers $A$, $B$, $C$.\nDoes there exist a simple path from vertex $A$ to $C$ that passes through $B$?\nConstraints:\n$3\\le N\\le 2\\times 10^5$ $N-1\\le M\\le \\min(\\frac{N(N-1)}2,2\\times 10^5)$ $1\\le A,B,C\\le N$ ($A$, $B$, $C$ are distinct) What is a simple path?\nA simple path does not visit the same vertex more than once. For example, $1\\to 2\\to 3$ is a simple path, but $1\\to 2\\to 1$ is not.\nSolution 1: Maximum Flow\rWe observe that a simple path $A\\to B\\to C$ exists if and only if there are two paths $B\\to A$ and $B\\to C$ that share no vertices except $B$. This can be modeled as a maximum flow problem.\nConstruct a directed graph $G'$ with $(2N+2)$ vertices:\nSource: $s$ Sink: $t$ Entry points for each vertex in $G$: $x_1,\\dots,x_N$ Exit points for each vertex in $G$: $y_1,\\dots,y_N$ Edges are added as follows:\nFor each $1\\le i\\le N$, connect entry $x_i$ to exit $y_i$ with capacity $1$; Connect source $s$ to $x_B$ (entry of $B$) with capacity $2$; Connect exits $y_A$ and $y_C$ to sink $t$ with capacity $1$ each; For each original edge $(u,v)\\in E_G$, connect $y_u \\to x_v$ and $y_v \\to x_u$ with capacity $1$. Compute the maximum flow from $s$ to $t$. If the flow equals $2$, the required paths exist.\nProof\nA flow of $2$ must utilize both $y_A\\to t$ and $y_C\\to t$ edges, implying existence of $B\\to A$ and $B\\to C$ paths. If these paths share any vertex $v$, both flows would require passing through the $x_v\\to y_v$ edge (capacity $1$), making total flow $1$. Hence, a flow of $2$ guarantees vertex-disjoint paths.\nUsing Dinic\u0026rsquo;s algorithm, the time complexity is $\\mathcal O(N+M)$ since the maximum flow is $2$.\nCode Implementation\rNotations:\nSource: $s=0$ Sink: $t=2n+1$ Entry of $i$: $x_i=i$ Exit of $i$: $y_i=n+i$ AC Library Implementation\nAtCoder Library provides a Dinic-based max flow implementation.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;atcoder/maxflow\u0026gt; using namespace std; int main() { int n, m, a, b, c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;a, \u0026amp;b, \u0026amp;c); int s = 0, t = (n \u0026lt;\u0026lt; 1) + 1; atcoder::mf_graph\u0026lt;int\u0026gt; G(t + 1); G.add_edge(s, b + n, 2); G.add_edge(a + n, t, 1); G.add_edge(c + n, t, 1); for(int i=1; i\u0026lt;=n; i++) G.add_edge(i, i + n, 1); while(m--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G.add_edge(x + n, y, 1); G.add_edge(y + n, x, 1); } puts(G.flow(s, t, 2) == 2? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } Manual Dinic Implementation\nDinic\u0026rsquo;s algorithm achieves $\\mathcal O(N+M)$ complexity for this graph. For algorithm details, refer to OI Wiki.\nNote on Memory Allocation\nThe transformed graph $G'$ contains $(N+2M+3)$ edges. Using static adjacency lists, allocate arrays of size $2(N+2M+3)$, which can safely be set to $1.25\\times 10^6$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 400005 #define maxm 1250005 using namespace std; int n, s, t, head[maxn], cur[maxn], dis[maxn], cnt, w[maxm], to[maxm], nxt[maxm]; inline void add(int u, int v, int flow) { nxt[cnt] = head[u]; head[u] = cnt; to[cnt] = v; w[cnt++] = flow; } inline void add_flow(int u, int v, int f) { add(u, v, f); add(v, u, 0); } inline bool bfs() { memset(dis, -1, sizeof(int) * n); dis[s] = 0, cur[s] = head[s]; queue\u0026lt;int\u0026gt; q; q.push(s); while(!q.empty()) { int v = q.front(); q.pop(); for(int i=head[v]; ~i; i=nxt[i]) if(w[i]) { int u = to[i]; if(dis[u] == -1) { dis[u] = dis[v] + 1, cur[u] = head[u]; if(u == t) return true; q.push(u); } } } return false; } int dfs(int v, int flow) { if(v == t) return flow; int res = 0; for(int i=cur[v]; ~i \u0026amp;\u0026amp; flow; i=nxt[i]) { cur[v] = i; int u = to[i]; if(w[i] \u0026amp;\u0026amp; dis[u] == dis[v] + 1) { int k = dfs(u, min(flow, w[i])); w[i] -= k; w[i ^ 1] += k; flow -= k; res += k; } } return res; } int main() { int n, m, a, b, c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;a, \u0026amp;b, \u0026amp;c); s = 0, t = (n \u0026lt;\u0026lt; 1) + 1, ::n = t + 1; memset(head, -1, sizeof(int) * ::n); add_flow(s, b + n, 2); add_flow(a + n, t, 1); add_flow(c + n, t, 1); for(int i=1; i\u0026lt;=n; i++) add_flow(i, i + n, 1); while(m--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add_flow(x + n, y, 1); add_flow(y + n, x, 1); } int mf = 0; while(bfs()) mf += dfs(s, 2); puts(mf == 2? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } Solution 2: Block Forest (Round-square Tree)\rCorrectness relies on:\nFor any simple path $A\\to C$, if $B$ lies in any biconnected component along this path, then $A\\to B\\to C$ exists. Otherwise, no such path exists. Construct the block forest (round-square tree) using Tarjan\u0026rsquo;s algorithm:\nBuild the block forest $T$ of $G$. Find the unique simple path $A\\to C$ in $T$. Check if $B$ is adjacent to any square node (biconnected component) on this path. Time complexity: $\\mathcal O(N+M)$, with better practical performance than flow-based solutions.\nCode Implementation\rTip: Allocate double-sized arrays for block forest nodes to avoid RE.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 200005 using namespace std; inline void setmin(int\u0026amp; x, int y) { if(y \u0026lt; x) x = y; } vector\u0026lt;int\u0026gt; G[maxn], T[maxn \u0026lt;\u0026lt; 1]; inline void add_edge(vector\u0026lt;int\u0026gt;* G, int x, int y) { G[x].push_back(y); G[y].push_back(x); } int dfc, dfn[maxn], low[maxn], top, st[maxn], cnt; void tarjan(int v) { low[v] = dfn[v] = ++dfc; st[++top] = v; for(int u: G[v]) if(!dfn[u]) { tarjan(u); setmin(low[v], low[u]); if(low[u] == dfn[v]) { add_edge(T, v, ++cnt); do add_edge(T, st[top], cnt); while(st[top--] != u); } } else setmin(low[v], dfn[u]); } int n, m, a, b, c, ct[maxn \u0026lt;\u0026lt; 1]; void dfs(int v, int par) { if(v \u0026gt; n) for(int u: T[v]) ct[u] ++; if(v == c) { puts(ct[b]? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); exit(0); } for(int u: T[v]) if(u != par) dfs(u, v); if(v \u0026gt; n) for(int u: T[v]) ct[u] --; } int main() { scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;a, \u0026amp;b, \u0026amp;c); while(m--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); add_edge(G, x, y); } cnt = n; tarjan(1); dfs(a, -1); return 0; } Comparison\rComparison of three solutions:\nSolution Code Length Running Time Memory Usage Max Flow (AC Library)1 $523~\\mathrm{B}$ $337~\\mathrm{ms}$ $106480~\\mathrm{KB}$ Max Flow (Dinic)2 $1650~\\mathrm{B}$ $334~\\mathrm{ms}$ $46980~\\mathrm{KB}$ Block Forest3 $1142~\\mathrm{B}$ $162~\\mathrm{ms}$ $57824~\\mathrm{KB}$ The block forest solution has the fastest runtime. AC Library implementation offers the shortest code, while manual Dinic uses the least memory.\nPersonal Note\nThis problem is excellent‚Äîsimple statement with rich underlying concepts.\nI didn\u0026rsquo;t even think of using max flow during the contest\nhttps://atcoder.jp/contests/abc318/submissions/45209577\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://atcoder.jp/contests/abc318/submissions/45212257\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://atcoder.jp/contests/abc318/submissions/45210151\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-03T13:28:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc318/","title":"AtCoder Beginner Contest 318 G - Typical Path Problem Solution"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Long time no write-up. Here\u0026rsquo;s a quick one.\nA - Job Interview\rProblem Summary\rGiven a string $S$ of length $N$ consisting of o, -, and x.\nDetermine if $S$ satisfies:\nContains at least one o. Contains no x. $1\\le N\\le 100$\nApproach\rStraightforward simulation.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { while(getchar() != \u0026#39;\\n\u0026#39;); char c; bool ok = false; while((c = getchar()) != \u0026#39;\\n\u0026#39;) { if(c == \u0026#39;x\u0026#39;) { puts(\u0026#34;No\u0026#34;); return 0; } if(c == \u0026#39;o\u0026#39;) ok = true; } puts(ok? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } Python quick pass one-liner\n1 2 3 input() s = input() print(\u0026#39;Yes\u0026#39; if \u0026#39;o\u0026#39; in s and \u0026#39;x\u0026#39; not in s else \u0026#39;No\u0026#39;) Saved 208 characters (flees\nB - Coloring Matrix\rProblem Summary\rGiven two $N\\times N$ binary matrices $A$ and $B$.\nRotate $A$ by 0¬∞, 90¬∞, 180¬∞, or 270¬∞, then check if for every cell where $A_{i,j}=1$, $B_{i,j}=1$.\n$1\\le N\\le 100$\nApproach\rSimulate all four rotations as described in the problem statement.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; #define maxn 105 using namespace std; int a[maxn][maxn], b[maxn][maxn], c[maxn][maxn]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;n; j++) scanf(\u0026#34;%d\u0026#34;, a[i] + j); for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;n; j++) scanf(\u0026#34;%d\u0026#34;, b[i] + j); for(int x=0; x\u0026lt;4; x++) { for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;n; j++) c[i][j] = a[i][j]; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;n; j++) a[i][j] = c[n - 1 - j][i]; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;n; j++) if(a[i][j] \u0026amp;\u0026amp; !b[i][j]) goto bad; // Avoid using goto (old habit), don\u0026#39;t learn this puts(\u0026#34;Yes\u0026#34;); return 0; bad:; } puts(\u0026#34;No\u0026#34;); return 0; } C - Cards Query Problem\rProblem Summary\rProcess $Q$ queries on $N$ boxes:\nInsert card with number $i$ into box $j$. Output all cards in box $i$ in sorted order (duplicates allowed). Output all boxes containing card $i$ in sorted order (no duplicates). $1\\le N,Q\\le 2\\times 10^5$\nApproach\rMaintain a multiset per box for query type 2. Maintain a set per card for query type 3. Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 200005 using namespace std; multiset\u0026lt;int\u0026gt; box[maxn]; set\u0026lt;int\u0026gt; has[maxn]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); while(q--) { int op, i; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;op, \u0026amp;i); if(op == 1) { int j; scanf(\u0026#34;%d\u0026#34;, \u0026amp;j); box[j].insert(i); has[i].insert(j); } else if(op == 2) { for(int x: box[i]) printf(\u0026#34;%d \u0026#34;, x); putchar(\u0026#39;\\n\u0026#39;); } else if(op == 3) { for(int x: has[i]) printf(\u0026#34;%d \u0026#34;, x); putchar(\u0026#39;\\n\u0026#39;); } } return 0; } D - Writing a Numeral\rProblem Summary\rMaintain a string $S$ (initially \u0026ldquo;1\u0026rdquo;) through $Q$ operations:\nAppend digit $x$ to $S$. Remove the first character of $S$. Output $S$ modulo $998244353$. $1\\le Q\\le 6\\times 10^5$\nApproach\rMaintain the current value modulo $P=998244353$ and track $10^{|S|}\\bmod P$ to handle removals efficiently.\nCode\rImplementation 1: Using atcoder::modint and deque\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;atcoder/modint\u0026gt; using namespace std; using modint = atcoder::modint998244353; int main() { deque\u0026lt;int\u0026gt; s; s.push_back(1); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); modint ans = 1; while(q--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if(op == 1) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); s.push_back(x); ans = ans * 10 + x; } else if(op == 2) { int x = s.front(); s.pop_front(); ans -= x * modint(10).pow((int)s.size()); } else printf(\u0026#34;%d\\n\u0026#34;, ans.val()); } return 0; } Implementation 2: Manual modular arithmetic with queue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define MOD 998244353 using namespace std; int main() { int Q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;Q); queue\u0026lt;int\u0026gt; q; q.push(1); int ans = 1, p = 1; while(Q--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if(op == 1) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); q.push(x); ans = (ans * 10LL + x) % MOD; p = p * 10LL % MOD; } else if(op == 2) { ans -= (long long) q.front() * p % MOD; q.pop(); p = p * 299473306LL % MOD; // 299473306 is inverse of 10 modulo MOD if(ans \u0026lt; 0) ans += MOD; } else printf(\u0026#34;%d\\n\u0026#34;, ans); } return 0; } E - Unfair Sugoroku\rProblem Summary\rTwo players move on a board of $N$ cells. Takahashi starts at $A$, Aoki at $B$. Takahashi\u0026rsquo;s die has $P$ faces, Aoki\u0026rsquo;s has $Q$ faces. Compute Takahashi\u0026rsquo;s winning probability modulo $998244353$.\n$2\\le N\\le 100$\nApproach\rDP with states $f_{i,j}$ (Takahashi\u0026rsquo;s turn) and $g_{i,j}$ (Aoki\u0026rsquo;s turn). Transition by averaging over possible dice outcomes.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define MOD 998244353 #define maxn 105 using namespace std; using LL = long long; inline LL inv(LL x) { int y = MOD - 2; LL res = 1LL; while(y) { if(y \u0026amp; 1) (res *= x) %= MOD; (x *= x) %= MOD, y \u0026gt;\u0026gt;= 1; } return res; } inline void add(int\u0026amp; x, int y) { if((x += y) \u0026gt;= MOD) x -= MOD; } int f[maxn][maxn], g[maxn][maxn]; int main() { int n, a, b, p, q; scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;a, \u0026amp;b, \u0026amp;p, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) f[n][i] = g[n][i] = 1, f[i][n] = g[i][n] = 0; LL prob_p = inv(p), prob_q = inv(q); for(int i=n-1; i\u0026gt;=a; i--) for(int j=n-1; j\u0026gt;=b; j--) { for(int k=1; k\u0026lt;=p; k++) add(f[i][j], g[min(i + k, n)][j]); f[i][j] = f[i][j] * prob_p % MOD; for(int k=1; k\u0026lt;=q; k++) add(g[i][j], f[i][min(j + k, n)]); g[i][j] = g[i][j] * prob_q % MOD; } printf(\u0026#34;%d\\n\u0026#34;, f[a][b]); return 0; } F - Rook Score\rProblem Summary\rGiven $N$ non-zero grid cells, compute the maximum sum of a row and column (minus overlap) for any chosen cell.\n$1\\le N\\le 2\\times 10^5$\nApproach\rTrack row sums and column sums. Use a max-heap to maintain column contributions adjusted for overlaps.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; using LL = long long; using pii = pair\u0026lt;int, int\u0026gt;; unordered_map\u0026lt;int, vector\u0026lt;pii\u0026gt;\u0026gt; rows; unordered_map\u0026lt;int, LL\u0026gt; col_sum; template \u0026lt;typename T\u0026gt; class MaxSet { private: multiset\u0026lt;T\u0026gt; s; public: inline void insert(const T\u0026amp; x) { s.insert(x); } inline void update(const T\u0026amp; old, const T\u0026amp; New) { s.erase(s.find(old)); s.insert(New); } inline T max() { return *s.rbegin(); } }; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while(n--) { int x, y, v; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;v); rows[x].emplace_back(y, v); col_sum[y] += v; } MaxSet\u0026lt;LL\u0026gt; s; for(auto [_, sum]: col_sum) s.insert(sum); LL ans = 0LL; for(auto\u0026amp; [x, v]: rows) { for(auto [y, val]: v) s.update(col_sum[y], col_sum[y] - val); LL cur = s.max(); for(auto [y, val]: v) s.update(col_sum[y] - val, col_sum[y]), cur += val; if(cur \u0026gt; ans) ans = cur; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } G - Strawberry War\rProblem Summary\rPartition a $H\\times W$ grid into $T+1$ rectangles via $T$ cuts. Minimize the difference between maximum and minimum strawberry counts.\n$1\\le H,W\\le 6$\nApproach\rDynamic programming tracking minimal maximum value for each subrectangle and cut count. Enumerate all possible minimum values.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const long long INF = 1000000000000000000; int main(){ int H, W, T; cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W \u0026gt;\u0026gt; T; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; s(H, vector\u0026lt;long long\u0026gt;(W)); for (int i = 0; i \u0026lt; H; i++){ for (int j = 0; j \u0026lt; W; j++){ cin \u0026gt;\u0026gt; s[i][j]; } } vector\u0026lt;vector\u0026lt;vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026gt;\u0026gt; sum(H, vector\u0026lt;vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026gt;(H + 1, vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;(W, vector\u0026lt;long long\u0026gt;(W + 1, 0))); vector\u0026lt;long long\u0026gt; x; for (int i = 0; i \u0026lt; H; i++){ for (int j = i + 1; j \u0026lt;= H; j++){ for (int k = 0; k \u0026lt; W; k++){ for (int l = k + 1; l \u0026lt;= W; l++){ for (int m = i; m \u0026lt; j; m++){ for (int n = k; n \u0026lt; l; n++){ sum[i][j][k][l] += s[m][n]; } } x.push_back(sum[i][j][k][l]); } } } } int cnt = x.size(); long long ans = INF; for (int i = 0; i \u0026lt; cnt; i++){ vector\u0026lt;vector\u0026lt;vector\u0026lt;vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; dp(T + 1, vector\u0026lt;vector\u0026lt;vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026gt;\u0026gt;(H, vector\u0026lt;vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026gt;(H + 1, vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;(W, vector\u0026lt;long long\u0026gt;(W + 1, INF))))); for (int j = H - 1; j \u0026gt;= 0; j--){ for (int k = j + 1; k \u0026lt;= H; k++){ for (int l = W - 1; l \u0026gt;= 0; l--){ for (int m = l + 1; m \u0026lt;= W; m++){ if (sum[j][k][l][m] \u0026gt;= x[i]){ dp[0][j][k][l][m] = sum[j][k][l][m]; } for (int n = j + 1; n \u0026lt; k; n++){ for (int o = 0; o \u0026lt; (n - j) * (m - l); o++){ for (int p = 0; p \u0026lt; (k - n) * (m - l) \u0026amp;\u0026amp; o + p \u0026lt; T; p++){ dp[o + p + 1][j][k][l][m] = min(dp[o + p + 1][j][k][l][m], max(dp[o][j][n][l][m], dp[p][n][k][l][m])); } } } for (int n = l + 1; n \u0026lt; m; n++){ for (int o = 0; o \u0026lt; (k - j) * (n - l); o++){ for (int p = 0; p \u0026lt; (k - j) * (m - n) \u0026amp;\u0026amp; o + p \u0026lt; T; p++){ dp[o + p + 1][j][k][l][m] = min(dp[o + p + 1][j][k][l][m], max(dp[o][j][k][l][n], dp[p][j][k][n][m])); } } } } } } } ans = min(ans, dp[T][0][H][0][W] - x[i]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } ","date":"2023-04-19T18:34:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc298/","title":"TOYOTA MOTOR CORPORATION Programming Contest 2023#1 (AtCoder Beginner Contest 298) A~G Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Preface\rThe Lowest Common Ancestor, abbreviated as LCA, is the deepest node that is a common ancestor of two given nodes in a tree.\nThis algorithm has wide applications, such as efficiently solving the shortest path problem on trees.\nFor convenience, we denote the LCA of a node set $S=\\{v_1,v_2,\\ldots,v_n\\}$ as $\\text{LCA}(v_1,v_2,\\ldots,v_n)$ or $\\text{LCA}(S)$.\nPartial content references OI Wiki. All algorithms in this article are implemented in C++.\nExample Problem: Luogu P3379 „ÄêTemplate„ÄëLowest Common Ancestor (LCA)\nProperties\r$\\text{LCA}(\\{u\\})=u$; $u$ is an ancestor of $v$ if and only if $\\text{LCA}(u,v)=u$; If neither $u$ is an ancestor of $v$ nor $v$ is an ancestor of $u$, then $u$ and $v$ reside in two different subtrees of $\\text{LCA}(u,v)$; In pre-order traversal, $\\text{LCA}(S)$ appears before all elements in $S$, while in post-order traversal, it appears after all elements in $S$; The LCA of the union of two node sets is the LCA of their individual LCAs: $\\text{LCA}(A\\cup B)=\\text{LCA}(\\text{LCA}(A), \\text{LCA}(B))$; The LCA of two nodes always lies on the shortest path between them; $d(u,v)=h(u)+h(v)-2h(\\text{LCA}(u,v))$, where $d$ is the distance between two nodes on the tree, and $h$ represents the distance from a node to the root. Solving Algorithms\rPrerequisite 1: Adjacency List Storage of Trees\rIn simple terms, adjacency list storage means for each node, store all nodes directly reachable via one directed or undirected edge.\nTraditional implementations use linked lists (or simulated linked lists), which can be cumbersome and error-prone. For better readability, we use vector from the STL.\n1 2 3 4 #include \u0026lt;vector\u0026gt; // Requires STL vector #define maxn 100005 // Maximum number of nodes std::vector\u0026lt;int\u0026gt; G[maxn]; To add an undirected edge $u\\leftrightarrow v$:\n1 2 G[u].push_back(v); G[v].push_back(u); To add a directed edge $u\\to v$:\n1 G[u].push_back(v); Traverse all nodes directly reachable from $v$:\n1 2 for(int u: G[v]) cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; endl; Prerequisite 2: DFS Traversal \u0026amp; Node Depth Calculation\rBoth algorithms require preprocessing node depths.\nThe depth of a node is defined as its distance from the root.\nPreprocessing all node depths is straightforward using a tree DP approach. Let $h_u$ denote the depth of node $u$:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 100005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; // Adjacency list int depth[maxn]; // Depth of each node void dfs(int v, int par) // dfs(current node, parent node) { int d = depth[v] + 1; // Child depth = current depth + 1 for(int u: G[v]) if(u != par) // Without this check, infinite recursion occurs { depth[u] = d; // Update child depth dfs(u, v); // Continue DFS } } int main() { // Build the graph // ... // Assume graph is stored in G: int root = 0; // Default root is node 0; adjust as needed dfs(root, -1); // Root has no parent (-1) return 0; } Naive Algorithm\rLet $u,v$ be the nodes whose LCA is sought. Preprocess each node\u0026rsquo;s parent (denoted as $f_v$).\nSteps:\nEqualize depths of $u$ and $v$: Move the deeper node upward until both depths match. While $u \\ne v$: Set $u \\gets f_u$, $v \\gets f_v$. When $u = v$, this value is the LCA. Time Complexity:\nPreprocessing: $\\mathcal O(N)$ via DFS. Per Query: Worst-case $\\mathcal O(N)$, average $\\mathcal O(\\log N)$ (for random trees with height $\\lceil\\log N\\rceil$). Reference Code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 500005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; int depth[maxn], par[maxn]; void dfs(int v) { int d = depth[v] + 1; for(int u: G[v]) if(u != par[v]) { par[u] = v, depth[u] = d; dfs(u); } } int lca(int u, int v) { if(depth[u] \u0026lt; depth[v]) swap(u, v); while(depth[u] \u0026gt; depth[v]) u = par[u]; while(u != v) u = par[u], v = par[v]; return u; } int main() { int n, q, root; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;q, \u0026amp;root); for(int i=1; i\u0026lt;n; i++) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[u].push_back(v); G[v].push_back(u); } par[root] = -1, depth[root] = 0; dfs(root); while(q--) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); printf(\u0026#34;%d\\n\u0026#34;, lca(u, v)); } return 0; } This code results in TLE on the last four test cases due to worst-case $\\mathcal O(NQ)$ complexity when $N,Q\\le 5\\times 10^5$.\nDoubling Algorithm\rThe doubling algorithm improves the naive approach and is the classic LCA solution.\nPreprocessing:\nLet $\\text{fa}_{x,i}$ denote the $2^i$-th ancestor of node $x$. During DFS, preprocess $\\text{fa}_{x,i}$: For $i=0$, $\\text{fa}_{x,0}$ is the parent of $x$. For $i\u003e0$, $\\text{fa}_{x,i} = \\text{fa}_{\\text{fa}_{x,i-1}, i-1}$. Query Steps:\nEqualize depths using binary lifting. If $u = v$ after equalizing, return $u$. Simultaneously move $u$ and $v$ upward until their ancestors converge. The LCA is $\\text{fa}_{u,0}$. Time Complexity:\nPreprocessing: $\\mathcal O(N \\log N)$. Per Query: $\\mathcal O(\\log N)$. Reference Code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; #define maxn 500005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; int fa[maxn][19]; // 2^19=524288 int depth[maxn]; void dfs(int v, int par) { fa[v][0] = par; int d = depth[v] + 1; for(int i=1; (1\u0026lt;\u0026lt;i)\u0026lt;d; i++) fa[v][i] = fa[fa[v][i - 1]][i - 1]; for(int u: G[v]) if(u != par) depth[u] = d, dfs(u, v); } inline int lca(int u, int v) { if(depth[u] \u0026lt; depth[v]) u ^= v ^= u ^= v; int m = depth[u] - depth[v]; for(int i=0; m; i++, m\u0026gt;\u0026gt;=1) if(m \u0026amp; 1) u = fa[u][i]; if(u == v) return u; // This line is essential for(int i=log2(depth[u]); i\u0026gt;=0; i--) if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i]; return fa[u][0]; } int main() { int n, q, root; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;q, \u0026amp;root); for(int i=1; i\u0026lt;n; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G[--x].push_back(--y); G[y].push_back(x); } depth[--root] = 0; dfs(root, -1); while(q--) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); printf(\u0026#34;%d\\n\u0026#34;, lca(--u, --v) + 1); } return 0; } Exercises\rProblem: Luogu P8805 [Blue Bridge Cup 2022 National B] Computer Room Solution: https://best-blogs.blog.luogu.org/solution-p8805 Summary\rThis article details LCA problem-solving using two algorithms. Comparison:\nAlgorithm Preprocessing Time Per Query Time1 Space Passes Example2? Naive $\\mathcal O(N)$ $\\mathcal O(N)$ $\\mathcal O(N)$ \u0026#x274c; Doubling $\\mathcal O(N \\log N)$ $\\mathcal O(\\log N)$ $\\mathcal O(N \\log N)$ \u0026#x2714;\u0026#xfe0f; Your support through likes and shares is appreciated!\nWorst-case time complexity.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nExample: Luogu P3379 „ÄêTemplate„ÄëLowest Common Ancestor (LCA)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-01-06T23:03:00+08:00","permalink":"https://goodcoder666.github.io/en/p/algonotes-lca/","title":"[Algorithm Notes] Solving the Lowest Common Ancestor (LCA) Problem ‚Äì Doubling Algorithm"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Preface\rIt\u0026rsquo;s been a while since the last update to the algorithm notes column. Just learned a new algorithm, so here\u0026rsquo;s an update\u0026hellip;\nThis is also the first special topic of this column, covering three data structures. If you spot any issues, please feel free to point them out. Thanks!\nAbout RMQ Problems\rRMQ stands for Range Minimum/Maximum Query.\nIn this article, our algorithms focus on finding maximum values (minimum values follow similar logic). The problem statement is as follows:\nGiven a sequence $A=(A_1,A_2,\\dots,A_N)$ of length $N$.\nThere are $Q$ queries. The $i$-th query is:\n$\\to~$ Given $1\\le l_i\\le r_i\\le N$, find the maximum value in interval $[l_i,r_i]$, i.e., $\\displaystyle\\max_{j=l_i}^{r_i} A_j$.\nBelow, we\u0026rsquo;ll start with a brute-force approach and gradually introduce common solutions for RMQ problems.\nStandard RMQ problems (all algorithms except brute-force can pass):\nLuogu P1816 Loyalty (classic RMQ) Luogu P2880 [USACO07JAN] Balanced Lineup G Luogu P2251 Quality Inspection Luogu P8818 [CSP-S 2022] Strategy Game (requires more thinking) Solutions\rBrute-Force\rWe first read the sequence $A$, then process each query by directly iterating through $A_l\\dots A_r$.\nTime complexity: $\\mathcal O(\\sum r_i-l_i)=\\mathcal O(NQ)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 using namespace std; int a[maxn]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); while(q--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); l --, r --; int res = a[l]; for(int i=l+1; i\u0026lt;=r; i++) if(a[i] \u0026lt; res) res = a[i]; printf(\u0026#34;%d \u0026#34;, res); } return 0; } However, when submitting to Luogu P1816\u0026hellip;\nClearly, the time complexity is too high. Further optimization is needed.\nSparse Table\rSparse Table (ST) is a data structure for static RMQ problems.\nStatic means the original sequence remains unchanged. ST tables cannot handle direct modifications.\nST table initialization takes $\\mathcal O(N\\log N)$, and each query takes $\\mathcal O(1)$.\nStorage Structure\r$$ st[i][j]=\\max\\{A_i,A_{i+1},\\dots,A_{i+2^j-1}\\} $$\nHere, $st[i][j]$ represents the maximum value of $2^j$ elements starting from $A_i$, using a doubling strategy.\nInitialization\r$$ st[i][j]=\\max\\{st[i][j-1],st[i+2^{j-1}][j-1]\\} $$\nFill by iterating $j$ first, then $i$. Total initialization time: $\\mathcal O(N\\log N)$.\nPseudocode:\n1 2 3 4 5 6 7 function init() { for i = 1 to N st[i][0] = A[i] for j = 1 to log2(N) for i = 1 to (N + 1 - 2^j) st[i][j] = max(st[i][j - 1], st[i + 2^(j-1)][j - 1]) } C++ implementation:\n1 2 3 4 5 6 7 8 void init() { for(int i=0; i\u0026lt;n; i++) st[i][0] = A[i]; for(int j=1; j\u0026lt;=log2(n); j++) for(int i=0; i+(1\u0026lt;\u0026lt;j)\u0026lt;=n; i++) // Note: \u0026lt;=n st[i][j] = max(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; j - 1)][j - 1]); } Query\rFor interval $[l,r)$, find two intervals $[l,a)$ and $[b,r)$ such that their union is exactly $[l,r)$. Let $k=\\lfloor\\log_2(r-l)\\rfloor$:\n1 2 3 4 5 6 // query(l, r) = max(A[l], ..., A[r - 1]) inline int query(int l, int r) { int k = log2(r - l); return max(st[l][k], st[r - (1 \u0026lt;\u0026lt; k)][k]); } Full Implementation\rComplete code for Luogu P1816. Time complexity: $\\mathcal O(Q+N\\log N)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 100005 using namespace std; int st[maxn][17]; // 2^17=131072 void init(int n) { for(int j=1, t=log2(n); j\u0026lt;=t; j++) for(int i=0; i+(1\u0026lt;\u0026lt;j)\u0026lt;=n; i++) st[i][j] = min(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; j - 1)][j - 1]); } inline int query(int l, int r) { int k = log2(r - l); return min(st[l][k], st[r - (1 \u0026lt;\u0026lt; k)][k]); // Note: min for this problem } int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, st[i]); // Directly read into ST table init(n); while(q--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%d \u0026#34;, query(--l, r)); } return 0; } Runtime: $128\\mathrm{ms}$\nMemory: $6.90\\mathrm{MB}$\nFenwick Tree\rFor Fenwick Tree basics, see this article. Here, we adapt it for RMQ.\nOriginal Algorithm\rFenwick Tree supports prefixSum and update in $\\mathcal O(\\log N)$. It works for any associative operation.\nImplementing prefixMax and update:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #define INF 2147483647 #define lowbit(x) ((x) \u0026amp; -(x)) inline void setmax(int\u0026amp; x, int y) { if(y \u0026gt; x) x = y; } int n, A[N], bit[N]; // max(A[1], ..., A[i]) inline int prefixMax(int i) { int res = -INF; for(; i\u0026gt;0; i-=lowbit(i)) setmax(res, bit[i]); return res; } // A[i] = max(A[i], val) inline void update(int i, int val) { for(; i\u0026lt;=n; i+=lowbit(i)) setmax(bit[i], val); } RMQ Fenwick Tree\rDefine recursive rangeMax:\n1 2 3 4 5 6 7 8 int rangeMax(int l, int r) { if(l == r) return A[l]; int t = r - lowbit(r); return t \u0026lt; l? max(A[r], rangeMax(l, r - 1)): max(bit[r], rangeMax(l, t)); } Non-recursive version for efficiency:\n1 2 3 4 5 6 7 8 9 10 11 int rangeMin(int l, int r) { int res = INF; while(l \u0026lt;= r) { int t = r - lowbit(r); if(t \u0026lt; l) setmin(res, a[r--]); else setmin(res, bit[r]), r = t; } return res; } Full Implementation\rSolution for Luogu P1816. Time complexity: $\\mathcal O(N+Q\\log N)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 using namespace std; #define INF 2147483647 #define lowbit(x) ((x) \u0026amp; -(x)) inline void setmin(int\u0026amp; x, int y) { if(y \u0026lt; x) x = y; } int a[maxn], bit[maxn]; int rangeMin(int l, int r) { int res = INF; while(l \u0026lt;= r) { int t = r - lowbit(r); if(t \u0026lt; l) setmin(res, a[r--]); else setmin(res, bit[r]), r = t; } return res; } inline void init(int n) { for(int i=1; i\u0026lt;=n; i++) bit[i] = a[i]; for(int i=1; i\u0026lt;=n; i++) { int j = i + lowbit(i); if(j \u0026lt;= n) setmin(bit[j], bit[i]); } } int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); init(n); while(q--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%d \u0026#34;, rangeMin(l, r)); } return 0; } Runtime: $135\\mathrm{ms}$\nMemory: $1.14\\mathrm{MB}$\nSegment Tree\rSegment Trees handle a wider range of problems with $\\mathcal O(N)$ initialization and $\\mathcal O(\\log N)$ per query.\nStorage Structure\rStored as a heap-like array. Each node represents an interval.\n1 2 3 #define ls(x) (x \u0026lt;\u0026lt; 1) #define rs(x) (x \u0026lt;\u0026lt; 1 | 1) #define par(x) (x \u0026gt;\u0026gt; 1) Build\rRecursively construct left and right subtrees:\n1 2 3 4 5 6 7 8 9 10 11 12 void build(int l, int r, int p) { if(l == r) { c[p] = a[l]; return; } int m = l + r \u0026gt;\u0026gt; 1; build(l, m, ls(p)); build(m + 1, r, rs(p)); c[p] = min(c[ls(p)], c[rs(p)]); } Query\rRecursively check overlapping intervals:\n1 2 3 4 5 6 7 8 int query(int l, int r, int a, int b, int p) { if(a \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= b) return c[p]; int m = l + r \u0026gt;\u0026gt; 1, res = INF; if(m \u0026gt;= a) res = min(res, query(l, m, a, b, ls(p))); if(m \u0026lt; b) res = min(res, query(m + 1, r, a, b, rs(p))); return res; } Full Implementation\rSolution for Luogu P1816. Time complexity: $\\mathcal O(N+Q\\log N)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 100005 using namespace std; #define INF 2147483647 #define ls(x) (x \u0026lt;\u0026lt; 1) #define rs(x) (x \u0026lt;\u0026lt; 1 | 1) #define par(x) (x \u0026gt;\u0026gt; 1) int a[maxn], c[maxn \u0026lt;\u0026lt; 2]; void build(int l, int r, int p) { if(l == r) { c[p] = a[l]; return; } int m = l + r \u0026gt;\u0026gt; 1; build(l, m, ls(p)); build(m + 1, r, rs(p)); c[p] = min(c[ls(p)], c[rs(p)]); } int query(int l, int r, int a, int b, int p) { if(a \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= b) return c[p]; int m = l + r \u0026gt;\u0026gt; 1, res = INF; if(m \u0026gt;= a) res = min(res, query(l, m, a, b, ls(p))); if(m \u0026lt; b) res = min(res, query(m + 1, r, a, b, rs(p))); return res; } int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); build(0, n - 1, 1); while(q--) { int l, r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%d \u0026#34;, query(0, n - 1, --l, --r, 1)); } return 0; } Runtime: $163\\mathrm{ms}$\nMemory: $1.78\\mathrm{MB}$\nSummary\rComparison of algorithms:\nAlgorithm Preprocessing Time Query Time Space Passes Constraints? Brute-Force $\\mathcal O(1)$ $\\mathcal O(N)$ $\\mathcal O(N)$ \u0026#x274c; Sparse Table $\\mathcal O(N\\log N)$ $\\mathcal O(1)$ $\\mathcal O(N\\log N)$ \u0026#x2714;\u0026#xfe0f; Fenwick Tree $\\mathcal O(N)$ $\\mathcal O(\\log N)$ $\\mathcal O(N)$ \u0026#x2714;\u0026#xfe0f; Segment Tree $\\mathcal O(N)$ $\\mathcal O(\\log N)$ $\\mathcal O(N)$ \u0026#x2714;\u0026#xfe0f; Performance on Luogu P1816:\nAlgorithm Runtime Memory Code Length Sparse Table $128\\mathrm{ms}$ $6.90\\mathrm{MB}$ $625\\mathrm B$ Fenwick Tree (non-recursive) $135\\mathrm{ms}$ $1.14\\mathrm{MB}$ $786\\mathrm B$ Segment Tree $163\\mathrm{ms}$ $1.78\\mathrm{MB}$ $905\\mathrm B$ ST Table is fastest but memory-heavy. Fenwick Tree balances speed and space. Segment Tree is versatile but slightly slower.\nThis concludes the article. Hope you found it helpful!\nThis is my first 10k-word article in 2023. Happy New Year!\n","date":"2023-01-05T22:48:00+08:00","permalink":"https://goodcoder666.github.io/en/p/algonotes-rmq/","title":"„ÄêAlgorithm Notes„Äë„ÄêSpecial Topic„ÄëRMQ Problems: Sparse Table/Fenwick Tree/Segment Tree"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Note: Why doesn\u0026rsquo;t this contest have an English name\u0026hellip;\nA - Batting Average\rProblem Summary\rGiven integers $A$ and $B$, output $\\frac BA$ rounded to three decimal places.\n$1\\le A\\le 10$\n$0\\le B\\le A$\nAnalysis\rA warm-up problem. Use formatted output with printf or cout.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;%.3Lf\\n\u0026#34;, (long double)b / a); return 0; } B - Line Sensor\rProblem Summary\rGiven an $H\\times W$ grid where each cell is . or #, count the number of # in each column and output the results.\n$1\\le H,W\\le 1000$\nAnalysis\rMaintain an array ans[W] to track counts per column. Accumulate during input.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #define maxn 1005 using namespace std; char s[maxn]; int ans[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(n--) { scanf(\u0026#34;%s\u0026#34;, s); for(int i=0; i\u0026lt;m; i++) if(s[i] == \u0026#39;#\u0026#39;) ans[i] ++; } for(int i=0; i\u0026lt;m; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); return 0; } C - Ameba\rProblem Summary\rA tree with $2N+1$ nodes has root node 1. The tree is defined by sequence $A=(A_1,A_2,\\dots,A_N)$:\nNode $A_i$ is the parent of $2i$ and $2i+1$. Compute the depth of each node.\n$1\\le N\\le 2\\times 10^5$\n$1\\le A_i\\le 2i-1$\nSolution 1\rConstruct the tree\u0026rsquo;s adjacency list from the sequence and compute depths via DFS from the root.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 200005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn \u0026lt;\u0026lt; 1]; int dep[maxn \u0026lt;\u0026lt; 1]; void dfs(int v, int par) { for(int u: G[v]) if(u != par) { dep[u] = dep[v] + 1; dfs(u, v); } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=1; i\u0026lt;=n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); G[x].push_back(i \u0026lt;\u0026lt; 1); G[x].push_back(i \u0026lt;\u0026lt; 1 | 1); } dep[1] = 0; dfs(1, -1); for(int i=1; i\u0026lt;=(n\u0026lt;\u0026lt;1)+1; i++) printf(\u0026#34;%d\\n\u0026#34;, dep[i]); return 0; } Solution 2 (Optimal)\rSince $A_i$ is always processed before $2i$ and $2i+1$, compute depths directly during input:\ndepth[2*i] = depth[2*i+1] = depth[A[i]] + 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 200005 using namespace std; int dep[maxn \u0026lt;\u0026lt; 1]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=1; i\u0026lt;=n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); dep[i \u0026lt;\u0026lt; 1] = dep[i \u0026lt;\u0026lt; 1 | 1] = dep[x] + 1; } for(int i=1; i\u0026lt;=(n\u0026lt;\u0026lt;1)+1; i++) printf(\u0026#34;%d\\n\u0026#34;, dep[i]); return 0; } D - Robot Arms 2\rProblem Summary\rGiven $N$ and sequence $A=(A_1,A_2,\\dots,A_N)$, determine if we can reach $(x,y)$ from $(0,0)$ in $N$ steps:\nStep 1: Move $A_1$ units right to $(A_1,0)$ Step $i$ ($i\u003e1$): Turn 90¬∞ left/right, then move $A_i$ units. $2\\le N\\le 10^3$\n$1\\le A_i\\le 10$\n$-10^4\\le x,y\\le 10^4$\nAnalysis\rSplit the problem into independent x and y axes:\nFor the x-axis: Start at $A_1$, target $x$, moves $A_3,A_5,\\dots$ For the y-axis: Start at $0$, target $y$, moves $A_2,A_4,\\dots$ Use set-based DP to track reachable positions for each axis. Both axes must satisfy their targets.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; inline bool check(vector\u0026lt;int\u0026gt;\u0026amp; v, int start, int target) { set\u0026lt;int\u0026gt; s; s.insert(start); for(int d: v) { set\u0026lt;int\u0026gt; ls = s; s.clear(); for(int x: ls) s.insert(x + d), s.insert(x - d); } return s.count(target); } int main() { int n, x, y; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;x, \u0026amp;y); vector\u0026lt;int\u0026gt; a(n); for(int\u0026amp; t: a) scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); vector\u0026lt;int\u0026gt; dx; for(int i=2; i\u0026lt;n; i+=2) dx.push_back(a[i]); if(!check(dx, a[0], x)) { puts(\u0026#34;No\u0026#34;); return 0; } vector\u0026lt;int\u0026gt; dy; for(int i=1; i\u0026lt;n; i+=2) dy.push_back(a[i]); puts(check(dy, 0, y)? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } E - Booster\rProblem Summary\rIn a 2D plane, visit all $N$ cities starting from $(0,0)$. Optional $M$ boosters double speed when collected. Compute the minimum time required.\nEach city has coordinates $(X_i,Y_i)$, boosters $(P_i,Q_i)$. Initial speed is 1.\nAnalysis\rRefer to Official Editorial for detailed approach.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #define maxn 17 using namespace std; inline double ppow(int x) { return 1.0 / (1 \u0026lt;\u0026lt; __builtin_popcount(x)); } inline void setmin(double\u0026amp; x, double y) { if(y \u0026lt; x) x = y; } double x[maxn], y[maxn], dp[maxn][1 \u0026lt;\u0026lt; maxn]; int main() { // Input int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); m += n; for(int i=0; i\u0026lt;m; i++) scanf(\u0026#34;%lf%lf\u0026#34;, x + i, y + i); int mx = 1 \u0026lt;\u0026lt; m; for(int i=0; i\u0026lt;m; i++) for(int s=0; s\u0026lt;mx; s++) dp[i][s] = 1e18; // DP: Initial state for(int i=0; i\u0026lt;m; i++) dp[i][1 \u0026lt;\u0026lt; i] = hypot(x[i], y[i]); // DP: Transfer for(int s=1; s\u0026lt;mx; s++) { double coef = ppow(s \u0026gt;\u0026gt; n); for(int i=0; i\u0026lt;m; i++) { if(!(s \u0026gt;\u0026gt; i \u0026amp; 1)) continue; for(int j=0; j\u0026lt;m; j++) { if(s \u0026gt;\u0026gt; j \u0026amp; 1) continue; setmin(dp[j][s | (1 \u0026lt;\u0026lt; j)], dp[i][s] + hypot(x[i] - x[j], y[i] - y[j])*coef); } } } // Output double ans = 1e18; for(int i=0, t=1\u0026lt;\u0026lt;n; i\u0026lt;m; i++) for(int s=t-1; s\u0026lt;mx; s+=t) setmin(ans, dp[i][s] + dp[i][1 \u0026lt;\u0026lt; i] * ppow(s \u0026gt;\u0026gt; n)); printf(\u0026#34;%.10f\\n\u0026#34;, ans); return 0; } ","date":"2022-10-24T08:30:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc274/","title":"AtCoder Beginner Contest 274 A~E Solution"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Preface\rSuddenly realized that bitwise operations are quite useful, so I\u0026rsquo;m writing this article to share some insights\u0026hellip;\nNote: I\u0026rsquo;ve included all the bitwise operation concepts I could think of, so this article is quite lengthy, please bear with me! If any part is unclear or insufficiently detailed, feel free to supplement in the comments section. Thanks for your support!\nReference code in this article is written in C++.\nWithout further ado, let\u0026rsquo;s get started.\nBasic Operations\rThose with prior knowledge can skip this section.\nBrief rules of bitwise operations:\nSymbol Name Rule \u0026amp; Bitwise AND 1 only when both bits are 1 | Bitwise OR 0 only when both bits are 0 ^ XOR 1 when bits differ, 0 when same ~ Bitwise NOT Flip 0 to 1, 1 to 0 \u0026lt;\u0026lt; Left Shift Shift bits left, discard high bits, pad 0s on right \u0026gt;\u0026gt; Right Shift Shift bits right, discard low bits, pad 0s on left (for unsigned) Detailed explanations:\nBitwise NOT\rBitwise NOT (~x) is the simplest unary operation. Simply flip each bit of the operand. Examples:\n~0011 = 1100\n~1011 = 0100\nProperty: ~(~x) = x\nBitwise AND\rBitwise AND (x \u0026amp; y) takes two operands. For each corresponding bit pair:\nx y x \u0026amp; y 0 0 0 0 1 0 1 0 0 1 1 1 Examples:\n0011 \u0026amp; 1100 = 0000\n1010 \u0026amp; 1011 = 1010\nProperties:\nCommutative: a \u0026amp; b = b \u0026amp; a Associative: a \u0026amp; b \u0026amp; c = a \u0026amp; (b \u0026amp; c) Idempotent: a \u0026amp; a = a AND with 0: 0 \u0026amp; a1 \u0026amp; a2 \u0026amp; ... = 0 AND with all-1s: a \u0026amp; inf = a Bitwise OR\rBitwise OR (x | y) takes two operands. For each corresponding bit pair:\nx y x | y 0 0 0 0 1 1 1 0 1 1 1 1 Examples:\n1100 | 0011 = 1111\n1010 | 0001 = 1011\nProperties:\nCommutative: a | b = b | a Associative: a | b | c = a | (b | c) Idempotent: a | a = a OR with 0: a | 0 = a OR with all-1s: a | inf = inf XOR\rXOR (x ^ y or $x\\oplus y$) takes two operands. For each corresponding bit pair:\nx y $x\\oplus y$ 0 0 0 0 1 1 1 0 1 1 1 0 Examples:\n1000 ^ 1011 = 0011\n0101 ^ 1010 = 1111\nProperties:\nCommutative: $a\\oplus b=b\\oplus a$ Associative: $a\\oplus b\\oplus c=a\\oplus(b\\oplus c)$ Self-inverse: $a\\oplus a=0$ XOR with 0: $a\\oplus 0=a$ Multiple XOR: $a\\oplus b\\oplus b=a\\oplus 0=a$ XOR with all-1s: $a\\oplus \\infty=~a$ If $a\\oplus b=c$, then $a\\oplus c=b$. Shifts\rShifts include left shift (\u0026lt;\u0026lt;) and right shift (\u0026gt;\u0026gt;).\na \u0026lt;\u0026lt; b: Append b zeros to the right of a\u0026rsquo;s binary. a \u0026gt;\u0026gt; b: Remove b bits from the right of a\u0026rsquo;s binary. Properties:\n(a \u0026lt;\u0026lt; b) \u0026gt;\u0026gt; b = a (when no overflow) a \u0026lt;\u0026lt; b ‚âà $a\\times 2^b$ a \u0026gt;\u0026gt; b ‚âà $\\lfloor\\frac{a}{2^b}\\rfloor$ Exercises\rDetermine Power of Two\rProblem: Given integer N, check if it\u0026rsquo;s a power of two.\nLuogu P1100 High-Low Swap\rProblem: Given 32-bit integer x, swap its high 16 bits and low 16 bits.\nSolution: ans = (x \u0026gt;\u0026gt; 16) | (x \u0026lt;\u0026lt; 16) Explanation:\nValue High 16 Low 16 x A B x \u0026raquo;16 0s A x \u0026laquo;16 B 0s ans B A Note: Use 32-bit unsigned integer to allow natural overflow when shifting.\nReference code:\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { unsigned int x; scanf(\u0026#34;%u\u0026#34;, \u0026amp;x); printf(\u0026#34;%u\\n\u0026#34;, (x \u0026gt;\u0026gt; 16) | (x \u0026lt;\u0026lt; 16)); return 0; } Find Unique Number\rGiven sequence A=(A‚ÇÅ,A‚ÇÇ,\u0026hellip;,A‚ÇÇ‚Çô‚Çä‚ÇÅ) where N numbers appear twice and one appears once. Find the unique number.\n- O(N) time, O(N) space solution\nCount occurrences and find the singleton.\n- O(N) time, O(1) space solution\nCompute XOR sum S = A‚ÇÅ^A‚ÇÇ^\u0026hellip;^A‚ÇÇ‚Çô‚Çä‚ÇÅ. All duplicates cancel out, leaving the unique number.\nReference code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); n = (n \u0026lt;\u0026lt; 1) + 1; int ans = 0; while(n--) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); ans ^= x; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } AtCoder ABC 261 E - Many Operations\rSolution: For each i=1..N, track how each bit of 0/1 transforms after first i operations using prefix-like approach. Time complexity O(N).\nReference code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // https://atcoder.jp/contests/abc261/submissions/33495431 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { unsigned n, c, zero = 0, one = 0xffffffff; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;c); while(n--) { int t, a; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;t, \u0026amp;a); if(t == 1) one \u0026amp;= a, zero \u0026amp;= a; else if(t == 2) one |= a, zero |= a; else one ^= a, zero ^= a; printf(\u0026#34;%d\\n\u0026#34;, c = (c \u0026amp; one) | (~c \u0026amp; zero)); } return 0; } Extended Concepts \u0026amp; Operations\rlowbit\rlowbit(x) returns the least significant 1-bit, e.g., lowbit(10010) = 10, lowbit(1) = 1. Used in Fenwick Trees.\nCalculating lowbit\nBrute force: 1 2 3 4 5 6 7 int lowbit(int x) { int res = 1; while(x \u0026amp;\u0026amp; !(x \u0026amp; 1)) x \u0026gt;\u0026gt;= 1, res \u0026lt;\u0026lt;= 1; return res; } x \u0026amp; -x x \u0026amp; (x - 1) gives x - lowbit(x). popcount\rpopcount(x) counts the number of 1-bits.\nCalculating popcount\nBrute force: 1 2 3 4 5 6 7 8 9 10 int popcount(int x) { int res = 0; while(x) { res += x \u0026amp; 1; x \u0026gt;\u0026gt;= 1; } return res; } Optimized with lowbit: 1 2 3 4 5 6 int popcount(int x) { int res = 0; for(; x; x\u0026amp;=x-1) res ++; return res; } Builtin functions (fastest) Builtin Bitwise Functions\rNote: Functions with ll suffix take long long arguments.\nReference: https://blog.csdn.net/zeekliu/article/details/124848210\n__builtin_popcount/__builtin_popcountll\rReturns number of 1-bits.\n__builtin_ctz / __buitlin_ctzll\rCount trailing zeros.\n__buitlin_clz / __buitlin_clzll\rCount leading zeros.\n__builtin_ffs / __buitlin_ffsll\rFind position of last set bit (1-indexed).\n__builtin_parity / __builtin_parityll\rReturn parity (even/odd) of 1-bit count.\nApplications of Bitwise Operations\rSubset Representation\rFor set {0,1,\u0026hellip;,N-1}, use N-bit integer S to represent subsets. Operations:\nEmpty set: 0 Full set: 2·¥∫-1 Size: __builtin_popcount(S) Check element i: S \u0026gt;\u0026gt; i \u0026amp; 1 Add i: S |= 1 \u0026lt;\u0026lt; i Remove i (must exist): S ^= 1 \u0026lt;\u0026lt; i Remove i (any case): S \u0026amp;= ~(1 \u0026lt;\u0026lt; i) Intersection: S \u0026amp; T Union: S | T Symmetric difference: S ^ T Subset Enumeration\r- Enumerate all subsets\n1 for(int s=0; s\u0026lt;(1\u0026lt;\u0026lt;N); s++) - Enumerate subsets of a subset\n1 2 for(int S=0; S\u0026lt;(1\u0026lt;\u0026lt;N); S++) for(int T=S; T; T=(T-1)\u0026amp;S) Time complexity O(3·¥∫).\n- Enumerate K-sized subsets\nOptimized method from \u0026ldquo;Competitive Programming\u0026rdquo;:\n1 2 3 4 5 6 7 int S = (1 \u0026lt;\u0026lt; k) - 1; while(S \u0026lt; 1 \u0026lt;\u0026lt; n) { // Process S int x = S \u0026amp; -S, y = S + x; S = ((S \u0026amp; ~y) / x \u0026gt;\u0026gt; 1) | y; } Extension: std::bitset\rC++ STL\u0026rsquo;s bitset for large N:\nOperation Description b.any() True if any bit is set b.none() True if no bits are set b.count() Number of set bits b.size() Total bits b[pos] Access bit at pos b.test(pos) Check bit at pos b.set(pos) Set bit at pos b.set() Set all bits b.reset(pos) Clear bit at pos b.reset() Clear all bits b.flip() Flip all bits b.flip(pos) Flip bit at pos b.to_ulong() Convert to unsigned long os \u0026lt;\u0026lt; b Output bit pattern Exercise: AtCoder ABC 258 G - Triangle\rSolution using bitset optimizations. See my explanation.\nDFS Optimization with Bitwise Operations\rN-Queens problem solved with bitwise optimizations:\nStandard backtracking vs. optimized version:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Standard backtracking bool row[maxn], diag_left[maxn \u0026lt;\u0026lt; 1], diag_right[maxn \u0026lt;\u0026lt; 1]; void dfs(int i) { /* ... */ } // Bitwise optimized void dfs(int row, int diag_left, int diag_right) { if(row == mx) { ans++; return; } int a = mx \u0026amp; ~(row | diag_left | diag_right); while(a) { int p = a \u0026amp; -a; a ^= p; dfs(row | p, (diag_left | p) \u0026gt;\u0026gt; 1, (diag_right | p) \u0026lt;\u0026lt; 1); } } Performance comparison (for N=16):\nStandard: 53.4s Optimized: 6.23s Exercise: Luogu P1092 [NOIP2004] Alphametic\nOther Applications\rSwap two numbers\r1 void swap(int\u0026amp; a, int\u0026amp; b) { a ^= b ^= a ^= b; } Average without overflow\r1 2 int average1(int x, int y) { return (x \u0026gt;\u0026gt; 1) + (y \u0026gt;\u0026gt; 1) + (x \u0026amp; y \u0026amp; 1); } int average2(int x, int y) { return (x \u0026amp; y) + ((x ^ y) \u0026gt;\u0026gt; 1); } Check power of two\r1 bool ispowof2(int x) { return x \u0026gt; 0 \u0026amp;\u0026amp; !(x \u0026amp; x - 1); } Conclusion\rThis article thoroughly explains bitwise operations and their applications.\nIf you found this helpful, please give a like and share! Thanks for reading!\n","date":"2022-10-18T08:30:00+08:00","permalink":"https://goodcoder666.github.io/en/p/algonotes-bwop/","title":"„ÄêAlgorithm Notes„ÄëDetailed Explanation of Bitwise Operations"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Introduction\rThe Fenwick Tree, also known as Binary Indexed Tree (BIT), is a tree-like data structure. Despite its name, its applications often seem unrelated to trees:\nGiven a sequence $A=(A_1,A_2,\\dots,A_N)$, perform the following operations in $\\mathcal O(\\log N)$ time:\n$\\to~$Calculate the sum of all elements in the interval $[L,R]$.\n$\\to~$Update a specific element $A_x$ by adding $k$.\nTo optimize summation, prefix sums come to mind, offering $\\mathcal O(1)$ query time but $\\mathcal O(N)$ update time. Conversely, naively storing all elements allows $\\mathcal O(1)$ updates but $\\mathcal O(N)$ queries. The solution? The Fenwick Tree.\nBasic Algorithm\rLuogu P3374 \u0026ldquo;Fenwick Tree 1 Template\u0026rdquo;\nConstraints: $1\\le n,m\\le 10^5$, where $m$ is the total number of operations.\nWith $n,m\\le 10^5$, an $\\mathcal O(nm)$ brute-force approach is infeasible. The Fenwick Tree achieves $\\mathcal O(M\\log N)$ time. Its structure is illustrated below:\nLet $B$ represent the internal storage. From the diagram:\n$B_1=A_1$ $B_2=A_1+A_2$ $B_3=A_3$ $B_4=A_1+A_2+A_3+A_4$ \u0026hellip; Here, $B_i$ stores the sum $A_{i-2^k+1}+A_{i-2^k+2}+\\dots+A_i$, where $k$ is the number of trailing zeros in $i$\u0026rsquo;s binary representation. This $2^k$ is the lowbit of $i$.\nAbout the lowbit Function\n$\\to~$Definition:\n$\\mathrm{lowbit}(0)$ is undefined. For $x \u003e 0$, $\\mathrm{lowbit}(x)=2^k$, where $k$ is the number of trailing zeros in $x$\u0026rsquo;s binary representation. $\\to~$Examples: $\\mathrm{lowbit}(10010_2)=10_2$; $\\mathrm{lowbit}(10000_2)=10000_2$\n$\\to~$C/C++ Implementation:\n1 2 3 inline int lowbit(int x) { return x \u0026amp; -x; } Or as a macro:\n1 #define lowbit(x) (x) \u0026amp; -(x) $$\rl:=i-\\mathrm{lowbit}(i)+1\\\\\rr:=i\\\\\rB_i=\\sum_{j=l}^{r} A_j\r$$This allows $\\mathcal O(\\log n)$ prefix sums (prefixSum(x)) and updates (update(x, k)). Interval sums $[L,R]$ are computed as segmentSum(l, r) = prefixSum(r) - prefixSum(l - 1). Code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;cstdio\u0026gt; using namespace std; template \u0026lt;typename value_type\u0026gt; class fenwick_tree { private: const int n; value_type* a; inline int lowbit(int x) { return x \u0026amp; -x; } public: inline fenwick_tree(int m): n(m) { a = new value_type[n + 1]; for(int i=0; i\u0026lt;=n; i++) a[i] = 0; } inline ~fenwick_tree() { delete[] a; } inline value_type prefixSum(int i) { value_type res = 0; for(; i; i-=lowbit(i)) res += a[i]; return res; } inline value_type segmentSum(int l, int r) { return prefixSum(r) - prefixSum(l - 1); } inline void update(int i, const value_type\u0026amp; d) { for(; i\u0026lt;=n; i+=lowbit(i)) a[i] += d; } }; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); fenwick_tree\u0026lt;int\u0026gt; bit(n); for(int i=1; i\u0026lt;=n; i++) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); bit.update(i, a); } while(m--) { int op, x, y; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;op, \u0026amp;x, \u0026amp;y); if(op == 1) bit.update(x, y); else printf(\u0026#34;%d\\n\u0026#34;, bit.segmentSum(x, y)); } return 0; } On Luogu P3374, this code runs in $572\\mathrm{ms}$, compared to ~$2.5\\mathrm{s}$ for a segment tree implementation, highlighting the Fenwick Tree\u0026rsquo;s efficiency.\nExtended Applications\rKnowledge Prerequisite: Discretization\nGiven a sequence $A$, discretization maps elements to $[1,N]$ while preserving order. For $A=(A_1,\\dots,A_N)$, discretized sequence $B=(B_1,\\dots,B_N)$ satisfies:\n$1\\le B_i\\le N$ $A_i \u003c A_j \\Rightarrow B_i \u003c B_j$, $A_i = A_j \\Rightarrow B_i = B_j$, $A_i \u003e A_j \\Rightarrow B_i \u003e B_j$. Counting Inversions\rInversion pairs can be counted using a Fenwick Tree after discretization.\nLuogu P1908 Inversion Pairs\nGiven $A=(A_1,\\dots,A_N)$, count pairs $(i,j)$ where $i A_j$. Constraints: $N\\le 10^5, A_i\\le 10^9$.\nAfter discretizing $A$ to $B$, use a Fenwick Tree to track occurrences. Traverse $B$ while maintaining a running count of elements ‚â§ current $B_i$, subtracting from the total possible pairs $\\frac{N(N-1)}{2}$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 500005 using namespace std; inline int read() { static char c; while((c = getchar()) \u0026lt; \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026gt; \u0026#39;9\u0026#39;); int res = c ^ 48; while((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) res = (res \u0026lt;\u0026lt; 3) + (res \u0026lt;\u0026lt; 1) + (c ^ 48); return res; } template \u0026lt;typename value_type\u0026gt; class fenwick_tree { private: const int n; value_type* a; inline int lowbit(int x) { return x \u0026amp; -x; } public: inline fenwick_tree(int m): n(m) { a = new value_type[n + 1]; for(int i=0; i\u0026lt;=n; i++) a[i] = 0; } inline ~fenwick_tree() { delete[] a; } inline value_type prefixSum(int i) { value_type res = 0; for(++i; i; i-=lowbit(i)) res += a[i]; return res; } inline void update(int i, const value_type\u0026amp; d) { for(++i; i\u0026lt;=n; i+=lowbit(i)) a[i] += d; } }; int a[maxn], rk[maxn]; int main() { int n = read(); for(int i=0; i\u0026lt;n; i++) a[rk[i] = i] = read(); stable_sort(rk, rk + n, [\u0026amp;](int x, int y) -\u0026gt; bool { return a[x] \u0026lt; a[y]; }); // Use stable_sort to handle duplicates fenwick_tree\u0026lt;int\u0026gt; bit(n); long long ans = n * (n - 1LL) \u0026gt;\u0026gt; 1LL; for(int i=0; i\u0026lt;n; i++) { ans -= bit.prefixSum(rk[i]); // Subtract non-inversion pairs bit.update(rk[i], 1); // Dynamically update occurrence count } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } Exercise: CF1676H2 Maximum Crossings (Hard Version)\nRange Updates\rWhile Fenwick Trees don‚Äôt directly support range updates, difference arrays can help:\nLuogu P3368 \u0026ldquo;Fenwick Tree 2 Template\u0026rdquo;\nOperations:\n1 x y k: Add $k$ to all elements in $[x,y]$. 2 x: Query the value at $A_x$. Maintain a difference array $B$ where $B_i = A_i - A_{i-1}$. Range updates become:\n$B_x \\mathrel{+}=k$ $B_{y+1} \\mathrel{-}=k$ Querying $A_x$ is equivalent to summing $B_1$ to $B_x$ via prefixSum(x).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;cstdio\u0026gt; #define maxn 500005 using namespace std; template \u0026lt;typename value_type\u0026gt; class fenwick_tree { private: const int n; value_type* a; inline int lowbit(int x) { return x \u0026amp; -x; } public: inline fenwick_tree(int m): n(m) { a = new value_type[n + 1]; for(int i=0; i\u0026lt;=n; i++) a[i] = 0; } inline ~fenwick_tree() { delete[] a; } inline value_type prefixSum(int i) { value_type res = 0; for(; i; i-=lowbit(i)) res += a[i]; return res; } inline void update(int i, const value_type\u0026amp; d) { for(; i\u0026lt;=n; i+=lowbit(i)) a[i] += d; } }; int a[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); fenwick_tree\u0026lt;int\u0026gt; bit(n); while(m--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if(op == 1) { int l, r, k; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;k); bit.update(l, k); if(r \u0026lt; n) bit.update(r + 1, -k); } else { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); printf(\u0026#34;%d\\n\u0026#34;, a[x] + bit.prefixSum(x)); } } return 0; } Exercises\rLuogu P1168 Median (Finding the $k$-th largest) Luogu P1637 Triples Luogu P6477 Subsequence Issues Luogu P8253 Correct Sorting ABC256 F - Cumulative Cumulative Cumulative Sum Luogu P3372 Segment Tree Template (Try a \u0026ldquo;Super Fenwick Tree\u0026rdquo; approach?) Conclusion\rThe Fenwick Tree efficiently handles point updates and prefix sums. Questions and suggestions are welcome!\nPlease like and share!\n","date":"2022-08-20T20:08:00+08:00","permalink":"https://goodcoder666.github.io/en/p/algonotes-fenwick-tree/","title":"„ÄêAlgorithm Notes„ÄëFenwick Tree/Binary Indexed Tree"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Preface\rThe Knapsack Problem is a classic dynamic programming problem with practical significance.\n0-1 Knapsack\rLuogu P2871 [USACO07DEC] Charm Bracelet S\nAtCoder Educational DP Contest D - Knapsack 1\nThere are $n$ items and a knapsack with total capacity $W$. The $i$-th item has weight $w_i$ and value $v_i$. Determine which items to select such that the total weight does not exceed the capacity while maximizing the total value.\nThis is the fundamental 0-1 Knapsack Problem (each item can be chosen either 0 or 1 times). Let\u0026rsquo;s explore its solution.\n$$\rf_{i,j}=\\begin{cases}\r0 \u0026 (i=0/j=0) \\\\\r\\max(f_{i-1,j},f_{i-1,j-w_i}+v_i) \u0026 (i\u003e0,j\\ge w_i)\r\\end{cases}\r$$\nBy incrementally increasing $i$ and expanding the problem scale, we can solve it. Both time and space complexity are $\\mathcal O(nW)$.\nIn practice, $\\mathcal O(nW)$ space may cause MLE. Hence, we optimize by reusing arrays or using rolling tables.\n$$\rf_j=\\max(f_j,f_{j-w_i}+v_i)\r$$\nNow space complexity reduces to $\\mathcal O(W)$.\nRemember to iterate $j$ in reverse order to prevent overlapping transitions. Reference code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define setmax(x, y) if(x \u0026lt; y) x = y using namespace std; int f[12881]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(n--) { int w, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;v); for(int i=m; i\u0026gt;=w; i--) setmax(f[i], f[i - w] + v); } printf(\u0026#34;%d\\n\u0026#34;, f[m]); return 0; } A variant of 0-1 Knapsack is finding minimum remaining space, where the answer is $(total\\ space - maximum\\ occupied\\ space)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define setmax(x, y) if(x \u0026lt; y) x = y using namespace std; int f[20005]; int main() { int n, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;v, \u0026amp;n); while(n--) { int w; scanf(\u0026#34;%d\u0026#34;, \u0026amp;w); for(int i=v; i\u0026gt;=w; i--) setmax(f[i], f[i - w] + w); } printf(\u0026#34;%d\\n\u0026#34;, v - f[v]); return 0; } Extension: Handling Larger $W$\rAtCoder Educational DP Contest E - Knapsack 2\nThis problem is identical to standard 0-1 Knapsack but with constraints $n\\le 100,W\\le 10^9,v_i\\le 10^3$.\n$$\rf_{i,j}=\\begin{cases}\r+\\infin \u0026 (i=0,j\\ne0) \\\\\r0 \u0026 (i\\ge 0,j=0) \\\\ \\min(f_{i-1,j},f_{i-1,j-v_i}+w_i) \u0026 (i\u003e0,j\u003e0)\r\\end{cases}\r$$\nThe final answer is the maximum $j$ where $f_{n,j}\\le W$. Optimizations include:\nTime: For each $i$, iterate $j$ only up to cumulative value $v_1+\\dots+v_i$ Space: Compress the first dimension and iterate $j$ in reverse Optimized code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; long long f[100005], t, tot, ans; int main() { int n, sz; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;sz); memset(f, 0x3f, sizeof f); f[0] = 0; while(n--) { int w, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;v); tot += v; for(int i=tot; i\u0026gt;=v; i--) if((t = f[i - v] + w) \u0026lt; f[i] \u0026amp;\u0026amp; t \u0026lt;= sz) { f[i] = t; if(i \u0026gt; ans) ans = i; } } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } Unbounded Knapsack\rLuogu P1616 Crazy Herb Gathering\nSimilar to 0-1 Knapsack, but each item can be chosen infinitely.\n$$\rf_{i,j}=\\max(f_{i-1,j},f_{i,j-w_i}+v_i)\r$$$$\r\\begin{aligned}\r0\\text{-}1: \u0026 \\max(f_{i-1,j},f_{i-1,j-w_i}+v_i) \\\\\r\\text{Unbounded}: \u0026 \\max(f_{i-1,j},f_{i,j-w_i}+v_i)\r\\end{aligned}\r$$\nBy changing loop order (forward iteration), we achieve this. Don\u0026rsquo;t forget long long:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define setmax(x, y) if(x \u0026lt; y) x = y using namespace std; long long f[10000005]; int main() { int sz, n; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;sz, \u0026amp;n); while(n--) { int w, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;v); for(int i=w; i\u0026lt;=sz; i++) setmax(f[i], f[i - w] + v); } printf(\u0026#34;%lld\\n\u0026#34;, f[sz]); return 0; } Bounded Knapsack\rLuogu P1776 Treasure Screening\nEach item has a maximum selection count $m_i$. Constraints: $n\\le100,\\sum m_i\\le10^5,W\\le 4\\times10^4$.\nNaive approach (convert to 0-1 Knapsack with $N=\\sum m_i$) yields $\\mathcal O(W\\sum m_i)$ complexity. Optimize via binary splitting: decompose $m_i$ into binary components (e.g., $5=1+2+2$). This reduces time to $\\mathcal O(W\\sum\\log m_i)$. Reference code using binary optimization:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; #define maxw 40004 #define setmax(x, y) if(x \u0026lt; y) x = y using namespace std; int n, w, f[maxw]; inline void add(int a, int b) // a: value, b: weight { for(int i=w; i\u0026gt;=b; i--) setmax(f[i], f[i - b] + a); } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;w); while(n--) { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); for(int i=0; (1\u0026lt;\u0026lt;i)\u0026lt;=c; i++) add(a \u0026lt;\u0026lt; i, b \u0026lt;\u0026lt; i), c -= 1 \u0026lt;\u0026lt; i; if(c) add(a * c, b * c); } printf(\u0026#34;%d\\n\u0026#34;, f[w]); return 0; } Hybrid Knapsack\rCombine all three knapsack types. For example, Luogu P1833 Cherry Blossoms. Handle via conditional branches:\n1 2 3 4 5 6 7 8 for (each item type) { if (0-1 knapsack) apply 0-1 code; else if (unbounded) apply unbounded code; else if (bounded) apply bounded code; } Alternatively, unify handling by setting selection limits:\n0-1: $k_i=1$ Unbounded: $k_i=\\lceil\\frac W{w_i}\\rceil$ Summary\rComparison of three basic knapsack DP types:\nAspect 0-1 Knapsack Unbounded Knapsack Bounded Knapsack Scenario Each item once Unlimited items Limited items State Transition1 $\\max(f_j,f_{j-w_i}+v_i)$ $\\max(f_j,f_{j-w_i}+v_i)$ Similar to 0-1 Time Complexity2 $\\mathcal O(nW)$ $\\mathcal O(nW)$ $\\mathcal O(W\\sum\\log k_i)$ Space Complexity $\\mathcal O(W)$ $\\mathcal O(W)$ $\\mathcal O(W)$ Coding Difficulty Low Low Medium Like this article? Please support with a üëç‚≠êüí¨!\nCompressed $f_j$; 0-1 uses reverse iteration, unbounded uses forward\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUnbounded uses optimized complexity; bounded uses binary optimization\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-08-18T19:05:00+08:00","permalink":"https://goodcoder666.github.io/en/p/algonotes-knapsack-dp/","title":"Three Types of Knapsack Problems ‚Äî Knapsack DP"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Preface\rWe often encounter problems like this in real life:\nHighway Construction\nThere are several cities where highways need to be built between them. Each pair of cities can be connected via a bidirectional road. Each road between two cities has a specific construction cost. How can we construct roads with the minimal total cost while ensuring all cities are connected directly or indirectly?\nWe can abstract this problem by representing cities as graph vertices and roads as weighted undirected edges, forming a weighted undirected graph. Since we want minimal total cost, the constructed roads must form a spanning tree, transforming the problem into:\nGiven a weighted undirected graph $G$, find its spanning tree where the sum of all edge weights is minimized.\nThis is the well-known Minimum Spanning Tree (MST) problem.\nConsider the following graph:\nThe green edges form its minimum spanning tree.\nMathematicians have studied this problem extensively. However, focusing only on correctness without considering simplicity, feasibility, and efficiency led many algorithms to obsolescence. Two algorithms stood out: Kruskal and Prim.\nTemplate Problem: Luogu P3366 „ÄêTemplate„ÄëMinimum Spanning Tree\nData Constraints: $N\\le5000,M\\le2\\times10^5,w\\le 10^4$.\nKruskal\rThe Kruskal algorithm, proposed by Joseph Kruskal in 1956, has a time complexity of $\\mathcal O(m\\log m)$. Let\u0026rsquo;s examine its workflow.\nKruskal Algorithm Workflow\rSort all edges in ascending order of weight and iterate through them. For each edge, if adding it to the current subgraph doesn\u0026rsquo;t form a cycle, include it as part of the MST. The algorithm terminates after selecting $N-1$ edges. Disjoint-Set Union (DSU) ‚Äî Accelerating the Algorithm\rBefore implementing Kruskal, we need DSU. Using DFS for cycle detection would result in $\\mathcal O(nm + m\\log m)$ time complexity, which is inefficient. DSU reduces this to $\\mathcal O(m\\log m)$ (dominated by sorting). DSU Template:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class dsu { private: const int n; int* fa; public: inline dsu(int count): n(count) // Initialize DSU with size n { fa = new int[n]; // Allocate memory for(int i=0; i\u0026lt;n; i++) fa[i] = i; // Initialize fa[i]=i } inline ~dsu() { delete[] fa; } // Prevent memory leaks inline int size() { return n; } // Return DSU size int find(int x) { return fa[x] == x? x: fa[x] = find(fa[x]); } // Find with path compression inline bool same(int x, int y) { return find(x) == find(y); } // Check connectivity inline void merge(int x, int y) { fa[find(x)] = find(y); } // Merge two components inline bool connected() // Check if the entire graph is connected { int p = find(0); for(int i=0; i\u0026lt;n; i++) if(find(i) != p) return false; return true; } }; Using DSU, the algorithm\u0026rsquo;s time complexity becomes $\\mathcal O(m\\log m)$. Now, let\u0026rsquo;s see the code.\nReference Code\rFor readers unfamiliar with DSU, feel free to copy the template first.Study it later\nFor single Kruskal runs, use priority_queue (more efficient than sort). For multiple runs, pre-sort edges.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; // Represents an edge for sorting struct Edge { int from, to, weight; inline bool operator \u0026lt;(const Edge\u0026amp; e2) const { return weight \u0026gt; e2.weight; // Note: Reverse order for priority_queue } inline void read() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;from, \u0026amp;to, \u0026amp;weight); from --, to --; } }; // DSU Template class dsu { private: const int n; int* fa; public: inline dsu(int count): n(count) { fa = new int[n]; for(int i=0; i\u0026lt;n; i++) fa[i] = i; } inline ~dsu() { delete[] fa; } inline int size() { return n; } int find(int x) { return fa[x] == x? x: fa[x] = find(fa[x]); } inline bool same(int x, int y) { return find(x) == find(y); } inline void merge(int x, int y) { fa[find(x)] = find(y); } inline bool connected() { int p = find(0); for(int i=0; i\u0026lt;n; i++) if(find(i) != p) return false; return true; } }; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); // Read vertices and edges priority_queue\u0026lt;Edge\u0026gt; q; // Priority queue for sorting while(m--) { Edge e; e.read(); // Read edge q.push(e); // Enqueue } int ans = 0, // Total weight cnt = 0; // Edge count dsu d(n); // Initialize DSU while(!q.empty() \u0026amp;\u0026amp; cnt \u0026lt; n - 1) // Process edges until n-1 selected { auto [u, v, w] = q.top(); q.pop(); // Extract minimum edge if(!d.same(u, v)) // No cycle formed { d.merge(u, v); // Add edge ans += w, cnt ++; // Update } } if(cnt == n - 1) printf(\u0026#34;%d\\n\u0026#34;, ans); // Output if MST exists else puts(\u0026#34;orz\u0026#34;); // Otherwise... return 0; } Alternative ending (slower but concise):\n1 2 3 4 5 6 7 8 9 10 11 12 13 int ans = 0; dsu d(n); while(!q.empty()) { auto [u, v, w] = q.top(); q.pop(); if(!d.same(u, v)) { d.merge(u, v); ans += w; } } if(d.connected()) printf(\u0026#34;%d\\n\u0026#34;, ans); else puts(\u0026#34;orz\u0026#34;); Prim\rThe Prim algorithm was discovered by Czech mathematician Vojtƒõch Jarn√≠k in 1930, independently by Robert C. Prim in 1957, and rediscovered by Edsger W. Dijkstra in 1959. Hence, it\u0026rsquo;s also called DJP, Jarn√≠k, or Prim-Jarn√≠k algorithm.\nPrim Algorithm Workflow\rSimilar to Dijkstra, vertices are divided into sets $S$ and $T$:\nInitially, all vertices are in $S$, $T$ is empty. Move any vertex from $S$ to $T$. Repeat until all vertices are in $T$: Select edge $(u,v,w)$ where $u\\in S$, $v\\in T$, with minimal $w$. Add this edge to MST and move $u$ to $T$. We present optimized versions using priority_queue and set.\nPriority Queue Optimization\rRuntime: $328\\mathrm{ms}$\nTime Complexity: $\\mathcal O(n\\log m)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define maxn 5005 #define INF 2147483647 using namespace std; using pii = pair\u0026lt;int, int\u0026gt;; vector\u0026lt;pii\u0026gt; G[maxn]; int dis[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int u, v, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); G[--u].emplace_back(--v, w); G[v].emplace_back(u, w); } for(int i=1; i\u0026lt;n; i++) dis[i] = INF; priority_queue\u0026lt;pii, vector\u0026lt;pii\u0026gt;, greater\u0026lt;pii\u0026gt;\u0026gt; q; q.emplace(0, 0); int ans = 0, left = n; while(!q.empty() \u0026amp;\u0026amp; left \u0026gt; 0) { auto [d, v] = q.top(); q.pop(); if(d != dis[v]) continue; dis[v] = -INF, left --, ans += d; for(auto [u, w]: G[v]) if(w \u0026lt; dis[u]) q.emplace(dis[u] = w, u); } if(left) puts(\u0026#34;orz\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } Set Optimization\rRuntime: $351\\mathrm{ms}$\nTime Complexity: $\\mathcal O(n\\log n)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 5005 #define INF 2147483647 using namespace std; using pii = pair\u0026lt;int, int\u0026gt;; vector\u0026lt;pii\u0026gt; G[maxn]; int dis[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int u, v, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); G[--u].emplace_back(--v, w); G[v].emplace_back(u, w); } for(int i=1; i\u0026lt;n; i++) dis[i] = INF; set\u0026lt;pii\u0026gt; s; s.emplace(0, 0); int ans = 0, left = n; while(!s.empty() \u0026amp;\u0026amp; left \u0026gt; 0) { auto it = s.begin(); auto [d, v] = *it; s.erase(it); dis[v] = -INF, left --, ans += d; for(auto [u, w]: G[v]) if(w \u0026lt; dis[u]) { if(dis[u] != INF) s.erase(pii(dis[u], u)); s.emplace(dis[u] = w, u); } } if(left) puts(\u0026#34;orz\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } Exercises\rLuogu P1551 Relatives (DSU practice) UVA1151 Buy or Build (Kruskal) UVA1395 Slim Span (Kruskal) Luogu P1265 Highway Construction (Prim) Summary\rComparison of Kruskal and Prim:\nMetric Kruskal Prim Time Complexity $\\mathcal O(m\\log m)$ $\\mathcal O(n\\log m)$1 Runtime2 $255\\mathrm{ms}$ $328\\mathrm{ms}$ Code Complexity Low Medium Applicability Sparse Graphs Dense Graphs In most cases, Kruskal is preferred. Use Prim for specific requirements.\nIf you find this article helpful, please like/share/bookmark. Thanks for your support!\nFor priority_queue optimization. Set optimization is $\\mathcal O(n\\log n)$.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nResults from Luogu P3366. Kruskal uses DSU+priority_queue; Prim uses priority_queue.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-08-15T11:43:00+08:00","permalink":"https://goodcoder666.github.io/en/p/algonotes-mst/","title":"„ÄêAlgorithm Notes„ÄëKruskal/Prim Algorithms ‚Äî Solving Minimum Spanning Tree Problems"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Introduction\rDijkstra\u0026rsquo;s algorithm solves the single-source shortest path problem with non-negative edge weights in $\\mathcal O(m\\log m)$ or $\\mathcal O(m\\log n)$ time. This article details the algorithm\u0026rsquo;s principles, implementations, and two common optimizations.\nAdditionally, Dijkstra\u0026rsquo;s algorithm should not be overused. For multi-source shortest paths, while Dijkstra\u0026rsquo;s complexity is $\\mathcal O(nm\\log m)$, it\u0026rsquo;s often simpler to use Floyd with $\\mathcal O(n^3)$ time if feasible.\nWithout further ado, let\u0026rsquo;s dive into the algorithm\u0026rsquo;s workflow.\nWorkflow\rDivide nodes into two sets: $S$ (nodes with determined shortest path lengths) and $T$ (nodes with undetermined lengths). Initially, all nodes belong to $T$.\nLet $d_v$ denote the distance from node $v$ to the source, and $s$ be the source. Initialize $d_s=0$ and $d=+\\infin$ for all other nodes.\nRepeat these steps until $T$ is empty:\nSelect the node $v$ with the smallest $d$ from $T$ and move it to $S$. For each neighbor $u$ of $v$, perform relaxation: dis[u] = min(dis[u], dis[v] + G[v][u]). The simplest implementation follows below.\nImplementations\rSample code is applicable to CF20C/Luogu. Input/output formats align with this problem. Constraints: $n,m\\le 10^5,w_i\\le 10^6$.\nTo output the shortest path, define an array $\\mathrm{par}$ where $\\mathrm{par}[i]$ represents the predecessor of node $i$ in the shortest path. Initialize $\\mathrm{par}[s]=-1$.\nWhen updating dis[u] = dis[v] + G[v][u], also set par[u] = v. Finally, backtrack from the destination using par.\nUnoptimized Implementation\rThis brute-force approach strictly follows the algorithm with $\\mathcal O(n^2)$ complexity, which fails the test case.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 100005 using namespace std; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; G[maxn]; long long dis[maxn]; int par[maxn]; bool vis[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int u, v, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;c); G[--u].emplace_back(--v, c); G[v].emplace_back(u, c); } // Dijkstra algorithm steps // Initialization memset(dis, 0x3f, sizeof dis); memset(vis, 0, sizeof vis); dis[0] = 0LL, par[0] = -1; // Distance of the starting point is 0 while(true) { int v = n; // Virtual node with +INF distance for(int i=0; i\u0026lt;n; i++) if(!vis[i] \u0026amp;\u0026amp; dis[i] \u0026lt; dis[v]) v = i; if(v \u0026gt;= n - 1) break; // Exit if no valid node found vis[v] = true; // Mark as visited for(auto [u, d]: G[v]) if(dis[v] + d \u0026lt; dis[u]) // Check for a better path? { dis[u] = dis[v] + d; // Update distance par[u] = v; // Update path } } if(dis[n - 1] == dis[n]) // No solution (disconnected graph) { puts(\u0026#34;-1\u0026#34;); return 0; } vector\u0026lt;int\u0026gt; path; // Store reversed path int v = n - 1; // Backtrack from destination while(v != -1) { path.push_back(v); // Add to path v = par[v]; // Backtrack } for(int i=path.size()-1; i\u0026gt;=0; i--) printf(\u0026#34;%d \u0026#34;, path[i] + 1); // Output return 0; } Test Result:\nPriority Queue Optimization\rPriority queues (binary heaps) support:\nExtracting min/max elements in $\\mathcal O(\\log n)$ Inserting elements in $\\mathcal O(\\log n)$ This achieves $\\mathcal O(m\\log m)$ complexity:\nInitialize with $(s,0)$ in the queue. While queue not empty: Extract $(v,d)$. If $d \\ne \\mathrm{dis}[v]$, skip. Otherwise, relax edges and enqueue updated nodes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define maxn 100005 #define INF 9223372036854775807LL using namespace std; using LL = long long; using pli = pair\u0026lt;LL, int\u0026gt;; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; G[maxn]; LL dis[maxn]; int par[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int u, v, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;c); G[--u].emplace_back(--v, c); G[v].emplace_back(u, c); } for(int i=1; i\u0026lt;n; i++) dis[i] = INF; par[0] = -1; priority_queue\u0026lt;pli, vector\u0026lt;pli\u0026gt;, greater\u0026lt;pli\u0026gt;\u0026gt; q; q.emplace(0LL, 0); while(!q.empty()) { auto [d, v] = q.top(); q.pop(); if(dis[v] == d) for(auto [u, w]: G[v]) if(d + w \u0026lt; dis[u]) par[u] = v, q.emplace(dis[u] = d + w, u); } if(dis[n - 1] == INF) { puts(\u0026#34;-1\u0026#34;); return 0; } vector\u0026lt;int\u0026gt; path; int v = n - 1; while(v != -1) { path.push_back(v); v = par[v]; } for(int i=path.size()-1; i\u0026gt;=0; i--) printf(\u0026#34;%d \u0026#34;, ++path[i]); return 0; } AC, runtime: $93\\text{ms}$\nSet Optimization\rSets allow deletion of arbitrary elements in $\\mathcal O(\\log n)$. By removing obsolete entries, the set size never exceeds $N$, yielding $\\mathcal O(m\\log n)$ complexity. Generally less used but provided below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 100005 #define INF 9223372036854775807LL using namespace std; using LL = long long; using pli = pair\u0026lt;LL, int\u0026gt;; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; G[maxn]; LL dis[maxn]; int par[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int u, v, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;c); G[--u].emplace_back(--v, c); G[v].emplace_back(u, c); } for(int i=1; i\u0026lt;n; i++) dis[i] = INF; par[0] = -1; set\u0026lt;pli\u0026gt; s; s.emplace(0LL, 0); while(!s.empty()) { auto it = s.begin(); s.erase(it); auto [d, v] = *it; for(auto [u, w]: G[v]) if(d + w \u0026lt; dis[u]) { par[u] = v; if(dis[u] != INF) s.erase(pli(dis[u], u)); s.emplace(dis[u] = d + w, u); } } if(dis[n - 1] == INF) { puts(\u0026#34;-1\u0026#34;); return 0; } vector\u0026lt;int\u0026gt; path; int v = n - 1; while(v != -1) { path.push_back(v); v = par[v]; } for(int i=path.size()-1; i\u0026gt;=0; i--) printf(\u0026#34;%d \u0026#34;, ++path[i]); return 0; } AC, runtime: $78\\text{ms}$\nConclusion\rDijkstra\u0026rsquo;s implementations summarized:\nBrute-force ($\\mathcal O(n^2)$, TLE ;() Priority queue ($\\mathcal O(m\\log m)$, $93\\text{ms}$ :|) Set ($\\mathcal O(m\\log n)$, $78\\text{ms}$ :)) ","date":"2022-08-13T12:37:00+08:00","permalink":"https://goodcoder666.github.io/en/p/algonotes-dijkstra/","title":"[Algorithm Notes] Single-Source Shortest Path Problem ‚Äî Dijkstra's Algorithm (Unoptimized/Priority Queue/Set Optimized)"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Preface\rIn graphs, when requiring distances between any two points, we can use Floyd ($\\mathcal O(N^3)$;)Ôºâand Dijkstra ($\\mathcal O(NM\\log M)$:)). For relatively small data ranges (typically vertex count $N\\le 150$), Floyd\u0026rsquo;s algorithm is suitable. This article explains the principles, implementation, and extended applications of Floyd\u0026rsquo;s algorithm.\nIf there are any shortcomings, please feel free to provide feedback. Thank you!\nPrinciple\r$$\rf(x,y)=\r\\begin{cases}\r0 \u0026 (x=y) \\\\\rG[x][y] \u0026 (G[x][y]\\ne0)\\\\\r+\\infty \u0026 (x\\ne y,G[x][y]=0)\r\\end{cases}\r$$\nwhere $G$ is the adjacency matrix of the graph, $G[x][y]$ represents the edge weight from vertex $x$ to $y$, and $0$ indicates no edge between $x$ and $y$.\nNext, consider enumerating intermediate points $k$ and calculating the shortest path via the route $x\\to k\\to y$. The pseudocode is:\n1 2 3 4 for k = 1, 2, ..., n for x = 1, 2, ..., n for y = 1, 2, ..., n f[x][y] = min(f[x][y], f[x][k] + f[k][y]) At this point, the algorithm concludes, and the final $f(x,y)$ represents the shortest path from $x$ to $y$.\nNote: When the given graph is undirected, for any $(x,y)$, $G[x][y]=G[y][x]$, so $f(x,y)=f(y,x)$. The computation process can be adjusted (e.g., using f[k][x]+f[k][y]). However, for directed graphs, strictly follow the order in the pseudocode!\nCode\rThe code for Floyd\u0026rsquo;s algorithm can be submitted on Luogu B3647. Below is the AC code for this problem (note edge-based input):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define maxn 100 using namespace std; int dis[maxn][maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); // Initialize, note that initial values should not exceed INT_MAX/2 (to prevent overflow from adding two INFs) memset(dis, 0x3f, sizeof dis); // Distance from each point to itself is 0 for(int i=0; i\u0026lt;n; i++) dis[i][i] = 0; // Read edges while(m--) { int u, v, d; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;d); u --, v --; // 0-index dis[u][v] = dis[v][u] = d; // Note both values need to be set } // Floyd algorithm process for(int k=0; k\u0026lt;n; k++) // Intermediate point for(int i=0; i\u0026lt;n; i++) // Start point for(int j=0; j\u0026lt;n; j++) // End point { int d = dis[i][k] + dis[k][j]; // i-\u0026gt;k-\u0026gt;j if(d \u0026lt; dis[i][j]) dis[i][j] = d; // Take shortest length } for(int i=0; i\u0026lt;n; i++, putchar(\u0026#39;\\n\u0026#39;)) for(int j=0; j\u0026lt;n; j++) printf(\u0026#34;%d \u0026#34;, dis[i][j]); return 0; } Extension\rNow the question arises: How to output the result path? The method is simple. Similar to Dijkstra but slightly different, let $\\text{path}(x, y)$ be a point on the shortest path from $x\\to y$. When updating $f(x,y)$ during state transition if $f(x,k)+f(k,y) \u003c f(x,y)$, not only update $f(x,y)$ but also set $\\text{path}(x,y):=k$. Finally, recursively output the result.\nProblem Statement\rGiven a simple undirected graph with $N$ vertices and $M$ edges, for every pair $(i,j)$ ($1\\le i \u003c j\\le N$), output every vertex on the shortest path from $i\\to j$.\nSample\rInput:\n1 2 3 4 5 6 7 5 6 3 4 3 4 1 1 4 5 4 1 2 2 5 2 10 3 2 7 Output:\n1 2 3 4 5 6 7 8 9 10 1-\u0026gt;2: 1 2 1-\u0026gt;3: 1 4 3 1-\u0026gt;4: 1 4 1-\u0026gt;5: 1 4 5 2-\u0026gt;3: 2 1 4 3 2-\u0026gt;4: 2 1 4 2-\u0026gt;5: 2 1 4 5 3-\u0026gt;4: 3 4 3-\u0026gt;5: 3 4 5 4-\u0026gt;5: 4 5 Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define maxn 100 using namespace std; int dis[maxn][maxn], path[maxn][maxn]; void print(int x, int y) // Recursively output path x-\u0026gt;y, excluding y { int k = path[x][y]; // x-\u0026gt;k-\u0026gt;y if(k == x || k == y) // Adjacent vertices, output directly printf(\u0026#34; %d\u0026#34;, x); else { // Split into two recursive parts print(x, k); // x-\u0026gt;k print(k, y); // k-\u0026gt;y } } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); // Initialize memset(dis, 0x3f, sizeof dis); for(int i=0; i\u0026lt;n; i++) dis[i][i] = 0; // Read edges while(m--) { int u, v, d; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;d); dis[u][v] = dis[v][u] = d; // Note both values need to be set path[u][v] = path[v][u] = u; // Initialize path } // Floyd algorithm process, using 1-index for easier output for(int k=1; k\u0026lt;=n; k++) // Intermediate point for(int i=1; i\u0026lt;=n; i++) // Start point for(int j=1; j\u0026lt;=n; j++) // End point { int d = dis[i][k] + dis[k][j]; // i-\u0026gt;k-\u0026gt;j if(d \u0026lt; dis[i][j]) // Update shortest path dis[i][j] = d, path[i][j] = k; } // Enumerate (i,j) and output paths for(int i=1; i\u0026lt;n; i++) for(int j=i+1; j\u0026lt;=n; j++) { printf(\u0026#34;%d-\u0026gt;%d:\u0026#34;, i, j); print(i, j); printf(\u0026#34; %d\\n\u0026#34;, j); } return 0; } Note: Since the length of each path won\u0026rsquo;t exceed $N$, the overall time complexity remains $\\mathcal O(N^3)$.\nEpilogue\rSummary: Floyd\u0026rsquo;s algorithm has a time complexity of $\\mathcal O(N^3)$ and is convenient to implement. If you found this helpful, please give a like/share/follow‚Äîthank you for your support!\n","date":"2022-08-12T21:07:00+08:00","permalink":"https://goodcoder666.github.io/en/p/algonotes-floyd/","title":"„ÄêAlgorithm Notes„ÄëMulti-source Shortest Path Problem‚Äî‚ÄîFloyd's Algorithm"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Definition\rTree DP, also known as Tree-shaped DP, refers to DP (Dynamic Programming) performed on trees, and is one of the more complex types in DP algorithms.\nBasics\rLet $f[u]=~$data related to tree node $u$, and perform $\\text{DP}$ in topological order (from leaf nodes up to the root) to ensure a node\u0026rsquo;s children have updated DP values before updating the current node. Typically implemented via DFS:\n1 2 3 4 5 6 7 void dfs(int v) { // Traverse node v dp[v] = ...; // Initialize for(int u: G[v]) { // Traverse all children of v dfs(u); update(u, v); // Update current node\u0026#39;s DP value using child\u0026#39;s DP value } } „ÄêExample 1.1„ÄëSubtree Size\rGiven a tree with $N$ nodes rooted at node 1. For each $i=1,2,\\dots,N$, compute the size of the subtree rooted at node $i$.\n$$\rf[v]=1+\\sum_{i=1}^{\\text{deg}_v} G[v][i]\r$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 100 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; // Adjacency list int sz[maxn]; // DP array, sz[v] = size of subtree v void dfs(int v) { sz[v] = 1; // Initial size is 1 for(int u: G[v]) // Traverse children { dfs(u); sz[v] += sz[u]; // Update subtree size } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=1; i\u0026lt;n; i++) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[u].push_back(v); } dfs(1); for(int i=1; i\u0026lt;=n; i++) printf(\u0026#34;%d\\n\u0026#34;, sz[i]); return 0; } „ÄêExample 1.2„ÄëLuogu P1352 No Boss\u0026rsquo;s Party\rThis is the Maximum Independent Set on a Tree problem.\nLet $f(v)$ be the optimal solution when selecting $v$, and $g(v)$ when not selecting $v$. Transitions:\n$g(v)=\\sum\\max\\{f(u),g(u)\\}$; $f(v)=r_i+\\sum g(u)$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 6005 using namespace std; inline int max(int x, int y) { return x \u0026gt; y? x: y; } vector\u0026lt;int\u0026gt; G[maxn]; bool bad[maxn]; int f[maxn], g[maxn]; void dfs(int v) { for(int u: G[v]) { dfs(u); f[v] += g[u]; g[v] += max(f[u], g[u]); } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, f + i); for(int i=1; i\u0026lt;n; i++) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[--v].push_back(--u); bad[u] = true; } int root = -1; for(int i=0; i\u0026lt;n; i++) if(!bad[i]) { root = i; break; } dfs(root); printf(\u0026#34;%d\\n\u0026#34;, max(f[root], g[root])); return 0; } Exercises\rHDU 2196 Computer / vjudge POJ 1463 Strategic game Luogu P3574 [POI2014] FAR-FarmCraft Tree Knapsack\r„ÄêExample 2.1„ÄëLuogu P2014 / AcWing 286 Course Selection\rConstruct a tree with virtual root 0. Let $f[i][j]$ be the maximum credit when selecting $j$ courses in subtree $i$. Add 1 to $M$ since root 0 must be selected.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 305 using namespace std; inline void setmax(int\u0026amp; x, int y) { if(x \u0026lt; y) x = y; } vector\u0026lt;int\u0026gt; G[maxn]; int n, m, f[maxn][maxn]; int dfs(int u) { int tot = 1; for(int v: G[u]) { int sz = dfs(v); for(int i=min(tot, m); i\u0026gt;0; i--) for(int j=1, lim=min(sz, m-i); j\u0026lt;=lim; j++) setmax(f[u][i + j], f[u][i] + f[v][j]); tot += sz; } return tot; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=1; i\u0026lt;=n; i++) { int a; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, f[i] + 1); G[a].push_back(i); } m ++; dfs(0); printf(\u0026#34;%d\\n\u0026#34;, f[0][m]); return 0; } Exercises\rLOJ #2546. „ÄåJSOI2018„ÄçCovert Operation LOJ #2268. „ÄåSDOI2017„ÄçApple Tree Rerooting DP\r„ÄêExample 3.1„ÄëLuogu P3478 [POI2008] STA-Station\rCompute depth sum for all nodes when treating each node as root. Use two-pass DFS for $\\mathcal O(N)$ solution.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 1000005 using namespace std; using LL = long long; vector\u0026lt;int\u0026gt; G[maxn]; LL sz[maxn], f[maxn]; int n, ans; LL dfs1(int v, int d, int par) { sz[v] = 1; LL s = d; for(int u: G[v]) if(u != par) s += dfs1(u, d + 1, v), sz[v] += sz[u]; return s; } void dfs2(int v, int par) { if(f[v] \u0026gt; f[ans]) ans = v; for(int u: G[v]) if(u != par) { f[u] = f[v] + n - (sz[u] \u0026lt;\u0026lt; 1LL); dfs2(u, v); } } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int t=n; --t; ) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[--u].push_back(--v); G[v].push_back(u); } f[0] = dfs1(0, 0, -1); dfs2(0, -1); printf(\u0026#34;%d\\n\u0026#34;, ++ans); return 0; } Exercises\rPOJ 3585 Accumulation Degree Luogu P2986 [USACO10MAR] Great Cow Gathering G CodeForce 708C Centroids ABC 222F - Expensive Expense Postscript\rTurns out it\u0026rsquo;s not as hard as it initially seemed\u0026hellip; Remember to like and share!\nReferences:\nTree DP - OI wiki Tree DP - tom0727\u0026rsquo;s blog „ÄêDynamic Programming„ÄëComplete Guide to Tree DP! - RioTian - Blog Garden ","date":"2022-08-12T10:15:00+08:00","permalink":"https://goodcoder666.github.io/en/p/algonotes-tree-dp/","title":"„ÄêAlgorithm Notes„ÄëTree DP Algorithm Summary \u0026 Detailed Explanation"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Full House\rProblem Summary\rTranslation from a passionate card game enthusiast qwq\nGiven five card numbers $A,B,C,D,E$ from a poker deck, determine if they form a \u0026ldquo;three-of-a-kind plus a pair\u0026rdquo;. (Baidu it if unclear\nConstraints: $1\\le A,B,C,D,E\\le 13$, and not all $A,B,C,D,E$ are identical.\nInput Format\r$A~B~C~D~E$\nOutput Format\rPrint Yes if a full house, otherwise No.\nSample Cases\r$A$ $B$ $C$ $D$ $E$ Output $1$ $2$ $1$ $2$ $1$ Yes $12$ $12$ $11$ $1$ $2$ No Analysis\rHehe, amused by startled by my own translation‚Äînever seen such a good terrible one!\nStraightforward problem. Count frequencies and check for exactly two and three counts. See code.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; using namespace std; int cnt[13]; int main() { for(int i=0; i\u0026lt;5; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); cnt[--x] ++; } bool has2 = false, has3 = false; for(int i=0; i\u0026lt;13; i++) if(cnt[i] == 2) has2 = true; else if(cnt[i] == 3) has3 = true; puts(has2 \u0026amp;\u0026amp; has3? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Ancestor\rProblem Summary\rThere are $N$ people. The parent of the $i$-th person is $P_i$, guaranteed $P_i \u003c i$.\nFind how many generations apart the $N$-th person is from the 1st person.\n$2\\le N\\le 50$\n$1\\le P_i \u003c i$\nInput Format\r$N$\n$P_2~P_3~\\dots~P_N$\nOutput Format\rPrint the answer.\nAnalysis\rNo DFS needed. Compute depth iteratively: $\\text{depth}_i = \\text{depth}_{P_i} + 1$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;cstdio\u0026gt; #define maxn 55 using namespace std; int dep[maxn]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=1; i\u0026lt;n; i++) { int f; scanf(\u0026#34;%d\u0026#34;, \u0026amp;f); dep[i] = dep[--f] + 1; } printf(\u0026#34;%d\\n\u0026#34;, dep[n - 1]); return 0; } C - Monotonically Increasing\rProblem Summary\rPrint all strictly increasing sequences of length $N$ with elements in $[1,M]$ in lex order. $1\\le N\\le M\\le 10$.\nInput Format\r$N~M$\nOutput Format\rPrint each sequence in lex order, one per line, space-separated.\nAnalysis\rBasic backtracking problem. See code.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; #define maxn 15 using namespace std; int n, m, ans[maxn]; void dfs(int pos, int last) { if(pos == n) { for(int i=0; i\u0026lt;n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); putchar(\u0026#39;\\n\u0026#39;); return; } while(++last \u0026lt;= m) { ans[pos] = last; dfs(pos + 1, last); } } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); dfs(0, 0); return 0; } D - Left Right Operation\rProblem Summary\rGiven integer sequence $A=(A_1,A_2,\\dots,A_N)$, perform at most one left operation (replace first $x$ elements with $L$) and one right operation (replace last $y$ elements with $R$). Find the minimal possible sum.\n$1\\le N\\le 2\\times 10^5$\n$-10^9\\le L,R,A_i\\le 10^9$\nInput Format\r$N~L~R$\n$A_1~A_2~\\dots~A_N$\nOutput Format\rPrint the minimal sum.\nAnalysis\rPrecompute prefix $f_i$ (min sum for first $i$ elements using left operations) and suffix $g_i$ (min sum for last $i$ elements using right operations). Answer is $\\min(f_i + g_{N-i})$.\nTime complexity: $\\mathcal O(N)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; using LL = long long; inline LL min(const LL\u0026amp; x, const LL\u0026amp; y) { return x \u0026lt; y? x: y; } int a[maxn]; LL f[maxn], g[maxn]; int main() { int n, l, r; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;l, \u0026amp;r); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); f[0] = min(l, a[0]); for(int i=1; i\u0026lt;n; i++) f[i] = min(f[i - 1] + a[i], (i + 1LL) * l); for(int i=n-1; i\u0026gt;=0; i--) g[i] = min(g[i + 1] + a[i], LL(n - i) * r); LL ans = g[0]; for(int i=0; i\u0026lt;n; i++) ans = min(ans, f[i] + g[i + 1]); printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } E - Sugoroku 3\rProblem Summary\r$N$ squares. On squares $1$ to $N-1$, a die outputs $0,1,\\dots,A_i$ uniformly. Move forward by the die result. Find the expected steps to reach square $N$, modulo $998244353$.\n$2\\le N\\le 2\\times 10^5$\n$1\\le A_i\\le N-i$ ($1\\le i \u003c N$)\nRational Number Modulo\nFor division, compute $A \\times B^{MOD-2} \\bmod MOD$.\nInput Format\r$N$\n$A_1~A_2~\\dots~A_{N-1}$\nOutput Format\rPrint the answer modulo $998244353$.\nAnalysis\r$$\r\\text{dp}_i = \\frac{\\sum_{j=i}^{i+A_i} \\text{dp}_j}{A_i+1} + 1\r$$\nSolve for $\\text{dp}_i$ and use suffix sums for optimization. Time complexity: $\\mathcal O(N \\log P)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 #define MOD 998244353 using namespace std; using LL = long long; int a[maxn], suf[maxn]; inline int inv(LL x) { LL res = 1LL; int p = MOD - 2; while(p) { if(p \u0026amp; 1) (res *= x) %= MOD; (x *= x) %= MOD, p \u0026gt;\u0026gt;= 1; } return res; } int main() { int n, cur; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n-1; i++) scanf(\u0026#34;%d\u0026#34;, a + i); for(int i=n-2; i\u0026gt;=0; i--) { int t = suf[i + 1] - suf[i + 1 + a[i]]; if(t \u0026lt; 0) t += MOD; cur = (a[i] + t + 1LL) % MOD * inv(a[i]) % MOD; if((suf[i] = suf[i + 1] + cur) \u0026gt;= MOD) suf[i] -= MOD; } printf(\u0026#34;%d\\n\u0026#34;, cur); return 0; } ","date":"2022-08-07T19:45:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc263/","title":"LINE Verda Programming Contest (AtCoder Beginner Contest 263) A-E Solutions"},{"content":"Preface\rRecently being idle at home, I came across a friend @studentWheat who shared a Tkinter-based account book. I decided to collaborate with him to improve the program.\nScreenshots:\nBackend\rThe backend was mainly developed by my friend. Here\u0026rsquo;s the core code:\nsrc/api.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 from collections import defaultdict class ApiError(RuntimeError): pass def openFile(filename): \u0026#39;\u0026#39;\u0026#39; Open file. File format: 4 lines per record for date, event type, money delta, and note. Such as: (file.example, encoding=utf-8) (Record 1) (ln 1) date1 (ln 2) event_type1 (ln 3) money_delta1 (ln 4) note1 (Record 2) (ln 5) date2 (ln 6) event_type2 (ln 7) money_delta2 (ln 8) note2 @param filename: File name. Returns: data in the format [[date1, event_type1, money_delta1, note1], ...] \u0026#39;\u0026#39;\u0026#39; with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: res = [] while date := f.readline(): if (etype := f.readline()) and (mdelta := f.readline()) and (note := f.readline()): res.append([date.rstrip(\u0026#39;\\n\u0026#39;), etype.rstrip(\u0026#39;\\n\u0026#39;), mdelta.rstrip(\u0026#39;\\n\u0026#39;), note.rstrip(\u0026#39;\\n\u0026#39;)]) else: raise ApiError(\u0026#39;Unexpected EOF at \u0026#39; + filename) return res def saveFile(filename, data): # Save \u0026#39;\u0026#39;\u0026#39; Save with the same format mentioned in openFile(). @param filename: File name. @param data: Data with the same format returned in openFile(). \u0026#39;\u0026#39;\u0026#39; with open(filename, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: for line in data: print(*line, sep=\u0026#39;\\n\u0026#39;, file=f) def query(data, key): return [record for record in data if any(key in x for x in record)] if key else data def total(data): in_total = out_total = 0 for _, _, mdelta, _ in data: mdelta = int(mdelta) if mdelta \u0026lt; 0: out_total -= mdelta else: in_total += mdelta return in_total, out_total def totalByEvent(data): cnt = defaultdict(lambda: [0, 0]) for _, event, mdelta, _ in data: mdelta = int(mdelta) if mdelta \u0026lt; 0: cnt[event][1] -= mdelta else: cnt[event][0] += mdelta return cnt def totalByDate(data): cnt = defaultdict(lambda: [0, 0]) for date, _, mdelta, _ in data: mdelta = int(mdelta) if mdelta \u0026lt; 0: cnt[date][1] -= mdelta else: cnt[date][0] += mdelta return cnt For details, see https://blog.csdn.net/qq_67190987/article/details/125918530.\nFrontend\rAs stated in the title, we used Qt6+Python with two framework options (PyQt6 and PySide6). Here we chose PySide6.\nResource Preparation\rStore all image resources under src/icons:\nDesigner Window Layout\rUse Qt Designer to create windows:\nDependency Installation\rCreate requirements.txt with:\n1 PySide6\u0026gt;=6.3.1 Then run in cmd:\n1 pip install -r requirements.txt Resource and UI Compilation\rCompile files using pyside6-uic and pyside6-rcc. Output structure:\n1 2 3 4 5 6 7 8 9 10 11 AccountBook ‚îî‚îÄsrc ‚îÇ dlgAdd.ui ‚îÇ dlgCharts.ui ‚îÇ MainWindow.ui ‚îÇ res.qrc ‚îÇ res_rc.py ‚îÇ ui_dlgAdd.py ‚îÇ ui_dlgCharts.py ‚îÇ ui_dlgHelp.py ‚îÇ ui_MainWindow.py Code Implementation\rsrc/dlgAdd.py\n\u0026ldquo;Add Account\u0026rdquo; window - a simple QDialog instance.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from PySide6.QtWidgets import * from PySide6.QtCore import QDate, QRegularExpression from PySide6.QtGui import QRegularExpressionValidator from ui_dlgAdd import Ui_Dialog class dlgAdd(QDialog): def __init__(self, parent=None): super().__init__(parent) self.ui = Ui_Dialog() self.ui.setupUi(self) self.ui.dateEdit.setDate(QDate.currentDate()) self.ui.moneyEdit.setValidator(QRegularExpressionValidator(QRegularExpression(r\u0026#39;(\\+|\\-)[1-9]+[0-9]*\u0026#39;))) self.ui.buttonBox.button(QDialogButtonBox.Ok).setText(\u0026#39;Confirm\u0026#39;) self.ui.buttonBox.button(QDialogButtonBox.Cancel).setText(\u0026#39;Cancel\u0026#39;) def getRow(self): date = self.ui.dateEdit.text() event = self.ui.eventEdit.text() money = self.ui.moneyEdit.text() note = self.ui.noteEdit.text() return [date, event, money, note] def accept(self): if not self.ui.eventEdit.text(): QMessageBox.critical(self, \u0026#34;Error\u0026#34;, \u0026#34;Event cannot be empty. Please fill in.\u0026#34;) return if self.ui.moneyEdit.text() in (\u0026#39;\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;): QMessageBox.critical(self, \u0026#34;Error\u0026#34;, \u0026#34;Amount cannot be empty. Please fill in.\u0026#34;) return return super().accept() src/dlgCharts.py\nChart display window using QtCharts (usage differs slightly from PyQt5/PySide2). More chart types may be added later.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 from bisect import bisect_left, bisect_right from PySide6.QtCore import QDate, Qt from PySide6.QtWidgets import * from PySide6.QtCharts import QBarCategoryAxis, QBarSeries, QBarSet, QChart, QChartView, QValueAxis from api import total, totalByDate, totalByEvent from ui_dlgCharts import Ui_Dialog class dlgCharts(QDialog): def __init__(self, data, parent=None): super().__init__(parent) self.ui = Ui_Dialog() self.ui.setupUi(self) self.showMaximized() self.data = data minDate = QDate.fromString(data[0][0], \u0026#39;yyyy/MM/dd\u0026#39;) maxDate = QDate.fromString(data[-1][0], \u0026#39;yyyy/MM/dd\u0026#39;) self.ui.startDateEdit.setDateRange(minDate, maxDate) self.ui.endDateEdit.setDateRange(minDate, maxDate) self.ui.startDateEdit.setDate(minDate) self.ui.endDateEdit.setDate(maxDate) self.__update_totalChart(*total(data)) self.__update_eventChart(totalByEvent(data)) self.__update_dateChart(totalByDate(data)) self.ui.startDateEdit.editingFinished.connect(self.__updateCharts) self.ui.endDateEdit.editingFinished.connect(self.__updateCharts) @staticmethod def createChart(chartView: QChartView, title, xAxis, yAxisList): chart = QChart() chart.setTitle(title) chart.setAnimationOptions(QChart.SeriesAnimations) series = QBarSeries() for axisName, data in yAxisList: barSet = QBarSet(axisName) barSet.append(data) series.append(barSet) chart.addSeries(series) axisX = QBarCategoryAxis() axisX.append(xAxis) chart.addAxis(axisX, Qt.AlignBottom) series.attachAxis(axisX) axisY = QValueAxis() axisY.setLabelFormat(\u0026#39;%d\u0026#39;) chart.addAxis(axisY, Qt.AlignLeft) series.attachAxis(axisY) chartView.setChart(chart) def __update_totalChart(self, total_in, total_out): self.createChart( chartView = self.ui.totalView, title = \u0026#39;Total Income \u0026amp; Expense\u0026#39;, xAxis = [\u0026#39;Income\u0026#39;, \u0026#39;Expense\u0026#39;], yAxisList = [ (\u0026#39;Amount\u0026#39;, [total_in, total_out]) ] ) def __update_eventChart(self, events): self.createChart( chartView = self.ui.eventView, title = \u0026#39;Category Statistics\u0026#39;, xAxis = list(events.keys()), yAxisList = [ (\u0026#39;Income\u0026#39;, list(map(lambda x: x[0], events.values()))), (\u0026#39;Expense\u0026#39;, list(map(lambda x: x[1], events.values()))) ] ) def __update_dateChart(self, dates): self.createChart( chartView = self.ui.dateView, title = \u0026#39;Daily Statistics\u0026#39;, xAxis = list(dates.keys()), yAxisList = [ (\u0026#39;Income\u0026#39;, list(map(lambda x: x[0], dates.values()))), (\u0026#39;Expense\u0026#39;, list(map(lambda x: x[1], dates.values()))) ] ) def __updateCharts(self): startDate = self.ui.startDateEdit.text() endDate = self.ui.endDateEdit.text() left = bisect_left(self.data, startDate, key=lambda x: x[0]) right = bisect_right(self.data, endDate, key=lambda x: x[0]) data = self.data[left:right] self.__update_totalChart(*total(data)) self.__update_eventChart(totalByEvent(data)) self.__update_dateChart(totalByDate(data)) src/main.py\nMain program handling the main window. The most complex part is QTableView with search and sorting features.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 import sys from bisect import insort_right from functools import partial from os.path import basename from webbrowser import open_new_tab from PySide6.QtWidgets import * from PySide6.QtCore import Slot, QDate from PySide6.QtGui import QStandardItem, QStandardItemModel from api import ApiError, openFile, query, saveFile from dlgAdd import dlgAdd from dlgCharts import dlgCharts from ui_dlgHelp import Ui_Dialog as Ui_dlgHelp from ui_MainWindow import Ui_MainWindow # Version info VERSION = \u0026#39;1.0.1\u0026#39; CHANNEL = \u0026#39;stable\u0026#39; BUILD_DATE = \u0026#39;2022-07-01\u0026#39; FULL_VERSION = f\u0026#39;{VERSION}-{CHANNEL} ({BUILD_DATE}) on {sys.platform}\u0026#39; app = QApplication(sys.argv) class AccountBookMainWindow(QMainWindow): version_str = \u0026#39;Account Book \u0026#39; + VERSION unsaved_tip = \u0026#39;*\u0026#39; SUPPORTED_FILTERS = \u0026#39;Account Book Files(*.abf);;Text Files(*.txt);;All Files(*.*)\u0026#39; def __init__(self, parent=None): # Initialize window super().__init__(parent) self.ui = Ui_MainWindow() self.ui.setupUi(self) self.setWindowTitle(\u0026#39;Account Book \u0026#39; + VERSION) self.labStatus = QLabel(self) self.ui.statusBar.addWidget(self.labStatus) # Initialize table self.model = QStandardItemModel(0, 4, self) self.model.setHorizontalHeaderLabels([\u0026#39;Date\u0026#39;, \u0026#39;Event\u0026#39;, \u0026#39;Amount\u0026#39;, \u0026#39;Note\u0026#39;]) self.ui.table.setModel(self.model) self.ui.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch) self.__data = [] self.on_actFile_New_triggered() self.ui.actEdit_Remove.setEnabled(False) # Connect slots self.ui.table.selectionModel().selectionChanged.connect(self.__selectionChanged) self.model.itemChanged.connect(self.__itemChanged) def __updateTable(self, data): self.model.itemChanged.disconnect(self.__itemChanged) self.model.setRowCount(len(data)) for row in range(len(data)): for col in range(len(data[row])): self.model.setItem(row, col, QStandardItem(data[row][col])) self.model.itemChanged.connect(self.__itemChanged) def __openFile(self, filename): try: self.__data = openFile(filename) except IOError: QMessageBox.critical(self, \u0026#39;Error\u0026#39;, \u0026#39;Failed to open file. Please try again.\u0026#39;) except ApiError: QMessageBox.critical(self, \u0026#39;Error\u0026#39;, \u0026#39;File format error. Check file integrity.\u0026#39;) except Exception as e: QMessageBox.critical(self, \u0026#39;Error\u0026#39;, \u0026#39;Unknown error: \u0026#39; + str(e.with_traceback())) else: self.ui.searchEdit.clear() self.__key = \u0026#39;\u0026#39; self.__updateTable(self.__data) self.labStatus.setText(filename) self.setWindowTitle(self.version_str) self.__filename = filename def __saveFile(self, filename): try: saveFile(filename, self.__data) except IOError: QMessageBox.critical(self, \u0026#39;Error\u0026#39;, \u0026#39;Failed to save file. Please try again.\u0026#39;) except Exception as e: QMessageBox.critical(self, \u0026#39;Error\u0026#39;, \u0026#39;Unknown error: \u0026#39; + str(e.with_traceback())) else: self.labStatus.setText(\u0026#39;Saved: \u0026#39; + filename) self.setWindowTitle(self.version_str) self.__filename = filename @Slot() def on_actFile_New_triggered(self): self.__filename = self.__key = \u0026#39;\u0026#39; self.setWindowTitle(self.unsaved_tip + self.version_str) self.labStatus.setText(\u0026#39;New File\u0026#39;) self.model.setRowCount(0) self.__data.clear() @Slot() def on_actFile_Open_triggered(self): filename, _ = QFileDialog.getOpenFileName(self, \u0026#39;Open\u0026#39;, filter=self.SUPPORTED_FILTERS) if filename: self.__openFile(filename) @Slot() def on_actFile_Save_triggered(self): if self.__filename: self.__saveFile(self.__filename) else: filename, _ = QFileDialog.getSaveFileName(self, \u0026#39;Save\u0026#39;, filter=self.SUPPORTED_FILTERS) if filename: self.__saveFile(filename) @Slot() def on_actFile_SaveAs_triggered(self): filename, _ = QFileDialog.getSaveFileName(self, \u0026#39;Save As\u0026#39;, filter=self.SUPPORTED_FILTERS) if filename: self.__saveFile(filename) @Slot() def on_actHelp_About_triggered(self): dialog = QDialog(self) ui = Ui_dlgHelp() ui.setupUi(dialog) for link in (ui.githubLink, ui.giteeLink, ui.licenseLink, ui.readmeLink): link.clicked.connect(partial(open_new_tab, link.description())) ui.labVersion.setText(\u0026#39;Version: \u0026#39; + FULL_VERSION) ui.btnUpdate.clicked.connect(partial(open_new_tab, \u0026#39;https://github.com/GoodCoder666/AccountBook/releases\u0026#39;)) dialog.exec() @Slot() def on_actHelp_AboutQt_triggered(self): QMessageBox.aboutQt(self, \u0026#39;About Qt\u0026#39;) @Slot() def on_actEdit_Add_triggered(self): dialog = dlgAdd(self) if dialog.exec() == QDialog.Accepted: row = dialog.getRow() insort_right(self.__data, row) self.__updateTable(query(self.__data, self.__key)) self.setWindowTitle(self.unsaved_tip + self.version_str) @Slot() def on_actEdit_Remove_triggered(self): rows = list(set(map(lambda idx: idx.row(), self.ui.table.selectedIndexes()))) for row in rows: self.__data.remove([self.model.item(row, col).text() for col in range(self.model.columnCount())]) self.model.itemChanged.disconnect(self.__itemChanged) self.model.removeRows(rows[0], len(rows)) self.model.itemChanged.connect(self.__itemChanged) self.setWindowTitle(self.unsaved_tip + self.version_str) def __selectionChanged(self): self.ui.actEdit_Remove.setEnabled(self.ui.table.selectionModel().hasSelection()) def __itemChanged(self, item: QStandardItem): i, j, new = item.row(), item.column(), item.text() if (old := self.__data[i][j]) == new: return if j == 0 and not QDate.fromString(new, \u0026#39;yyyy/MM/dd\u0026#39;).isValid(): QMessageBox.critical(self, \u0026#39;Error\u0026#39;, \u0026#39;Invalid date format.\u0026#39;) self.model.itemChanged.disconnect(self.__itemChanged) item.setText(old) self.model.itemChanged.connect(self.__itemChanged) return row = self.__data.pop(i) row[j] = new insort_right(self.__data, row) self.__updateTable(query(self.__data, self.__key)) self.setWindowTitle(self.unsaved_tip + self.version_str) @Slot() def on_searchEdit_textChanged(self): self.__key = self.ui.searchEdit.text() self.__updateTable(query(self.__data, self.__key)) @Slot() def on_actStat_Show_triggered(self): if self.__data: dlgCharts(self.__data, self).exec() else: QMessageBox.information(self, \u0026#39;Info\u0026#39;, ","date":"2022-07-23T08:00:00+08:00","permalink":"https://goodcoder666.github.io/en/p/pyside6-accountbook/","title":"PyQt6/PySide6: Building an Account Book Frontend„ÄêComplete Project Address Included„Äë"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - A Unique Letter\rProblem Summary\rGiven a string $S$ of length 3.\nOutput any character that appears exactly once in $S$ (e.g., in abc, any of the three characters can be the answer).\nIf no such character exists, output -1.\nConstraints:\n$S$ has length 3 $S$ consists of lowercase English letters. Input Format\r$S$\nOutput Format\rOutput any valid answer.\nSamples\r$S$ Output pop o abc a/b/c xxx -1 Analysis\rLet the three input characters be a, b, c.\nIf $a = b = c$, output -1. Check for two equal characters in different positions: xxy pattern ($a = b$): output $c$ xyx pattern ($a = c$): output $b$ yxx pattern ($b = c$): output $a$ xyz pattern (all distinct): output any character In the code, the last two cases are merged (handled by a single else, outputting $a$).\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char a = getchar(), b = getchar(), c = getchar(); if(a == b \u0026amp;\u0026amp; b == c) puts(\u0026#34;-1\u0026#34;); else if(a == c) putchar(b); else if(a == b) putchar(c); else putchar(a); return 0; } B - Better Students Are Needed!\rProblem Summary\r$N$ candidates took an exam.\nCandidate $i$ scored $A_i$ in math and $B_i$ in English.\nThe company selects candidates in three stages:\nTop $X$ math scores are selected. From remaining candidates, top $Y$ English scores are selected. From remaining candidates, top $Z$ total scores (math + English) are selected. Note: Candidates with equal scores are ordered by their IDs.\nOutput all selected candidate IDs in ascending order.\nConstraints:\n$1\\le N\\le 1000$\n$0\\le X,Y,Z\\le N$\n$1\\le X+Y+Z\\le N$\n$0\\le A_i,B_i\\le 100$\nInput Format\r$N~X~Y~Z$\n$A_1~A_2~\\dots~A_N$\n$B_1~B_2~\\dots~B_N$\nOutput Format\rOutput selected candidate IDs in ascending order, one per line.\nAnalysis\rTwo approaches:\nUse pair\u0026lt;int, int\u0026gt; for candidates and sort vectors/use priority queues for each selection stage. Use a struct to store candidate data and sort three times with different criteria. See Code 1 and Code 2.\nCode\rCode 1 (vector + sort)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 1005 using namespace std; int a[maxn], b[maxn]; bool used[maxn]; int main() { int n, x, y, z; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;x, \u0026amp;y, \u0026amp;z); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, b + i); // Math vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; sel_a; for(int i=0; i\u0026lt;n; i++) sel_a.emplace_back(-a[i], i); sort(sel_a.begin(), sel_a.end()); for(int i=0; i\u0026lt;x; i++) used[sel_a[i].second] = true; // English vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; sel_b; for(int i=0; i\u0026lt;n; i++) if(!used[i]) sel_b.emplace_back(-b[i], i); sort(sel_b.begin(), sel_b.end()); for(int i=0; i\u0026lt;y; i++) used[sel_b[i].second] = true; // Total vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; sel_t; for(int i=0; i\u0026lt;n; i++) if(!used[i]) sel_t.emplace_back(-(a[i] + b[i]), i); sort(sel_t.begin(), sel_t.end()); for(int i=0; i\u0026lt;z; i++) used[sel_t[i].second] = true; for(int i=0; i\u0026lt;n; i++) if(used[i]) printf(\u0026#34;%d\\n\u0026#34;, i + 1); return 0; } Code 2 (struct-based sorting)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 1005 using namespace std; struct Emp { int math, eng, id; } emps[maxn]; inline bool cmp1(const Emp\u0026amp; e1, const Emp\u0026amp; e2) { return e1.math == e2.math? e1.id \u0026lt; e2.id: e1.math \u0026gt; e2.math; } inline bool cmp2(const Emp\u0026amp; e1, const Emp\u0026amp; e2) { return e1.eng == e2.eng? e1.id \u0026lt; e2.id: e1.eng \u0026gt; e2.eng; } inline bool cmp3(const Emp\u0026amp; e1, const Emp\u0026amp; e2) { int tot1 = e1.math + e1.eng, tot2 = e2.eng + e2.math; return tot1 == tot2? e1.id \u0026lt; e2.id: tot1 \u0026gt; tot2; } inline bool cmp4(const Emp\u0026amp; e1, const Emp\u0026amp; e2) { return e1.id \u0026lt; e2.id; } int main() { int n, x, y, z; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;x, \u0026amp;y, \u0026amp;z); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;emps[i].math), emps[i].id = i; for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;emps[i].eng); auto last = emps + n; sort(emps, last, cmp1); sort(emps + x, last, cmp2); sort(emps + x + y, last, cmp3); sort(emps, emps + x + y + z, cmp4); for(int i=0; i\u0026lt;x+y+z; i++) printf(\u0026#34;%d\\n\u0026#34;, emps[i].id + 1); return 0; } C - Changing Jewels\rProblem Summary\rTakahashi has an level $N$ red jewel.\nHe can perform the following operations any number of times:\nConvert a level $N$ red jewel into \u0026ldquo;1 level $N-1$ red jewel + $X$ level $N$ blue jewels\u0026rdquo;. Convert a level $N$ blue jewel into \u0026ldquo;1 level $N-1$ red jewel + $Y$ level $N-1$ blue jewels\u0026rdquo;. What\u0026rsquo;s the maximum number of level 1 blue jewels he can obtain?\nConstraints:\n$1\\le N\\le 10$\n$1\\le X,Y\\le 5$\nInput Format\r$N~X~Y$\nOutput Format\rOutput the maximum count of level 1 blue jewels.\nSamples\r$N$ $X$ $Y$ Output $2$ $3$ $4$ $12$ $10$ $5$ $5$ $3942349900$ Note: Beware of 32-bit integer overflow.\nAnalysis\rTo maximize level 1 blue jewels, process jewels from higher levels downwards.\nMaintain two variables: red (level $k$ red jewels) and blue (level $k$ blue jewels).\nFor each level from $N$ down to 2:\nConvert all red jewels to lower-level red and blue jewels. Convert all blue jewels to lower-level red and blue jewels. Time complexity: $\\mathcal O(N)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n, x, y; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;x, \u0026amp;y); long long red = 1LL, blue = 0LL; while(--n) { blue += red * x; red += blue, blue *= y; } printf(\u0026#34;%lld\\n\u0026#34;, blue); return 0; } D - Draw Your Cards\rProblem Summary\rProcess $N$ cards with unique numbers $P_1,\\dots,P_N$ in order.\nFor each card $P_i$:\nFind the topmost card in existing piles that is $\\ge P_i$. Place $P_i$ on it. If no such pile exists, create a new pile. If a pile reaches $K$ cards, remove all its cards immediately. Output the time each card is removed (or -1 if never removed).\nConstraints:\n$1\\le K\\le N \\le 2\\times 10^5$\n$P$ is a permutation of $(1,2,\\dots,N)$.\nAnalysis\rUse a Union-Find structure to track parent cards and set-based operations to find the correct pile.\nMaintain a set of current pile tops for efficient lookups.\nFor each card, track the pile size and update when merged.\nTime complexity: $\\mathcal O(N \\log N)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 200005 using namespace std; int fa[maxn], eat[maxn], sz[maxn]; int find(int x) { return fa[x] == x? x: fa[x] = find(fa[x]); } int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); set\u0026lt;int\u0026gt; cards; for(int i=0; i\u0026lt;n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); x --; eat[x] = -1, fa[x] = x; if(k == 1) { eat[x] = i + 1; continue; } auto it = cards.upper_bound(x); if(it == cards.end()) cards.insert(x), sz[x] = 1; else { fa[*it] = x; cards.erase(it); if((sz[x] = sz[*it] + 1) == k) eat[x] = i + 1; else cards.insert(x); } } for(int i=0; i\u0026lt;n; i++) printf(\u0026#34;%d\\n\u0026#34;, eat[find(i)]); return 0; } E - At Least One\rProblem Summary\rGiven $M$ and $N$ pairs $(A_i,B_i)$, count all consecutive subarrays $[l,r]$ of $[1,M]$ such that for each $i$, $A_i$ or $B_i$ is in $[l,r]$.\nLet $f(k)$ be the count of valid subarrays of length $k$. Output $f(1),\\dots,f(M)$.\nConstraints:\n$1\\le N\\le 2\\times 10^5$\n$2\\le M\\le 2\\times 10^5$\n$1\\le A_i \u003c B_i\\le M$\nAnalysis\rUse a sliding window approach. For each $l$, find the smallest $r$ where all pairs are covered.\nPreprocess each position\u0026rsquo;s contribution to coverage and track counts using difference arrays.\nTime complexity: $\\mathcal O(N + M)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 200005 using namespace std; vector\u0026lt;int\u0026gt; inv[maxn]; int cnt[maxn], ans[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;n; i++) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); inv[a].push_back(i); inv[b].push_back(i); } int left = n; for(int i=1, j=1; i\u0026lt;=m; i++) { for(; j \u0026lt;= m \u0026amp;\u0026amp; left \u0026gt; 0; j++) for(int x: inv[j]) if(++cnt[x] == 1) left --; if(left \u0026gt; 0) break; ans[j - i] ++, ans[m - i + 2] --; for(int x: inv[i]) if(--cnt[x] == 0) left ++; } for(int i=1; i\u0026lt;=m; i++) printf(\u0026#34;%d \u0026#34;, ans[i] += ans[i - 1]); return 0; } F - Find 4-cycle\rProblem Summary\rGiven a bipartite graph between sets $U$ and $V$, find any 4-cycle (four nodes forming a cycle). Output the nodes or -1.\nConstraints:\n$2\\le |U| \\le 3\\times 10^5$\n$2\\le |V| \\le 3000$\n$4\\le M\\le \\min(|U|\\times|V|,3\\times 10^5)$\nAnalysis\rExploit the small size of $V$. For each node in $V$, track pairs of nodes in $U$ connected to it. Use a matrix to record pairs and detect overlaps.\nTime complexity: $\\mathcal O(T^2)$, feasible due to $T \\le 3000$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #define maxs 300005 #define maxt 3005 using namespace std; vector\u0026lt;int\u0026gt; G[maxs]; int f[maxt][maxt]; int main() { int s, t, m; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;s, \u0026amp;t, \u0026amp;m); while(m--) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[--u].push_back(--v - s); } memset(f, -1, sizeof(f)); for(int i=0; i\u0026lt;s; i++) for(int j=0; j+1\u0026lt;G[i].size(); j++) for(int k=j+1; k\u0026lt;G[i].size(); k++) { int u = G[i][j], v = G[i][k]; if(u \u0026gt; v) u ^= v ^= u ^= v; if(f[u][v] != -1) { printf(\u0026#34;%d %d %d %d\\n\u0026#34;, f[u][v] + 1, i + 1, u + s + 1, v + s + 1); return 0; } f[u][v] = i; } puts(\u0026#34;-1\u0026#34;); return 0; } ","date":"2022-07-19T20:31:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc260/","title":"AtCoder Beginner Contest 260 A~F Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed D - Trophy\rProblem Statement\rA game consists of $N$ stages. The $i$-th stage is represented by a pair $(A_i, B_i)$.\nTo clear a stage, you must first spend $A_i$ time watching an introduction. Then, it takes $B_i$ time to clear the stage. For subsequent clears of the same stage, the introduction is skipped (i.e., clearing the $i$-th stage $M$ times in total requires $A_i + M \\times B_i$ time).\nInitially, only the first stage is unlocked. After clearing any stage, the next stage is automatically unlocked (except the last stage). Find the minimum time required to clear exactly $X$ stages (repeats count).\n$1\\le N\\le 2\\times 10^5$\n$1\\le A_i,B_i\\le 10^9$\n$1\\le X\\le N$\nInput Format\r$N~X$\n$A_1~B_1$\n$\\vdots$\n$A_N~B_N$\nOutput Format\rPrint the answer.\nSample\rRefer to AtCoder.\nAnalysis\rThe optimal strategy involves clearing some initial stages once, then repeatedly clearing a particular stage. Using prefix sums and enumerating each stage, we achieve $\\mathcal O(n)$ time complexity.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define INF 0x7FFFFFFFFFFFFFFFLL using namespace std; int main() { int n, x; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;x); if(x \u0026lt; n) n = x; long long s = 0LL, ans = INF, cur; for(int i=1; i\u0026lt;=n; i++) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); if((cur = (s += a + b) + (long long)(x - i) * b) \u0026lt; ans) ans = cur; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } E - Packing Potatoes\rProblem Statement\rThere are $10^{100}$ potatoes arranged in a sequence. The weight of the $i$-th potato is $W_{i \\bmod N}$ (weights cycle every $N$ elements).\nTakahashi packs potatoes into boxes sequentially. When the total weight in a box reaches at least $X$, he starts a new box.\nGiven $Q$ queries, each asking for the number of potatoes in the $K_i$-th box.\n$1\\le N,Q\\le 2\\times 10^5$\n$1\\le X,W_i\\le 10^9$\n$1\\le K_i\\le 10^{12}$\nInput Format\r$N~Q~X$\n$W_0~\\dots~W_{N-1}$\n$K_1$\n$\\vdots$\n$K_Q$\nOutput Format\rPrint $Q$ lines, each containing the answer.\nSample\rRefer to AtCoder.\nAnalysis\rCyclic pattern problem.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 200005 using namespace std; using LL = long long; int cnt[maxn], ord[maxn], w[maxn \u0026lt;\u0026lt; 1]; template \u0026lt;typename T\u0026gt; inline T read() { char c; while((c = getchar()) \u0026lt; \u0026#39;0\u0026#39; || c \u0026gt; \u0026#39;9\u0026#39;); T res = c ^ 48; while((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) res = (res \u0026lt;\u0026lt; T(3)) + (res \u0026lt;\u0026lt; T(1)) + (c ^ 48); return res; } inline void print(int x) { if(x \u0026gt; 9) print(x / 10); putchar(x % 10 ^ 48); } inline void println(int x) { print(x); putchar(\u0026#39;\\n\u0026#39;); } int main() { int n = read\u0026lt;int\u0026gt;(), q = read\u0026lt;int\u0026gt;(), x = read\u0026lt;int\u0026gt;(); LL sum = 0LL; for(int i=0; i\u0026lt;n; i++) sum += w[i + n] = w[i] = read\u0026lt;int\u0026gt;(); int fill = x / sum * n; for(int i=0; i\u0026lt;n; i++) cnt[i] = fill, ord[i] = -1; x %= sum; for(int i=0, j=0, s=0; i\u0026lt;n; i++) { if(j \u0026lt; i) j = i, s = 0; while(s \u0026lt; x) { s += w[j]; j += 1; } cnt[i] += j - i; s -= w[i]; } vector\u0026lt;int\u0026gt; path; int loop = -1; for(int u=0, k=0; ; k++) { if(ord[u] != -1) { loop = k - ord[u]; break; } ord[u] = k; path.push_back(u); (u += cnt[u]) %= n; } int non_loop = path.size() - loop; while(q--) { LL k = read\u0026lt;LL\u0026gt;(); println(cnt[path[--k \u0026lt; non_loop? k: non_loop + (k - non_loop) % loop]]); } return 0; } F - Main Street\rWJ...\nG - Triangle\rProblem Statement\rGiven a simple undirected graph $G$ with $N$ vertices and its adjacency matrix $A$:\n$A_{i,j}=1$ indicates an edge between vertices $i$ and $j$ $A_{i,j}=0$ otherwise (with $A_{i,i}=0$ for all $i$) Count the number of triples $(i,j,k)$ satisfying:\n$1\\le i \u003c j \u003c k \\le N$ $A_{i,j}=A_{i,k}=A_{j,k}=1$ $3\\le N\\le 3000$\nInput Format\r$N$\n$A_{1,1}A_{1,2}\\dots A_{1,N}$\n$A_{2,1}A_{2,2}\\dots A_{2,N}$\n$\\vdots$\n$A_{N,1}A_{N,2}\\dots A_{N,N}$ (e.g., 10110)\nOutput Format\rPrint the count.\nSample\rRefer to AtCoder.\nAnalysis\rThe naive $\\mathcal O(N^3)$ approach can be optimized using bitset operations. For each edge $(i,j)$, compute the intersection of $i$\u0026rsquo;s and $j$\u0026rsquo;s adjacency lists, then sum all intersections and divide by 3. Time complexity: $\\mathcal O(N^3 / w)$ where $w$ is bitset width (64).\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;bitset\u0026gt; #define maxn 3000 using namespace std; bitset\u0026lt;maxn\u0026gt; a[maxn]; int main() { int n = 0; char c; while((c = getchar()) != \u0026#39;\\n\u0026#39;) n = (n \u0026lt;\u0026lt; 3) + (n \u0026lt;\u0026lt; 1) + (c ^ 48); for(int i=0; i\u0026lt;n; i++, getchar()) for(int j=0; j\u0026lt;n; j++) if(getchar() == \u0026#39;1\u0026#39;) a[i].set(j); long long ans = 0LL; for(int i=0; i+1\u0026lt;n; i++) for(int j=i+1; j\u0026lt;n; j++) if(a[i][j]) ans += (a[i] \u0026amp; a[j]).count(); printf(\u0026#34;%lld\\n\u0026#34;, ans / 3LL); return 0; } ","date":"2022-07-04T22:15:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc258/","title":"AtCoder Beginner Contest 258 A~Ex Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Last Two Digits\rProblem Statement\rGiven a positive integer $N$, output its last two digits.\n$100\\le N\\le 999$\nInput Format\r$N$\nOutput Format\rPrint the last two digits of $N$. Note that the output may have leading 0s.\nSample\r$N$ Output $254$ 54 $101$ 01 Analysis\rSince $N$ is guaranteed to be a three-digit number, we can directly treat the input as a string and output its last two characters.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { getchar(); putchar(getchar()); putchar(getchar()); return 0; } B - Practical Computing\rProblem Statement\rOutput $N$ integer sequences $A_0,\\dots,A_{N-1}$ defined as:\nLength of $A_i$ is $i+1$. The $(j+1)$-th element of $A_i$, denoted $a_{i,j}$ ($0\\le j\\le i \u003c N$), is: $1$ if $j=0$ or $j=i$; $a_{i-1,j-1}+a_{i-1,j}$ otherwise. $1\\le N\\le 30$\nInput Format\r$N$\nOutput Format\rPrint $N$ lines. The $i$-th line contains $i$ numbers from $A_{i-1}$, separated by spaces.\nSample\rSample Input 1\r1 3 Sample Output 1\r1 2 3 1 1 1 1 2 1 Sample Input 2\r1 10 Sample Output 2\r1 2 3 4 5 6 7 8 9 10 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 Analysis\rThe problem essentially describes the Yang Hui Triangle (Pascal\u0026rsquo;s Triangle). We can compute the elements sequentially as per the rules. Time complexity $\\mathcal O(n^2)$, space complexity $\\mathcal O(n)$ or $\\mathcal O(n^2)$. See Code 1 and 2.\nAlternatively, since $a_{i,j} = \\binom{i}{j}$, we can compute it with $\\mathcal O(1)$ space (code to be added).\nCode\rCode 1 (Standard approach without optimization, cin/cout, $7\\text{ms}~3604\\text{KB}$)\nTime: $\\mathcal O(n^2)$\nSpace: $\\mathcal O(n^2)$\nDifficulty: Low 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; int arr[35][35]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { arr[i][0] = 1; arr[i][i] = 1; } for (int i = 2; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt; i; j++) { arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j]; } } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt;= i; j++) { cout \u0026lt;\u0026lt; arr[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } return 0; } Code 2 (Standard approach + rolling array, scanf/printf, $6\\text{ms}~1656\\text{KB}$)\nTime: $\\mathcal O(n^2)$\nSpace: $\\mathcal O(n)$\nDifficulty: Medium-Low 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;cstdio\u0026gt; using namespace std; int a[35]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); a[0] = 1, puts(\u0026#34;1\u0026#34;); for(int i=1; i\u0026lt;n; i++) { putchar(\u0026#39;1\u0026#39;); for(int j=i-1; j\u0026gt;0; j--) a[j] += a[j - 1]; for(int j=1; j\u0026lt;i; j++) printf(\u0026#34; %d\u0026#34;, a[j]); a[i] = 1, puts(\u0026#34; 1\u0026#34;); } return 0; } C - K Swap\rProblem Statement\rGiven a sequence $A=(a_1,a_2,\\dots,a_N)$ of length $N$ and an integer $K$, you can perform the following operation any number of times:\nChoose an integer $1\\le i\\le N-K$, swap $a_i$ and $a_{i+K}$. Determine if $A$ can be sorted in non-decreasing order through these operations.\n$2\\le N\\le 2\\times 10^5$\n$1\\le K\\le N-1$\n$1\\le a_i\\le 10^9$\nInput Format\r$N~K$\n$a_1~\\dots~a_N$\nOutput Format\rPrint Yes if possible, otherwise No.\nSample\rSample Input 1\r1 2 5 2 3 4 1 3 4 Sample Output 1\r1 Yes Explanation: After two swaps, $A$ becomes sorted.\nSample Input 2\r1 2 5 3 3 4 1 3 4 Sample Output 2\r1 No Sample Input 3\r1 2 7 5 1 2 3 4 5 5 10 Sample Output 3\r1 Yes Analysis\rElements at positions $i, i+K, i+2K, \\dots$ (for $0 \\le i \u003c K$) can be freely rearranged. For each such group, sort them and check if the entire array becomes sorted.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 200005 using namespace std; int a[maxn], b[maxn]; int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d\u0026#34;, a + i); b[i] = a[i]; } sort(b, b + n); for(int i=0; i\u0026lt;k; i++) { multiset\u0026lt;int\u0026gt; s1, s2; for(int j=i; j\u0026lt;n; j+=k) { s1.insert(a[j]); s2.insert(b[j]); } if(s1 != s2) { puts(\u0026#34;No\u0026#34;); return 0; } } puts(\u0026#34;Yes\u0026#34;); return 0; } Note: Python\u0026rsquo;s array slicing makes this problem concise. Example Python code:\n1 2 3 4 5 n, k = map(int, input().split()) a = list(map(int, input().split())) for i in range(k): a[i::k] = sorted(a[i::k]) print(\u0026#39;Yes\u0026#39; if a == sorted(a) else \u0026#39;No\u0026#39;) D - Together Square\rProblem Statement\rGiven $N$, count the number of positive integer pairs $(i,j)$ satisfying:\n$1\\le i,j\\le N$ $i\\times j$ is a perfect square. $1\\le N\\le 2\\times 10^5$\nInput Format\r$N$\nOutput Format\rPrint the answer.\nSample\r$N$ Output $4$ $6$ $254$ $896$ Analysis\rFor $i \\times j$ to be a square, the product\u0026rsquo;s prime factors must have even exponents. Enumerate coprime pairs $(x,y)$ where $x,y \\le \\sqrt{N}$, and count valid $(i,j)$ pairs derived from them. Time complexity $\\mathcal O(N \\log \\sqrt N)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;cstdio\u0026gt; using namespace std; inline int gcd(int a, int b) { while(b ^= a ^= b ^= a %= b); return a; } int main() { int n = 0; char c; while((c = getchar()) != \u0026#39;\\n\u0026#39;) n = (n \u0026lt;\u0026lt; 3) + (n \u0026lt;\u0026lt; 1) + (c ^ 48); int t = __builtin_sqrt(n); long long ans = 0LL, x; for(int i=1; i\u0026lt;=t; i++) for(int j=i; j\u0026lt;=t; j++) if(gcd(i, j) == 1) { ans += (x = n / (i \u0026gt; j? i * i: j * j)); if(i != j) ans += x; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } E - Small d and k\rProblem Statement\rGiven an undirected graph with $N$ vertices and $M$ edges, where each vertex has degree ‚â§3. Answer $Q$ queries:\nFind the sum of indices of vertices within distance $k_i$ from $x_i$. $1\\le N,Q\\le 1.5\\times 10^5$\n$0\\le M\\le \\min\\{\\frac{N(N-1)}2,\\frac32N\\}$\n$0\\le k_i\\le 3$\nInput Format\r$N~M$\n$a_1~b_1$\n$\\vdots$\n$a_M~b_M$\n$Q$\n$x_1~k_1$\n$\\vdots$\n$x_Q~k_Q$\nOutput Format\rPrint $Q$ lines with answers.\nSample\rSample Input\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 6 5 2 3 3 4 3 5 5 6 2 6 7 1 1 2 2 2 0 2 3 4 1 6 0 4 3 Sample Output\r1 2 3 4 5 6 7 1 20 2 20 7 6 20 Analysis\rLeverage the constraints:\nMaximum reachable nodes per query: 3‚Å¥ = 81 (practical limit ‚âà28) Use BFS up to depth 3 for each query. Reset visited markers efficiently. Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define maxn 150005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; int dis[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); G[a].push_back(b); G[b].push_back(a); } int Q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;Q); for(int i=1; i\u0026lt;=n; i++) dis[i] = -1; while(Q--) { int x, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;k); vector\u0026lt;int\u0026gt; ans; queue\u0026lt;int\u0026gt; q; q.push(x); dis[x] = 0; while(!q.empty()) { int v = q.front(); q.pop(); int d = dis[v]; if(d \u0026lt;= k) ans.push_back(v); if(++d \u0026gt; k) continue; for(int u: G[v]) if(dis[u] == -1) { dis[u] = d; q.push(u); } } int res = 0; for(int v: ans) res += v, dis[v] = -1; printf(\u0026#34;%d\\n\u0026#34;, res); } return 0; } ","date":"2022-06-04T22:41:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc254/","title":"AtCoder Beginner Contest 254 A~E Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Median?\rProblem Statement\rGiven three positive integers $a$, $b$, and $c$, determine whether $b$ is the median of the three numbers (i.e., the second value when sorted in non-decreasing order, not the average).\nConstraints:\n$1 \\le a, b, c \\le 100$\nInput Format\r$a~b~c$\nOutput Format\rPrint Yes if $b$ is the median; otherwise, print No.\nSample Cases\r$a$ $b$ $c$ Output 5 3 2 Yes 2 5 3 No 100 100 100 No Analysis\rSince this is an A-level problem, the solution is straightforward. I misread it as the average during the contest and got WA.. (The description should be clear enough.)\nWe can directly sort the three numbers or check if either $a \\le b \\le c$ or $c \\le b \\le a$ holds.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); puts((a \u0026lt;= b \u0026amp;\u0026amp; b \u0026lt;= c) || (c \u0026lt;= b \u0026amp;\u0026amp; b \u0026lt;= a)? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Distance Between Tokens\rProblem Statement\rOn an $H \\times W$ grid, exactly two cells contain tokens, and the rest are empty. Starting from either token, find the minimum number of moves required to reach the other token by moving up, down, left, or right.\nInput Format\rThe first line contains $H$ and $W$ separated by a space. The next $H$ lines each contain a string of length $W, where -denotes an empty cell ando` denotes a token.\nOutput Format\rPrint the minimum number of moves required.\nSample Cases\rSample Input 1\r1 2 3 2 3 --o o-- Sample Output 1\r1 3 Sample Input 2\r1 2 3 4 5 6 5 4 -o-- ---- ---- ---- -o-- Sample Output 2\r1 4 Analysis\rNo BFS is needed. Since there are no obstacles, directly compute the Manhattan distance between the two tokens: $|x_1 - x_2| + |y_1 - y_2|$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { int h = 0, w = 0, x1 = -1, y1 = -1, x2 = -1, y2 = -1; char c; while((c = getchar()) != \u0026#39; \u0026#39;) h = (h \u0026lt;\u0026lt; 3) + (h \u0026lt;\u0026lt; 1) + (c ^ 48); while((c = getchar()) != \u0026#39;\\n\u0026#39;) w = (w \u0026lt;\u0026lt; 3) + (w \u0026lt;\u0026lt; 1) + (c ^ 48); for(; h--; getchar()) for(int i=w; i--; ) if(getchar() == \u0026#39;o\u0026#39;) if(x1 == -1) x1 = h, y1 = i; else { x2 = h, y2 = i; break; } printf(\u0026#34;%d\\n\u0026#34;, x1 - x2 + (y1 \u0026gt; y2? y1 - y2: y2 - y1)); return 0; } C - Max - Min Query\rProblem Statement\rGiven an initially empty sequence $S$, process $Q$ operations:\n1 x: Append $x$ to $S$. 2 x c: Remove $\\min(c, \\text{count of } x)$ occurrences of $x$ from $S$. 3: Print the difference between the maximum and minimum values in $S`. Constraints:\n$1 \\le Q \\le 2 \\times 10^5$\n$0 \\le x \\le 10^9$\n$1 \\le c \\le Q$\nInput Format\r$Q$\n$\\text{query}_1$\n$\\text{query}_2$\n$\\vdots$\n$\\text{query}_Q$\nOutput Format\rFor each 3 operation, print the difference.\nAnalysis\rA classic STL exercise.\nUse a multiset or map (C++ specific). Here\u0026rsquo;s a map approach:\nmp[x] returns the count of $x$ (auto-initialized to 0). mp.begin()-\u0026gt;first gives the minimum element. mp.rbegin()-\u0026gt;first gives the maximum element. mp.erase(x) removes all occurrences of $x$. Each query can be handled efficiently with these operations.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; int main() { int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); map\u0026lt;int, int\u0026gt; cnt; while(q--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if(op == 3) printf(\u0026#34;%d\\n\u0026#34;, cnt.rbegin()-\u0026gt;first - cnt.begin()-\u0026gt;first); else if(op == 1) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); cnt[x] ++; } else if(op == 2) { int x, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;m); if(cnt[x] \u0026gt; m) cnt[x] -= m; else cnt.erase(x); } } return 0; } D - FizzBuzz Sum Hard\rProblem Statement\rCompute the sum of integers from $1$ to $N$ that are not multiples of $A$ or $B$.\nConstraints:\n$1 \\le N, A, B \\le 10^9$\nInput Format\r$N~A~B$\nOutput Format\rPrint the answer.\nAnalysis\rBy inclusion-exclusion principle, the sum of multiples of $A$ or $B$ is:\n$\\text{sum}(A) + \\text{sum}(B) - \\text{sum}(\\text{lcm}(A,B))$.\nDefine:\n$f(n) = 1 + 2 + \\dots + n = \\frac{n(n+1)}{2}$ $\\text{sum}(x) = x \\cdot f(\\lfloor N/x \\rfloor)$ (sum of multiples of $x$ up to $N$) The final answer is:\n$f(N) - \\text{sum}(A) - \\text{sum}(B) + \\text{sum}(\\text{lcm}(A,B))$\nTime complexity is dominated by computing $\\text{lcm}(A,B)$ using GCD.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; using namespace std; using LL = long long; inline LL sum(const LL\u0026amp; x, const LL\u0026amp; n) { LL cnt = n / x; return x * cnt * (cnt + 1LL) \u0026gt;\u0026gt; 1LL; } int main() { int n, a, b; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;a, \u0026amp;b); LL x = b, y = a; while(b ^= a ^= b ^= a %= b); LL t = x / a * y; // t = lcm(a, b) printf(\u0026#34;%lld\\n\u0026#34;, sum(1, n) - sum(x, n) - sum(y, n) + sum(t, n)); return 0; } E - Distance Sequence\rProblem Statement\rCount the number of sequences $A = (A_1, \\dots, A_N)$ modulo $998244353$ that satisfy:\n$1 \\le A_i \\le M$ for all $i$ $|A_i - A_{i+1}| \\ge K$ for all $1 \\le i \u003c N$ Constraints:\n$2 \\le N \\le 1000$\n$1 \\le M \\le 5000$\n$0 \\le K \u003c M$\nInput Format\r$N~M~K$\nOutput Format\rPrint the count modulo $998244353$.\nAnalysis\rDynamic Programming (DP) approach:\nDefine $\\text{dp}(i, j)$ as the number of valid sequences ending with $j$ at position $i$. Transition: $\\text{dp}(i, j) = \\sum \\text{dp}(i-1, p)$ where $|j - p| \\ge K$. Optimize using prefix/suffix sums to reduce time complexity from $\\mathcal{O}(NM^2)$ to $\\mathcal{O}(NM)$. Special case $K=0$ has answer $M^N \\bmod 998244353$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;cstdio\u0026gt; #define maxn 1002 #define maxm 5005 #define MOD 998244353 using namespace std; using LL = long long; int qpow(LL a, LL b) { LL ans = 1LL; while(b \u0026gt; 0) { if(b \u0026amp; 1LL) ans = ans * a % MOD; a = a * a % MOD, b \u0026gt;\u0026gt;= 1LL; } return ans; } inline void mod(int\u0026amp; x) { if(x \u0026gt;= MOD) x -= MOD; } int dp[2][maxm]; int main() { int n, m, k; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); if(k == 0) { printf(\u0026#34;%d\\n\u0026#34;, qpow(m, n)); return 0; } for(int i=1; i\u0026lt;=m; i++) dp[0][i] = 1; for(int i=1; i\u0026lt;n; i++) { int c = i \u0026amp; 1, p = c ^ 1, s = 0; for(int j=k+1; j\u0026lt;=m; j++) mod(s += dp[p][j]); for(int j=1; j\u0026lt;=m; j++) { if(j \u0026gt; k) mod(s += dp[p][j - k]); mod(dp[c][j] = s); if(j + k \u0026lt;= m) { mod(s -= dp[p][j + k]); if(s \u0026lt; 0) s += MOD; } } } int ans = 0, t = n \u0026amp; 1 ^ 1; for(int i=1; i\u0026lt;=m; i++) mod(ans += dp[t][i]); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","date":"2022-05-29T16:07:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc253/","title":"AtCoder Beginner Contest 253 A~E Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Foreword\nThis is my first time writing solutions for 7 problems (A~G) in an ABC contest. If there are any shortcomings or areas needing improvement, please feel free to provide feedback. Your support is greatly appreciated! A - ASCII code\rProblem Statement\rGiven a positive integer $N$, output the character whose ASCII code is $N$.\n$97\\le N\\le 122$\nInput Format\r$N$\nOutput Format\rPrint the character corresponding to ASCII code $N$.\nAnalysis\rNote a corresponds to 97, b to 98, \u0026hellip;, z to 122. Beginner conversion examples:\nC 1 2 int n = 97; putchar(n); /* Output: a */ putchar automatically converts to character. printf(\u0026quot;%c\u0026quot;, n) works similarly. C++ 1 2 int n = 97; cout \u0026lt;\u0026lt; char(n) \u0026lt;\u0026lt; endl; // Output: a Direct cout \u0026lt;\u0026lt; n outputs 97, requires char conversion. Python 1 2 n = 97 print(chr(n)) # Output: a Requires chr conversion. Java 1 2 3 int n = 97; char c = (char) n; System.out.print(c); Casting required. JavaScript 1 2 3 var n = 97; var c = String.fromCharCode(n); console.log(c); // Output: a Uses String.fromCharCode. Need more examples?\nCode\rStraightforward Python (AC in 25s):\n1 print(chr(int(input()))) B - Takahashi\u0026rsquo;s Failure\rProblem Statement\rTakahashi\u0026rsquo;s house has $N$ foods. The $i$-th food has deliciousness $A_i$.\nHe dislikes $K$ foods: $B_1,B_2,\\dots,B_K$.\nTakahashi will randomly select a food with maximum deliciousness and eat it.\nIs it possible for him to eat a disliked food?\n$1\\le K\\le N\\le 100$\n$1\\le A_i\\le 100$\n$1\\le B_i\\le N$\nInput Format\r$N~K$\n$A_1~\\dots~A_N$\n$B_1~\\dots~B_K$\nOutput Format\rPrint Yes if possible, No otherwise.\nAnalysis\rCheck if any disliked food has maximum deliciousness. See code.\nCode\rNote convert to 0-indexed for $B_i$:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;cstdio\u0026gt; using namespace std; int a[105]; int main() { int n, k, mx = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d\u0026#34;, a + i); if(a[i] \u0026gt; mx) mx = a[i]; } while(k--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if(a[--n] == mx) { puts(\u0026#34;Yes\u0026#34;); return 0; } } puts(\u0026#34;No\u0026#34;); return 0; } C - Slot Strategy\rProblem Statement\rRefer to AtCoder.\n$2\\le N\\le 100$\nInput Format\r$N$\n$S_1$\n$\\vdots$\n$S_N$\nOutput Format\rPrint the answer.\nAnalysis\rLet $\\text{cnt}[i][j]$ be the count of $S_k[j] = i$. Compute cost for each target digit. See code.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;cstdio\u0026gt; using namespace std; int cnt[10][10]; // cnt[i][j] = number of (s[j]=i) int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { char s[15]; scanf(\u0026#34;%s\u0026#34;, s); for(int j=0; j\u0026lt;10; j++) cnt[s[j] ^ 48][j] ++; } int ans = 1000; for(int i=0; i\u0026lt;10; i++) { int cur = 0; for(int j=0; j\u0026lt;10; j++) { int c = j + (cnt[i][j] - 1) * 10; if(c \u0026gt; cur) cur = c; } if(cur \u0026lt; ans) ans = cur; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Distinct Trio\rProblem Statement\rGiven integer sequence $A=(A_1,\\dots,A_N)$, count triples $(i,j,k)$ where:\n$1\\le i \u003c j \u003c k\\le N$ $A_i \\ne A_j \\ne A_k$ $3\\le N\\le 2\\times 10^5$\n$1\\le A_i\\le 2\\times 10^5$\nInput Format\r$N$\n$A_1~\\dots~A_N$\nOutput Format\rPrint the count.\nAnalysis\rApproach:\nTotal triples $C_n^3$ minus invalid ones. For each $x$ in $A$: Subtract $C_{\\text{cnt}_x}^2 \\times (N-\\text{cnt}_x)$ for pairs (x,x,y) Subtract $C_{\\text{cnt}_x}^3$ for triples (x,x,x) Time: $O(N + \\max A)$\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; using LL = long long; int cnt[maxn]; inline LL C2(int n) { return n * (n - 1LL) \u0026gt;\u0026gt; 1LL; } inline LL C3(int n) { return C2(n) * (n - 2LL) / 3LL; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); cnt[a] ++; } LL ans = C3(n); for(int i=1; i\u0026lt;maxn; i++) if(cnt[i] \u0026gt; 1) { ans -= C2(cnt[i]) * (n - cnt[i]); if(cnt[i] \u0026gt; 2) ans -= C3(cnt[i]); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } E - Road Reduction\rProblem Statement\rGiven undirected graph with $N$ nodes and $M$ edges. Find a spanning tree minimizing the sum of distances from node 1 to all others.\n$2\\le N\\le 2\\times 10^5$\n$N-1\\le M\\le 2\\times 10^5$\n$1\\le C_i\\le 10^9$\nInput Format\r$N~M$\n$A_1~B_1~C_1$\n$\\vdots$\n$A_M~B_M~C_M$\nOutput Format\rPrint indices of $N-1$ edges in the tree.\nAnalysis\rOptimal tree preserves shortest paths from node 1. Use Dijkstra\u0026rsquo;s algorithm and track edges.\nCode\rPriority queue (182ms): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define maxn 200005 #define INF 9223372036854775807LL using namespace std; using LL = long long; using pli = pair\u0026lt;LL, int\u0026gt;; struct Edge { int v, id; LL d; inline Edge(int u, int l, int i): v(u), d(l), id(i) {} }; vector\u0026lt;Edge\u0026gt; G[maxn]; LL dis[maxn]; int ans[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=1; i\u0026lt;=m; i++) { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); G[--a].emplace_back(--b, c, i); G[b].emplace_back(a, c, i); } priority_queue\u0026lt;pli, vector\u0026lt;pli\u0026gt;, greater\u0026lt;pli\u0026gt;\u0026gt; q; for(int i=1; i\u0026lt;n; i++) dis[i] = INF; q.emplace(0LL, 0); while(!q.empty()) { auto [d, v] = q.top(); q.pop(); if(dis[v] == d) for(const Edge\u0026amp; e: G[v]) { LL nd = d + e.d; if(nd \u0026lt; dis[e.v]) q.emplace(dis[e.v] = nd, e.v), ans[e.v] = e.id; } } for(int i=1; i\u0026lt;n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); return 0; } Set (202ms): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 200005 #define INF 9223372036854775807LL using namespace std; using LL = long long; using pli = pair\u0026lt;LL, int\u0026gt;; struct Edge { int v, id; LL d; inline Edge(int u, int l, int i): v(u), d(l), id(i) {} }; vector\u0026lt;Edge\u0026gt; G[maxn]; LL dis[maxn]; int ans[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=1; i\u0026lt;=m; i++) { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); G[--a].emplace_back(--b, c, i); G[b].emplace_back(a, c, i); } set\u0026lt;pli\u0026gt; s; // \u0026lt;distance, vertex\u0026gt; for(int i=1; i\u0026lt;n; i++) dis[i] = INF; s.emplace(0LL, 0); while(!s.empty()) { auto [d, v] = *s.begin(); s.erase(s.begin()); for(const Edge\u0026amp; e: G[v]) { LL nd = d + e.d; if(nd \u0026lt; dis[e.v]) { if(dis[e.v] \u0026lt; INF) s.erase(pli(dis[e.v], e.v)); s.emplace(dis[e.v] = nd, e.v); ans[e.v] = e.id; } } } for(int i=1; i\u0026lt;n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); return 0; } F - Bread\rProblem Statement\rGiven initial loaf of length $L$, split into parts including all elements of array $A$. Each split of $k$ costs $k$. Find minimum total cost.\n$2\\le N\\le 2\\times 10^5$\n$1\\le A_i\\le 10^9$\n$A_1+\\dots+A_N\\le L\\le 10^{15}$\nInput Format\r$N~L$\n$A_1~\\dots~A_N$\nOutput Format\rPrint the minimal cost.\nAnalysis\rMerge all elements (plus remaining $L-\\sum A$ if needed) using a min-heap. Always merge smallest two elements.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; using LL = long long; int main() { int n; LL l; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;l); priority_queue\u0026lt;LL, vector\u0026lt;LL\u0026gt;, greater\u0026lt;LL\u0026gt;\u0026gt; q; for(int i=0; i\u0026lt;n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); q.push(x); l -= x; } if(l \u0026gt; 0) q.push(l); LL ans = 0LL; while(q.size() \u0026gt; 1) { LL x = q.top(); q.pop(); x += q.top(); q.pop(); ans += x; q.push(x); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } G - Pre-Order\rProblem Statement\rCount valid rooted trees with given pre-order traversal $P_1,\\dots,P_N$, where children are visited in ascending order. Modulo 998244353.\n$2\\le N\\le 500$\n$P_1=1$\n$P$ is permutation.\nInput Format\r$N$\n$P_1~\\dots~P_N$\nOutput Format\rPrint the count modulo 998244353.\nAnalysis\rLet $dp(l,r)$ be the count for subarray $A_l,\\dots,A_{r-1}$. Transition:\n$dp(l,r) = dp(l+1,r) + \\sum_{k} dp(l+1,k) \\times dp(k,r)$ if $A_l \u003c A_k$ Code\rVersion 1 (59ms): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; #define MOD 998244353 #define maxn 505 using namespace std; using LL = long long; int p[maxn], dp[maxn][maxn]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, p + i); for(int l=n; l\u0026gt;0; l--) { dp[l][l] = 1; for(int r=l+1; r\u0026lt;=n; r++) { dp[l][r] = dp[l + 1][r]; for(int k=l+1; k\u0026lt;r; k++) if(p[l] \u0026lt; p[k] \u0026amp;\u0026amp; (dp[l][r] += LL(dp[l + 1][k]) * dp[k][r] % MOD) \u0026gt;= MOD) dp[l][r] -= MOD; } } printf(\u0026#34;%d\\n\u0026#34;, dp[1][n]); return 0; } Version 2 (66ms): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; #define MOD 998244353 #define maxn 505 using namespace std; using LL = long long; int p[maxn], dp[maxn][maxn]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, p + i); for(int i=1; i\u0026lt;=n; i++) dp[i][i] = 1; for(int d=1; d\u0026lt;=n; d++) for(int l=1, r=d+1; r\u0026lt;=n; l++, r++) { dp[l][r] = dp[l + 1][r]; for(int k=l+1; k\u0026lt;r; k++) if(p[l] \u0026lt; p[k] \u0026amp;\u0026amp; (dp[l][r] += LL(dp[l + 1][k]) * dp[k][r] % MOD) \u0026gt;= MOD) dp[l][r] -= MOD; } printf(\u0026#34;%d\\n\u0026#34;, dp[1][n]); return 0; } ","date":"2022-05-22T11:31:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc252/","title":"AtCoder Beginner Contest 252 A~G Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed C - Adjacent Swaps\rProblem Statement\r$N$ balls are arranged in a row from left to right. Initially, the $i$-th ball from the left has the number $i$ written on it.\nPerform $Q$ operations, where the $i$-th operation is as follows:\nLet $j$ be the position of the ball with number $x_i$ written on it among the $N$ balls. If $j=N$, swap it with the $(j-1)$-th ball; otherwise, swap it with the $(j+1)$-th ball. Output the numbers written on the balls after all operations. See the output format for details.\n$2\\le N\\le 2\\times 10^5$\n$1\\le Q\\le 2\\times 10^5$\n$1\\le x_i\\le N$\nInput Format\r$N~Q$\n$x_1$\n$\\vdots$\n$x_Q$\nOutput Format\rLet $a_i$ be the number written on the $i$-th ball from the left after all operations. Output in the following format:\n$a_1~a_2~\\dots~a_n$\nThat is, output $a_1,\\dots,a_n$ in order on a single line, separated by spaces.\nSample\rRefer to AtCoder for samples.\nAnalysis\rGiven the constraints, only algorithms with time complexity $\\mathcal O(N+Q\\log n)$ or better are acceptable.\nBrute-force simulation (searching for positions in $\\mathcal O(NQ)$) is infeasible.\nAn efficient approach is to maintain index arrays $p$, where $p_x=i$ when $a_i=x$.\nThis allows finding the position of $x_i$ in $\\mathcal O(1)$ per operation.\nWhen swapping, update both $a$ and $p$. Total time complexity is $\\mathcal O(N+Q)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; inline void swap(int\u0026amp; x, int\u0026amp; y) { x ^= y ^= x ^= y; } int pos[maxn], ans[maxn]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=1; i\u0026lt;=n; i++) ans[i] = pos[i] = i; while(q--) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); int p1 = pos[x]; int p2 = p1 == n? p1 - 1: p1 + 1; swap(pos[x], pos[ans[p2]]); swap(ans[p1], ans[p2]); } for(int i=1; i\u0026lt;=n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); return 0; } D - 250-like Number\rProblem Statement\rA positive integer $k$ is called \u0026ldquo;250-like\u0026rdquo; if:\n$k=p\\times q^3$ where $p$ and $q$ are primes with $p \u003c q$. Count the number of 250-like numbers $k$ that do not exceed $N$.\n$1\\le N\\le 10^{18}$\nInput Format\r$N$\nOutput Format\rOutput the answer as an integer.\nSample\r$N$ Output $250$ $2$ $1$ $0$ $123456789012345$ $226863$ Analysis\rGiven the large $N$, we note that $q$ is bounded by $\\sqrt[3]{N/2}\\approx794000$.\nSieve primes up to this bound. For each prime $p$, compute the maximum $q$ such that $p\\times q^3\\le N$, then add the count of primes in $(p, q]$. Terminate when $p\\ge q$.\nUse binary search or a two-pointer technique. Total time complexity is approximately $\\mathcal O(n^{\\frac{7}{22}})$.\nCode\rThis implementation uses a two-pointer approach.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; #define maxp 794000 using namespace std; using LL = long long; bool bad[maxp]; vector\u0026lt;int\u0026gt; primes; inline LL pow3(LL x) { return x * x * x; } int main() { bad[0] = bad[1] = true; for(int i=2; i\u0026lt;maxp; i++) if(!bad[i]) { primes.push_back(i); for(int j=i\u0026lt;\u0026lt;1; j\u0026lt;maxp; j+=i) bad[j] = true; } LL n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); LL ans = 0LL; for(int i=0, j=primes.size()-1; i\u0026lt;j; i++) { while(j \u0026gt;= 0 \u0026amp;\u0026amp; primes[i] * pow3(primes[j]) \u0026gt; n) j --; if(i \u0026gt;= j) break; ans += j - i; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } E - Prefix Equality\rProblem Statement\rGiven two length-$N$ sequences $A=(A_1,\\dots,A_N)$ and $B=(B_1,\\dots,B_N)$.\nFor $1\\le i\\le Q$, answer queries of the form:\nDetermine if the sets $\\{A_1,\\dots,A_{x_i}\\}$ and $\\{B_1,\\dots,B_{y_i}\\}$ are equal. A set is formed by deduplicating and sorting the sequence. For example, $(9,3,5,3,4)$ corresponds to $\\{3,4,5,9\\}$.\n$1\\le N,Q\\le 2\\times 10^5$\n$1\\le A_i\\le B_i\\le 10^9$\nInput Format\r$N$\n$A_1~\\dots~A_N$\n$B_1~\\dots~B_N$\n$Q$\n$x_1~y_1$\n$\\vdots$\n$x_Q~y_Q$\nSample\rSample Input\r1 2 3 4 5 6 7 8 9 10 11 5 1 2 3 4 5 1 2 2 4 3 7 1 1 2 2 2 3 3 3 4 4 4 5 5 5 Sample Output\r1 2 3 4 5 6 7 Yes Yes Yes No No Yes No Analysis\rWe use a hashing approach to solve this efficiently.\n$$\rP_A(i) = \\text{hash of } \\{A_1,\\dots,A_i\\} \\\\\rP_B(i) = \\text{hash of } \\{B_1,\\dots,B_i\\}\r$$\nA query $(x,y)$ is answered by checking $P_A(x) == P_B(y)$.\nTo mitigate hash collisions, use a robust hash function like $H(x)=x(x+93)(x+117) \\bmod (2^{32}-1)$. Time complexity is $\\mathcal O(N+Q)$ with unordered sets.\nCode\rThis code uses natural overflow for modular arithmetic.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;unordered_set\u0026gt; #define maxn 200005 using namespace std; inline int read() { char c; while((c = getchar()) \u0026lt; \u0026#39;0\u0026#39; || c \u0026gt; \u0026#39;9\u0026#39;); int res = c ^ 48; while((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) res = (res \u0026lt;\u0026lt; 3) + (res \u0026lt;\u0026lt; 1) + (c ^ 48); return res; } unsigned suma[maxn], sumb[maxn]; inline void hread(unsigned* psum, int n) { unordered_set\u0026lt;int\u0026gt; s; for(int i=1, x; i\u0026lt;=n; i++) { psum[i] = psum[i - 1]; if(s.insert(x = read()).second) psum[i] += x * unsigned(x + 93) * unsigned(x + 117); } } int main() { int n = read(); hread(suma, n); hread(sumb, n); for(int q=read(); q--;) puts(suma[read()] == sumb[read()]? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } ","date":"2022-05-11T07:45:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc250/","title":"AtCoder Beginner Contest 250 C~E Solution"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed C - Dice Sum\rProblem Statement\rHow many integer sequences $A=(A_1,\\dots,A_N)$ satisfy the following conditions:\n$1\\le A_i\\le M$ $\\sum\\limits_{i=1}^NA_i\\le K$ Output the answer modulo $998244353$.\n$1\\le N,M\\le 50$\n$N\\le K\\le NM$\nInput Format\r$N~M~K$\nOutput Format\rPrint the answer modulo $998244353$.\nAnalysis\rDamn, another DP problem for C\nWe use dynamic programming. Let $\\text{dp}(i,j)$ denote the number of valid sequences for the first $i$ elements with sum $j$ ($1\\le A_x\\le M$). The pseudocode is as follows:\n1 2 3 4 5 6 dp[0][0] = 1 for i = 0 to N-1 // consider each position one by one for j = 0 to K-1 // consider all possible sums (up to K-1) for k = 1 to M // each choice from 1-M if j + k \u0026lt;= K: // constraint dp[i + 1][j + k] += dp[i][j] // update dp[i+1] Time complexity is $\\mathcal O(NMK)$, which is acceptable.\nActually, prefix sum optimization can be applied.\nWe observe that $\\mathrm{dp}(i,j)=\\displaystyle\\sum_{k=L}^R\\text{dp}(i-1,k)$,\nwhere $L\\le R$. The exact values of $L$ and $R$ are left for derivation.\nWe can precompute the prefix sum $\\mathrm{pre}$ of $\\mathrm{dp}[i-1]$:\n$\\mathrm{pre}_j=\\displaystyle\\sum_{k=1}^j\\mathrm{dp}(i-1,k)$ Then $\\mathrm{dp}(i,j)=\\mathrm{pre}_R-\\mathrm{pre}_{L-1}$.\nThis reduces the time complexity to $\\mathcal O(NK)$.\nReaders are strongly encouraged to derive and implement this optimization. Prefix-sum optimized DP is common in problems like E and F.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; #define MOD 998244353 #define maxn 200005 using namespace std; inline void mod(int\u0026amp; x) { if(x \u0026gt;= MOD) x -= MOD; } int dp[2][maxn]; int main() { int n, m, k; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); dp[0][0] = 1; for(int i=0; i\u0026lt;n; i++) { int c = i \u0026amp; 1, p = c ^ 1; for(int j=0; j\u0026lt;=k; j++) dp[p][j] = 0; for(int j=0; j\u0026lt;k; j++) for(int d=1; d\u0026lt;=m \u0026amp;\u0026amp; d\u0026lt;=k-j; d++) mod(dp[p][j + d] += dp[c][j]); } int ans = 0; for(int i=1; i\u0026lt;=k; i++) mod(ans += dp[n \u0026amp; 1][i]); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Range Count Query\rProblem Statement\rGiven an integer sequence $A=(A_1,\\dots,A_N)$.\nProcess $Q$ queries. Each query is formatted as:\nGiven integers $L,R,X$, count the occurrences of $X$ in $A_L,\\dots,A_R$. $1\\le A_i,X\\le N\\le 2\\times10^5$\n$1\\le L\\le R\\le N$\nInput Format\r$N$\n$A_1~\\dots~A_N$\n$Q$\n$L_1~R_1~X_1$\n$\\vdots$\n$L_Q~R_Q~X_Q$\nOutput Format\rPrint $Q$ lines, each containing the answer to a query.\nAnalysis\rThe problem reduces to: For each $X$, count how many of its positions lie within $[L,R]$.\nThus, we preprocess the positions where each number appears using a vector, then answer queries via binary search.\nCode\rNote the binary search boundaries.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 200005 using namespace std; vector\u0026lt;int\u0026gt; pos[maxn]; int main() { int n, q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); pos[a].push_back(i); } scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while(q--) { int l, r, x; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;x); printf(\u0026#34;%d\\n\u0026#34;, int( lower_bound(pos[x].begin(), pos[x].end(), r) - lower_bound(pos[x].begin(), pos[x].end(), --l) )); } return 0; } ","date":"2022-04-17T15:45:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc248/","title":"UNIQUE VISION Programming Contest 2022ÔºàAtCoder Beginner Contest 248ÔºâSolutions for Problems C~D"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Note: This article was originally published on CSDN and has ceased updates. Original text follows:\nAtCoder Solution Collection\rA curated collection of high-quality AtCoder solutions from various sources, currently covering C~F problems of ABC (AtCoder Beginner Contest). Periodically updated.\nIf you need more solutions, feel free to DM me or leave a comment!\n$\\rarr$ Solution List Portal\nUsage\rTable Lookup\nLocate the corresponding contest row Find the target problem column The cell contains the solution link Problem Number Search\nPress Ctrl+F in your browser to open the search box. Enter the problem ID, e.g., 244F Locate the solution Title Search\nPress Ctrl+F in your browser to open the search box. Enter the problem title, e.g., Shortest Good Path Locate the solution Solution Selection Criteria:\nPrioritize Chinese solutions Use official AtCoder editorials if no good Chinese solutions exist Select high-quality submission records if no solutions are available shortly after contests Problem List\rSorted by contest date ascending, starting from ABC195.\nContest C D E F ABC195 195C - Comma 195D - Shipping Center 195E - Lucky 7 Battle 195F - Coprime Present ABC196 196C - Doubled 196D - Hanjo 196E - Filters 196F - Substring 2 ABC197 197C - ORXOR 197D - Opposite 197E - Traveler 197F - Construct a Palindrome ABC198 198C - Compass Walking 198D - Send More Money 198E - Unique Color 198F - Cube ABC199 199C - IPFL 199D - RGB Coloring 2 199E - Permutation 199F - Graph Smoothing ABC200 200C - Ringo\u0026rsquo;s Favorite Numbers 2 200D - Happy Birthday! 2 200E - Patisserie ABC 2 200F - Minflip Summation ABC201 201C - Secret Number 201D - Game in Momotetsu World 201E - Xor Distances 201F - Insertion Sort ABC202 202C - Made Up 202D - aab aba baa 202E - Count Descendants 202F - Integer Convex Hull ABC203 203C - Friends and Travel costs 203D - Pond 203E - White Pawn 203F - Weed ABC204 204C - Tour 204D - Cooking 204E - Rush Hour 2 204F - Hanjo 2 ABC205 205C - POW 205D - Kth Excluded 205E - White and Black Balls 205F - Grid and Tokens ABC206 206C - Swappable 206D - KAIBUNsyo 206E - Divide Both 206F - Interval Game 2 ABC207 207C - Many Segments 207D - Congruence Points 207E - Mod i 207F - Tree Patrolling ABC208 208C - Fair Candy Distribution 208D - Shortest Path Queries 2 208E - Digit Products 208F - Cumulative Sum ABC209 209C - Not Equal 209D - Collision 209E - Shiritori 209F - Deforestation ABC210 210C - Colorful Candies 210D - National Railway 210E - Ring MST 210F - Coprime Solitaire ABC211 211C - chokudai 211D - Number of Shortest paths 211E - Red Polyomino 211F - Rectilinear Polygons ABC212 212C - Min Difference 212D - Querying Multiset 212E - Safety Journey 212F - Greedy Takahashi ABC213 213C - Reorder Cards 213D - Takahashi Tour 213E - Stronger Takahashi 213F - Common Prefixes ABC214 214C - Distribution 214D - Sum of Maximum Weights 214E - Packing Under Range Regulations 214F - Substrings ABC215 215C - One More aab aba baa 215D - Coprime 2 215E - Chain Contestant 215F - Dist Max 2 ABC216 216C - Many Balls 216D - Pair of Balls 216E - Amusement Park 216F - Max Sum Counting ABC217 217C - Inverse of Permutation 217D - Cutting Woods 217E - Sorting Queries 217F - Make Pair ABC218 218C - Shapes 218D - Rectangles 218E - Destruction 218F - Blocked Roads ABC219 219C - Neo-lexicographic Ordering 219D - Strange Lunchbox 219E - Moat 219F - Cleaning Robot ABC220 220C - Long Sequence 220D - FG operation 220E - Distance on Large Perfect Binary Tree 220F - Distance Sums 2 ABC221 221C - Select Mul 221D - Online games 221E - LEQ 221F - Diameter set ABC222 222C - Swiss-System Tournament 222D - Between Two Arrays 222E - Red and Blue Tree 222F - Expensive Expense ABC223 223C - Doukasen 223D - Restricted Permutation 223E - Placing Rectangles 223F - Parenthesis Checking ABC224 224C - Triangle? 224D - 8 Puzzle on Graph 224E - Integers on Grid 224F - Problem where +s Separate Digits ABC225 225C - Calendar Validator 225D - Play Train 225E - „Éï/7 225F - String Cards ABC226 226C - Martial artist 226D - Teleportation 226E - Just one 226F - Score of Permutations ABC227 [227C - ABC conjecture ","date":"2022-04-15T22:27:00+08:00","permalink":"https://goodcoder666.github.io/en/p/atcoder-all/","title":"AtCoder Solution Collection"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed ARC138 B - 01 Generation\rApproach\rConsider reverse thinking. We can prioritize removing trailing 0s (reverse operation of Operation B), then remove the leading 0 and flip the sequence if present (reverse operation of Operation A). Repeat these steps until the sequence becomes empty. If the process gets stuck, output No; otherwise, output Yes.\nProof of correctness:\nAssume there exists a sequence $A$ where our method outputs No but the correct answer is Yes; Then there must exist a step (possibly the first) where only reverse Operation A can be applied first instead of Operation B. Let the sequence before this step be $S$; Let $N=|S|$, then $S_1=S_N=0$; If we apply reverse Operation A first, we get $(S_2,S_3,\\dots,S_{N-1},1)$; If we apply reverse Operation B first, we get $(S_1,S_2,\\dots,S_{N-1})$; Comparing both results, performing reverse Operation B first does not block subsequent reverse Operation A, hence such sequence $S$ cannot exist; Conclusion: The approach is correct. Code\rIn implementation, no actual sequence flipping is needed. Track the flip state using a boolean flipped. The actual value at position $i$ is $A_i = A_i' \\oplus \\text{flipped}$ (where $A_i'$ is the input sequence, $\\oplus$ denotes XOR).\nUse deque or track endpoints with l and r.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; bool a[maxn]; int main() { int n = 0; char c; while((c = getchar()) != \u0026#39;\\n\u0026#39;) n = (n \u0026lt;\u0026lt; 3) + (n \u0026lt;\u0026lt; 1) + (c ^ 48); for(int i=0; i\u0026lt;n; i++, getchar()) a[i] = getchar() ^ 48; bool flipped = false; for(int l=0, r=n-1; a[l]==flipped; flipped^=1, l++) while(!a[r] ^ flipped) if(l \u0026gt; --r) return puts(\u0026#34;Yes\u0026#34;), 0; puts(\u0026#34;No\u0026#34;); return 0; } ","date":"2022-04-14T22:37:00+08:00","permalink":"https://goodcoder666.github.io/en/p/arc138_b/","title":"ARC138 B - 01 Generation Solution"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Good morning\rProblem Summary\rOn the same day, Takahashi wakes up at $A$ hours $B$ minutes, and Aoki wakes up at $C$ hours $D$ minutes 1 second. Who wakes up earlier?\n$0\\le A,C \u003c 24$\n$0\\le B,D \u003c 60$\nInput Format\r$A~B~C~D$\nOutput Format\rOutput the name of the earlier riser (Takahashi or Aoki).\nSamples\r$A$ $B$ $C$ $D$ Output $7$ $0$ $6$ $30$ Aoki $7$ $30$ $7$ $30$ Takahashi $0$ $0$ $23$ $59$ Takahashi Analysis\rThe approach is straightforward: directly check whether $(A,B)\\le(C,D)$ holds.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c, d; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); puts((a == c? b \u0026lt;= d: a \u0026lt; c)? \u0026#34;Takahashi\u0026#34;: \u0026#34;Aoki\u0026#34;); return 0; } B - Mex\rProblem Summary\rGiven an integer sequence $A=(A_1,\\dots,A_N)$, find the smallest natural number not present in $A$.\n$1\\le N\\le 2000$\n$0\\le A_i\\le 2000$\nInput Format\r$N$\n$A_1~\\dots~A_N$\nOutput Format\rOutput the smallest natural number not in $A$.\nSamples\rSamples omitted; please visit AtCoder.\nAnalysis\rSince $0\\le A_i\\le 2000$, we can use an array to track occurrences of numbers in $[0,2001]$.\nThere are multiple approaches for this problem; here we present the fastest algorithm with $\\mathcal O(N)$ time complexity.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; using namespace std; bool used[2005]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while(n--) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); used[a] = true; } int i = -1; while(used[++i]); printf(\u0026#34;%d\\n\u0026#34;, i); return 0; } C - Choose Elements\rProblem Summary\rGiven two integer sequences $A=(A_1,\\dots,A_N)$ and $B=(B_1,\\dots,B_N)$, determine if there exists a sequence $X=(X_1,\\dots,X_N)$ satisfying:\n$X_i=A_i$ or $X_i=B_i$ $|X_i-X_{i+1}|\\le K$ for all $1\\le i \u003c N$ $1\\le N\\le 2\\times 10^5$\n$1\\le K\\le 10^9$\n$1\\le A_i,B_i\\le 10^9$\nInput Format\r$N~K$\n$A_1~\\dots~A_N$\n$B_1~\\dots~B_N$\nOutput Format\rOutput Yes if such $X$ exists; otherwise, output No.\nSamples\rSamples omitted; please visit AtCoder.\nAnalysis\rThis problem can be solved using dynamic programming.\nLet $f(i)$ denote whether $X_i$ can be $A_i$, and $g(i)$ denote whether $X_i$ can be $B_i$.\nState transitions are straightforward; see code for details.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; int a[maxn], b[maxn]; bool f[maxn], g[maxn]; int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, b + i); f[0] = g[0] = true; #define set(x, y, z) x |= y - z \u0026lt;= k \u0026amp;\u0026amp; z - y \u0026lt;= k for(int i=1; i\u0026lt;n; i++) { if(f[i - 1]) set(f[i], a[i - 1], a[i]), set(g[i], a[i - 1], b[i]); if(g[i - 1]) set(f[i], b[i - 1], a[i]), set(g[i], b[i - 1], b[i]); } puts(f[n - 1] || g[n - 1]? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } Note: There\u0026rsquo;s a peculiar alternative solution that checks if at least one of the four adjacent connections exists, such as in #30453703. If anyone can prove its correctness, please comment below!\nD - Polynomial division\rProblem Summary\r$$\rA(x)=\\sum_{i=0}^N A_iX^i\\\\\rB(x)=\\sum_{i=0}^M B_iX^i\\\\\rC(x)=\\sum_{i=0}^{N+M} C_iX^i\r$$\nwhere $A$ and $C$ coefficients are known and $A(x)\\times B(x)=C(x)$, find coefficients $B_0,\\dots,B_M$.\n$1\\le N,M \u003c 100$\n$|A_i|\\le 100$\n$|C_i|\\le 10^6$\n$A_N\\ne0$, $C_{N+M}\\ne0$\nA valid $B$ is guaranteed.\nInput Format\r$N~M$\n$A_0~\\dots~A_N$\n$C_0~\\dots~C_{N+M}$\nOutput Format\rOutput $B_0,\\dots~B_M$ separated by spaces.\nSamples\rSamples omitted; please visit AtCoder.\nAnalysis\rSimulate the polynomial long division process by tracking coefficients.\nReference: Polynomial long division\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #define maxn 105 using namespace std; int a[maxn], b[maxn], c[maxn \u0026lt;\u0026lt; 1]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;=n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); for(int i=0; i\u0026lt;=n+m; i++) scanf(\u0026#34;%d\u0026#34;, c + i); for(int i=m; i\u0026gt;=0; i--) // NOTE: must process in reverse order! { b[i] = c[n + i] / a[n]; for(int j=0; j\u0026lt;=n; j++) c[i + j] -= a[j] * b[i]; } for(int i=0; i\u0026lt;=m; i++) printf(\u0026#34;%d \u0026#34;, b[i]); return 0; } E - Wrapping Chocolate\rProblem Summary\rWe have $N$ chocolates and $M$ boxes. The $i$-th chocolate has dimensions $A_i\\times B_i$, and the $j$-th box has dimensions $C_j\\times D_j$. Determine if all chocolates can be packed into boxes such that:\nEach box contains exactly one chocolate. For chocolate $i$ in box $j$, $A_i\\le C_j$ and $B_i\\le D_j$ must hold. $1\\le N\\le M\\le 2\\times10^5$\n$1\\le A_i,B_i,C_i,D_i\\le 10^9$\nInput Format\r$N~M$\n$A_1~\\dots~A_N$\n$B_1~\\dots~B_N$\n$C_1~\\dots~C_M$\n$D_1~\\dots~D_M$\nOutput Format\rOutput Yes if possible; otherwise, No.\nAnalysis\rGreedy algorithm steps:\nSort all items (chocolates and boxes) in descending order of length. When lengths are equal, boxes come first. Use a multiset to track available box heights. For each chocolate, remove the smallest box height ‚â• its height.\nTime complexity: $\\mathcal O((N+M)\\log(N+M))$ Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; struct Item { int w, h; bool type; inline bool operator \u0026lt;(const Item\u0026amp; i2) const { return w == i2.w? type \u0026gt; i2.type: w \u0026gt; i2.w; // Note: The sort must have strict ordering. Initially, writing type==1 here caused RE, see: // https://atcoder.jp/contests/abc245/submissions/30526563 } } v[400005]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); // Chocolate for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;v[i].w); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;v[i].h); // Box m += n; for(int i=n; i\u0026lt;m; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;v[i].w); for(int i=n; i\u0026lt;m; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;v[i].h); for(int i=n; i\u0026lt;m; i++) v[i].type = 1; // Algorithm sort(v, v + m); multiset\u0026lt;int\u0026gt; s; for(int i=0; i\u0026lt;m; i++) { const Item\u0026amp; it = v[i]; if(it.type) s.insert(it.h); // Box else { auto itr = s.lower_bound(it.h); if(itr == s.end()) { puts(\u0026#34;No\u0026#34;); return 0; } s.erase(itr); } } puts(\u0026#34;Yes\u0026#34;); return 0; } ","date":"2022-03-28T21:00:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc245/","title":"AtCoder Beginner Contest 245 A~E Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed D - Swap Hats\rProblem Statement\rThere are 3 Takahashis wearing hats colored $S_1$, $S_2$, and $S_3$ respectively.\nWe want to perform exactly $10^{18}$ swap operations to make $S_i = T_i$.\nEach operation is defined as:\nSelect a pair $(i,j)$ and swap $S_i$ and $S_j$. Determine if the goal can be achieved.\nInput Format\r$S_1~S_2~S_3$\n$T_1~T_2~T_3$\nOutput Format\rPrint Yes if possible; otherwise, print No.\nSample\rSample Input\r1 2 R G B R G B Sample Output\r1 Yes Analysis\rWe manually enumerate all cases. The solution outputs Yes when all $S_i=T_i$ or all $S_i\\ne T_i$ (requiring even parity after $10^{18}$ swaps), otherwise No.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char a, b, c, d, e, f; scanf(\u0026#34;%c %c %c %c %c %c\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d, \u0026amp;e, \u0026amp;f); puts(((a == d) + (b == e) + (c == f)) == 1? \u0026#34;No\u0026#34;: \u0026#34;Yes\u0026#34;); return 0; } E - King Bombee\rProblem Statement\rGiven a simple undirected graph with $N$ vertices and $M$ edges. The $i$-th edge connects vertices $U_i$ and $V_i$.\nCount the number of paths from $S$ to $T$ with length $K$ that pass through vertex $X$ an even number of times, modulo $998244353$.\nConstraints:\n$2\\le N\\le 2000$\n$1\\le M\\le 2000$\n$1\\le K\\le 2000$\n$1\\le S,T,X\\le N$\n$X\\ne S,X\\ne T$\n$1\\le U_i \u003c V_i\\le N$\nAll edges are distinct.\nInput Format\r$N~M~K~S~T~X$\n$U_1~V_1$\n$\\vdots$\n$U_M~V_M$\nOutput Format\rPrint the count modulo $998244353$.\nSample\rSample Input 1\r1 2 3 4 5 4 4 4 1 3 2 1 2 2 3 3 4 1 4 Sample Output 1\r1 4 Valid paths:\n$1\\to2\\to1\\to2\\to3$ $1\\to2\\to3\\to2\\to3$ $1\\to4\\to1\\to4\\to3$ $1\\to4\\to3\\to4\\to3$ Each path visits $X=2$ even times.\nSample Input 2\r1 2 3 4 5 6 6 5 10 1 2 3 2 3 2 4 4 6 3 6 1 5 Sample Output 2\r1 0 Disconnected graph.\nSample Input 3\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 10 15 20 4 4 6 2 6 2 7 5 7 4 5 2 4 3 7 1 7 1 4 2 9 5 10 1 3 7 8 7 9 1 6 1 2 Sample Output 3\r1 952504739 Result modulo $998244353$.\nAnalysis\rDefine $\\mathrm{dp}(i,j,k)$ as the number of paths reaching vertex $j$ in $i$ steps with $k$ being the parity (even/odd) of visits to $X$. Transitions occur via adjacency list:\nWhen moving to vertex $v$, if $v=X$, toggle the parity bit. Use rolling array optimization for space efficiency. Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 2005 #define MOD 998244353 using namespace std; inline void mod(int\u0026amp; x) { if(x \u0026gt;= MOD) x -= MOD; } vector\u0026lt;int\u0026gt; G[maxn]; int dp[2][maxn][2]; int main() { int n, m, k, s, t, x; scanf(\u0026#34;%d%d%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k, \u0026amp;s, \u0026amp;t, \u0026amp;x); x --; while(m--) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[--u].push_back(--v); G[v].push_back(u); } dp[0][--s][0] = 1; for(int i=1; i\u0026lt;=k; i++) { bool c = i \u0026amp; 1, p = i \u0026amp; 1 ^ 1; for(int v=0; v\u0026lt;n; v++) { dp[c][v][0] = dp[c][v][1] = 0; for(int u: G[v]) mod(dp[c][v][0] += dp[p][u][u == x]), mod(dp[c][v][1] += dp[p][u][u != x]); } } printf(\u0026#34;%d\\n\u0026#34;, dp[k \u0026amp; 1][--t][0]); return 0; } F - Shortest Good Path\rAnalysis\rLet $\\mathrm{dis}[S][j]$ be the shortest length of a good path with respect to bitmask $S$ ending at vertex $j$. Perform BFS where each state $(S, v)$ represents the current bitmask and position. Use bitmask compression for efficiency.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define INF 2147483647 #define maxn 17 using namespace std; using ULL = unsigned long long; int dis[1 \u0026lt;\u0026lt; maxn][maxn]; vector\u0026lt;int\u0026gt; G[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[--u].push_back(--v); G[v].push_back(u); } queue\u0026lt;ULL\u0026gt; q; for(int i=0; i\u0026lt;n; i++) dis[1 \u0026lt;\u0026lt; i][i] = 1, q.push(1ULL\u0026lt;\u0026lt;i+32^i); while(!q.empty()) { ULL pkg = q.front(); q.pop(); int st = pkg \u0026gt;\u0026gt; 32ULL, v = pkg \u0026amp; 0x7fffffff; int nd = dis[st][v] + 1; for(int u: G[v]) { int nst = st ^ (1 \u0026lt;\u0026lt; u); if(dis[nst][u] == 0) { dis[nst][u] = nd; q.push(ULL(nst) \u0026lt;\u0026lt; 32ULL ^ u); } } } long long ans = 0LL; for(int i=1, lim=1\u0026lt;\u0026lt;n; i\u0026lt;lim; i++) { int cur = INF; for(int j=0; j\u0026lt;n; j++) if(dis[i][j] \u0026gt; 0 \u0026amp;\u0026amp; dis[i][j] \u0026lt; cur) cur = dis[i][j]; ans += cur; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2022-03-20T21:49:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc244/","title":"AtCoder Beginner Contest 244 D~F Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Preface\rRecently I suddenly wanted to know how many lines of code I\u0026rsquo;ve written, so I created this little tool\u0026hellip;\nPreparation\rFirst consider the desired output:\nLanguage Lines Size Files A 12345 300 KB 193 B 2345 165 KB 98 The program outputs a table sorted by code lines.\nBasic code framework:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # -*- encoding: utf-8 -*- import ... # Code lines counter class class CodeLinesCounter(object): SIZES = [(\u0026#39;B\u0026#39;, 1), (\u0026#39;KB\u0026#39;, 1024), (\u0026#39;MB\u0026#39;, 1024**2), (\u0026#39;GB\u0026#39;, 1024**3), (\u0026#39;TB\u0026#39;, 1024**4)] def __init__(self, languages): self._languages = languages # Languages (dict, {file_extension: language}) self._codelines = {suffix: (0, 0, 0) for suffix in languages} # Results, {suffix: (lines, size, files)} self._successful = self._error = 0 # Success/Error file counts # @param directory: Directory to scan # @param log: Whether to print logs def scan(self, directory, log=False): if log: print(\u0026#39;Scanning\u0026#39;, directory) pass def report(self): # Output results pass counter = CodeLinesCounter(languages={\u0026#39;py\u0026#39;: \u0026#39;Python\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;cpp\u0026#39;: \u0026#39;C++\u0026#39;, \u0026#39;java\u0026#39;: \u0026#39;Java\u0026#39;, \u0026#39;js\u0026#39;: \u0026#39;JavaScript\u0026#39;, \u0026#39;html\u0026#39;: \u0026#39;HTML\u0026#39;, \u0026#39;css\u0026#39;: \u0026#39;CSS\u0026#39;, \u0026#39;txt\u0026#39;: \u0026#39;Plain text\u0026#39;}) counter.scan(\u0026#39;E:/\u0026#39;) # Scan E drive (Note: cannot use \u0026#39;E:\u0026#39;) counter.report() Now let\u0026rsquo;s move to the ==core implementation==\nImplementation\rFile Scanning\rFirst, we need to get file lists under root directory using os.walk:\nos.walk(rootdir) returns a walker (iterable) containing file/directory lists for each subdirectory. Example:\nFor folder structure:\n1 2 3 4 5 6 7 8 Folder | file1 | Folder1 | file2 | file3 | Folder2 | file4 | Folder3 Running:\n1 2 3 4 import os for root, dirs, files in os.walk(\u0026#39;Folder\u0026#39;): print(root, dirs, files) Output:\n1 2 3 4 Folder\t[\u0026#39;Folder1\u0026#39;, \u0026#39;Folder2\u0026#39;]\t[\u0026#39;file1\u0026#39;] Folder\\Folder1\t[]\t[\u0026#39;file2\u0026#39;, \u0026#39;file3\u0026#39;] Folder\\Folder2\t[\u0026#39;Folder3\u0026#39;]\t[\u0026#39;file4\u0026#39;] Folder\\Folder2\\Folder3\t[]\t[] First element is current root, second is subdirectories, third is files.\nImplementation code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # -*- encoding: utf-8 -*- from os.path import join, getsize, abspath from os import walk class CodeLinesCounter(object): SIZES = [(\u0026#39;B\u0026#39;, 1), (\u0026#39;KB\u0026#39;, 1024), (\u0026#39;MB\u0026#39;, 1024**2), (\u0026#39;GB\u0026#39;, 1024**3), (\u0026#39;TB\u0026#39;, 1024**4)] def __init__(self, languages): self._languages = languages self._results = {suffix: (0, 0, 0) for suffix in languages} self._successful = self._error = 0 def scan(self, directory, log=False): if log: print(\u0026#39;Scanning\u0026#39;, directory) try: for root, _, files in walk(abspath(directory)): for filename in files: suffix = filename[filename.rfind(\u0026#39;.\u0026#39;) + 1:] filename = join(root, filename) if suffix in self._results: lines, size, numFiles = self._results[suffix] lines += 1 # Temporary line count, set to 1 first numFiles += 1 size += getsize(filename) # getsize returns bytes self._results[suffix] = (lines, size, numFiles) if log: print(filename) except KeyboardInterrupt: print(\u0026#39;\\nUser stopped operation\u0026#39;) else: if log: print(\u0026#39;Scan finished\u0026#39;) def report(self): print(\u0026#39;Language\\tLines\\tSize\\tFiles\u0026#39;) for suffix, (lines, size, files) in sorted(self._results.items(), key=lambda x: x[1], reverse=True): print(self._languages[suffix], lines, self.__format_size(size), files, sep=\u0026#39;\\t\u0026#39;) # Unit conversion def __format_size(self, bytes): for suffix, size in self.SIZES: if bytes \u0026lt; size * 1024: return \u0026#39;%.2f %s\u0026#39; % (bytes / size, suffix) return \u0026#39;%.2f %s\u0026#39; % (bytes / self.SIZES[-1][1], 2, self.SIZES[-1][0]) counter = CodeLinesCounter(languages={\u0026#39;py\u0026#39;: \u0026#39;Python\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;cpp\u0026#39;: \u0026#39;C++\u0026#39;, \u0026#39;java\u0026#39;: \u0026#39;Java\u0026#39;, \u0026#39;js\u0026#39;: \u0026#39;JavaScript\u0026#39;, \u0026#39;html\u0026#39;: \u0026#39;HTML\u0026#39;, \u0026#39;css\u0026#39;: \u0026#39;CSS\u0026#39;, \u0026#39;txt\u0026#39;: \u0026#39;Plain text\u0026#39;}) counter.scan(\u0026#39;E:/\u0026#39;) counter.report() Sample output (manually formatted):\n1 2 3 4 5 6 7 8 9 Language Lines Size Files C++ 667 671.51 KB 667 Python 317 981.01 KB 317 HTML 38 466.52 KB 38 Plain text 34 90.69 KB 34 JavaScript 19 1.43 MB 19 CSS 9 341.04 KB 9 C 2 20.45 KB 2 Java 1 676.00 B 1 Next step: actual line counting.\nLine Counting\rEmpty lines shouldn\u0026rsquo;t be counted. Modify line 23:\n1 2 3 4 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: # Open with utf-8 for line in f: if line and not line.isspace(): # Skip empty lines lines += 1 But when running:\n1 2 3 Traceback (most recent call last): ... UnicodeDecodeError: \u0026#39;utf-8\u0026#39; codec can\u0026#39;t decode byte 0xb5 in position 355: invalid start byte Some files use GBK encoding. Improved code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 try: ln = 0 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: for line in f: if line and not line.isspace(): ln += 1 except UnicodeDecodeError: # Try GBK try: ln = 0 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;gbk\u0026#39;) as f: for line in f: if line and not line.isspace(): ln += 1 except: print(filename, \u0026#39;[Error: unknown encoding]\u0026#39;) self._error += 1 else: lines += ln except Exception as e: print(filename, \u0026#39;[Unknown error: %s]\u0026#39; % e) self._error += 1 continue lines += ln if log: print(f\u0026#39;{filename} [{ln}]\u0026#39;) self._successful += 1 Now correct results:\n1 2 3 4 5 6 7 8 9 Language Lines Size Files C++ 35595 671.51 KB 667 JavaScript 24485 1.43 MB 19 Python 24130 982.16 KB 317 CSS 8203 341.04 KB 9 HTML 6138 466.52 KB 38 Plain text 741 90.69 KB 34 C 557 20.45 KB 2 Java 29 676.00 B 1 Final step: table formatting.\nTable Formatting\rUse PrettyTable library:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 # -*- encoding: utf-8 -*- from os.path import join, getsize, abspath from os import walk from prettytable import PrettyTable class CodeLinesCounter(object): SIZES = [(\u0026#39;B\u0026#39;, 1), (\u0026#39;KB\u0026#39;, 1024), (\u0026#39;MB\u0026#39;, 1024**2), (\u0026#39;GB\u0026#39;, 1024**3), (\u0026#39;TB\u0026#39;, 1024**4)] def __init__(self, languages): self._languages = languages self._results = {suffix: (0, 0, 0) for suffix in languages} self._successful = self._error = 0 def scan(self, directory, log=False): if log: print(\u0026#39;Scanning\u0026#39;, directory) try: for root, _, files in walk(abspath(directory)): for filename in files: suffix = filename[filename.rfind(\u0026#39;.\u0026#39;) + 1:] filename = join(root, filename) if suffix in self._results: lines, size, numFiles = self._results[suffix] numFiles += 1 size += getsize(filename) try: ln = 0 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: for line in f: if line and not line.isspace(): ln += 1 except UnicodeDecodeError: try: ln = 0 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;gbk\u0026#39;) as f: for line in f: if line and not line.isspace(): ln += 1 except: print(filename, \u0026#39;[Error: unknown encoding]\u0026#39;) self._error += 1 else: lines += ln except Exception as e: print(filename, \u0026#39;[Unknown error: %s]\u0026#39; % e) self._error += 1 continue lines += ln if log: print(f\u0026#39;{filename} [{ln}]\u0026#39;) self._successful += 1 self._results[suffix] = (lines, size, numFiles) elif log: print(filename, \u0026#39;[None]\u0026#39;) except KeyboardInterrupt: print(\u0026#39;\\nUser stopped operation\u0026#39;) else: if log: print(\u0026#39;Scan finished\u0026#39;) def report(self): table = PrettyTable([\u0026#39;Language\u0026#39;, \u0026#39;Lines\u0026#39;, \u0026#39;Size\u0026#39;, \u0026#39;Files\u0026#39;], title=f\u0026#39;Scan result (OK {self._successful}, Error {self._error})\u0026#39;) for suffix, (lines, size, files) in sorted(self._results.items(), key=lambda x: x[1], reverse=True): table.add_row([self._languages[suffix], lines, self.__format_size(size), files]) print(table) def __format_size(self, bytes): for suffix, size in self.SIZES: if bytes \u0026lt; size * 1024: return \u0026#39;%.2f %s\u0026#39; % (bytes / size, suffix) return \u0026#39;%.2f %s\u0026#39; % (bytes / self.SIZES[-1][1], 2, self.SIZES[-1][0]) counter = CodeLinesCounter(languages={\u0026#39;py\u0026#39;: \u0026#39;Python\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;cpp\u0026#39;: \u0026#39;C++\u0026#39;, \u0026#39;java\u0026#39;: \u0026#39;Java\u0026#39;, \u0026#39;js\u0026#39;: \u0026#39;JavaScript\u0026#39;, \u0026#39;html\u0026#39;: \u0026#39;HTML\u0026#39;, \u0026#39;css\u0026#39;: \u0026#39;CSS\u0026#39;, \u0026#39;txt\u0026#39;: \u0026#39;Plain text\u0026#39;}) counter.scan(\u0026#39;E:/\u0026#39;) counter.report() Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 +----------------------------------------+ | Scan result (OK 1087, Error 0) | +------------+-------+-----------+-------+ | Language | Lines | Size | Files | +------------+-------+-----------+-------+ | C++ | 35595 | 671.51 KB | 667 | | JavaScript | 24485 | 1.43 MB | 19 | | Python | 24130 | 982.16 KB | 317 | | CSS | 8203 | 341.04 KB | 9 | | HTML | 6138 | 466.52 KB | 38 | | Plain text | 741 | 90.69 KB | 34 | | C | 557 | 20.45 KB | 2 | | Java | 29 | 676.00 B | 1 | +------------+-------+-----------+-------+ Conclusion\rFinal code (without comments):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 # -*- encoding: utf-8 -*- from os.path import join, getsize, abspath from os import walk from prettytable import PrettyTable class CodeLinesCounter(object): SIZES = [(\u0026#39;B\u0026#39;, 1), (\u0026#39;KB\u0026#39;, 1024), (\u0026#39;MB\u0026#39;, 1024**2), (\u0026#39;GB\u0026#39;, 1024**3), (\u0026#39;TB\u0026#39;, 1024**4)] def __init__(self, languages): self._languages = languages self._results = {suffix: (0, 0, 0) for suffix in languages} self._successful = self._error = 0 def scan(self, directory, log=False): if log: print(\u0026#39;Scanning\u0026#39;, directory) try: for root, _, files in walk(abspath(directory)): for filename in files: suffix = filename[filename.rfind(\u0026#39;.\u0026#39;) + 1:] filename = join(root, filename) if suffix in self._results: lines, size, numFiles = self._results[suffix] numFiles += 1 size += getsize(filename) try: ln = 0 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: for line in f: if line and not line.isspace(): ln += 1 except UnicodeDecodeError: try: ln = 0 with open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;gbk\u0026#39;) as f: for line in f: if line and not line.isspace(): ln += 1 except: print(filename, \u0026#39;[Error: unknown encoding]\u0026#39;) self._error += 1 else: lines += ln except Exception as e: print(filename, \u0026#39;[Unknown error: %s]\u0026#39; % e) self._error += 1 continue lines += ln if log: print(f\u0026#39;{filename} [{ln}]\u0026#39;) self._successful += 1 self._results[suffix] = (lines, size, numFiles) elif log: print(filename, \u0026#39;[None]\u0026#39;) except KeyboardInterrupt: print(\u0026#39;\\nUser stopped operation\u0026#39;) else: if log: print(\u0026#39;Scan finished\u0026#39;) def report(self): table = PrettyTable([\u0026#39;Language\u0026#39;, \u0026#39;Lines\u0026#39;, \u0026#39;Size\u0026#39;, \u0026#39;Files\u0026#39;], title=f\u0026#39;Scan result (OK {self._successful}, Error {self._error})\u0026#39;) for suffix, (lines, size, files) in sorted(self._results.items(), key=lambda x: x[1], reverse=True): table.add_row([self._languages[suffix], lines, self.__format_size(size), files]) print(table) def __format_size(self, bytes): for suffix, size in self.SIZES: if bytes \u0026lt; size * 1024: return \u0026#39;%.2f %s\u0026#39; % (bytes / size, suffix) return \u0026#39;%.2f %s\u0026#39; % (bytes / self.SIZES[-1][1], 2, self.SIZES[-1][0]) counter = CodeLinesCounter(languages={\u0026#39;py\u0026#39;: \u0026#39;Python\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;cpp\u0026#39;: \u0026#39;C++\u0026#39;, \u0026#39;java\u0026#39;: \u0026#39;Java\u0026#39;, \u0026#39;js\u0026#39;: \u0026#39;JavaScript\u0026#39;, \u0026#39;html\u0026#39;: \u0026#39;HTML\u0026#39;, \u0026#39;css\u0026#39;: \u0026#39;CSS\u0026#39;, \u0026#39;txt\u0026#39;: \u0026#39;Plain text\u0026#39;}) counter.scan(\u0026#39;E:/\u0026#39;) counter.report() Future improvements:\nAdd regex file ignore matplotlib visualization PyQt5 GUI \u0026hellip; (Welcome valuable suggestions!) ","date":"2022-03-15T15:24:00+08:00","permalink":"https://goodcoder666.github.io/en/p/py_codelinescounter/","title":"„ÄêPython„Äë72-Line Code Lines Counter, Simple and Practical!"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed C - 1111gal password\rProblem Statement\rGiven a positive integer $N$, find the number of integers $X$ satisfying the following conditions, modulo $998244353$:\n$X$ is an $N$-digit positive integer Every digit of $X$ is between $[1,9]$ (==0 is forbidden==) The absolute difference between adjacent digits in $X$ is at most 1. $2\\le N\\le 10^6$\nInput Format\r$N$\nOutput Format\rPrint the answer.\nSample\r$N$ Output $4$ $203$ $2$ $25$ $1000000$ $248860093$ Analysis\rBy the multiplication principle, the maximum possible count of valid $N$-digit numbers is $9^N$, which is clearly infeasible for brute force. However, since each digit is constrained by its predecessor, a dynamic programming (DP) approach is natural.\n$$\rf(i,j)=\\begin{cases}\r1\u0026(i=1)\\\\\rf(i-1,1)+f(i-1,2)\u0026(j=1)\\\\\rf(i-1,8)+f(i-1,9)\u0026(j=9)\\\\\rf(i-1,j-1)+f(i-1,j)+f(i-1,j+1)\u0026(i\u003e1,2\\le j\\le8)\r\\end{cases}\r$$\nThe final answer is $\\sum\\limits_{i=1}^9f(n,i)$.\nCode\rThis code employs rolling table optimization to reduce memory usage. Directly allocating an $N\\times9$ array is possible but memory-intensive.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;cstdio\u0026gt; #define MOD 998244353 using namespace std; inline void mod(int\u0026amp; x) { if(x \u0026gt;= MOD) x -= MOD; } int dp[9], ldp[9]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;9; i++) dp[i] = 1; while(--n) { for(int i=0; i\u0026lt;9; i++) ldp[i] = dp[i]; mod(dp[0] += dp[1]), mod(dp[8] += dp[7]); for(int i=1; i\u0026lt;8; i++) mod(dp[i] += ldp[i - 1]), mod(dp[i] += ldp[i + 1]); } int ans = 0; for(int i=0; i\u0026lt;9; i++) mod(ans += dp[i]); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - ABC Transform\rProblem Statement\rGiven a string $S$ composed of A, B, C. Define $S_0=S$ and $S_i$ as the string formed by replacing each character in $S_{i-1}$:\nA ‚Üí BC B ‚Üí CA C ‚Üí AB Answer $Q$ queries where the $i$-th query asks for the $k_i$-th character in $S_{t_i}$.\n$1\\le |S|\\le 10^5$\n$1\\le Q\\le 10^5$\n$1\\le t_i\\le 10^{18}$\n$1\\le k_i\\le min(10^{18},$ length of $S_{t_i})$\nInput Format\r$S$\n$Q$\n$t_1~k_1$\n$\\vdots$\n$t_Q~k_Q$\nSample\rSample Input 1\r1 2 3 4 5 6 ABC 4 0 1 1 1 1 3 1 6 Sample Output 1\r1 2 3 4 A B C B $S_0=~$ABC $S_1=~$AABCB Sample Input 2\r1 2 3 4 5 6 7 CBBAACCCCC 5 57530144230160008 659279164847814847 29622990657296329 861239705300265164 509705228051901259 994708708957785197 176678501072691541 655134104344481648 827291290937314275 4071211144297426665 Sample Output 2\r1 2 3 4 5 A A C A A Beware of integer overflow issues.\nAnalysis\r$$\rf(t,k)=\\begin{cases}\r0 \u0026 (t=0)\\\\\rg(0,t) \u0026 (k=0)\\\\\rg(f(t-1,\\lfloor\\frac k2\\rfloor),(k\\bmod2)+1) \u0026 (t\u003e0,k\u003e0)\r\\end{cases}\r$$\nwhere $g(c,x)$ returns the $(c+x)$-th character modulo 3 in the cyclic sequence A‚ÜíB‚ÜíC‚ÜíA....\nThe solution involves determining which original character in $S$ generates the queried position. The final answer is $\\mathrm{ans}=g(f(t,(k-1)\\bmod2^t),S_{\\lfloor\\frac {k-1}{2^t}\\rfloor})$.\nCode\rBoth implementations below use iterative approaches. Recursive versions are also feasible.\nCode 1 (Standard)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;cstdio\u0026gt; using namespace std; char s[100005]; int main() { scanf(\u0026#34;%s\u0026#34;, s); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while(q--) { long long t, k; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;t, \u0026amp;k); k --; int x = s[t \u0026lt; 64? k \u0026gt;\u0026gt; t: 0] - \u0026#39;A\u0026#39;; // Prevent t from being too large causing RE while(t \u0026gt; 0 \u0026amp;\u0026amp; k \u0026gt; 0) { x = (x + int(k \u0026amp; 1LL) + 1) % 3; k \u0026gt;\u0026gt;= 1LL, t --; } putchar((t + x) % 3 + \u0026#39;A\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); } return 0; } Code 2 (Optimized)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; using namespace std; char s[100005]; int main() { scanf(\u0026#34;%s\u0026#34;, s); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while(q--) { long long t, k; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;t, \u0026amp;k); k --; int c = 0; if(t \u0026lt; 64) { c = s[k \u0026gt;\u0026gt; t] - \u0026#39;A\u0026#39;; k \u0026amp;= (1LL \u0026lt;\u0026lt; t) - 1LL; } else c = s[0] - \u0026#39;A\u0026#39;; for(c+=t%3; k\u0026gt;0; k\u0026amp;=k-1) c ++; putchar(c % 3 + \u0026#39;A\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); } return 0; } E - (‚àÄx‚àÄ)\rProblem Statement\rFor $T$ test cases, solve the following:\nGiven integer $N$ and string $S$, count the number of valid palindromic strings $X$ satisfying:\n$|X|=N$ $X$ consists of uppercase letters $X\\le S$ lexicographically $1\\le T\\le 250000$\n$1\\le N\\le 10^6$\n$1\\le \\sum N\\le 10^6$\n$|S|=N$ with uppercase letters.\nAnalysis\rThe palindrome $X$ is uniquely determined by its first $\\lceil\\frac N2\\rceil$ characters. Consider ABCDE:\nThe first 3 characters are ABC There are $28$ valid prefixes lex-order smaller than ABC (treated as a base-26 number) Check if ABCBA ‚â§ ABCDE If valid, total becomes $28+1=29$ Thus, output $29$. Other cases follow similarly.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;cstdio\u0026gt; #define maxn 1000005 #define MOD 998244353 using namespace std; using LL = long long; char s[maxn]; int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d%s\u0026#34;, \u0026amp;n, \u0026amp;s); long long x = 0LL; int j = n - 1 \u0026gt;\u0026gt; 1; for(int i=0; i\u0026lt;=j; i++) (x = x * 26LL + s[i] - \u0026#39;A\u0026#39;) %= MOD; bool ok = true; while(j \u0026gt;= 0) { if(s[j] \u0026lt; s[n - 1 - j]) break; if(s[j] \u0026gt; s[n - 1 - j]) { ok = false; break;} j --; } if(ok \u0026amp;\u0026amp; ++x == MOD) x -= MOD; printf(\u0026#34;%lld\\n\u0026#34;, x); } return 0; } ","date":"2022-03-08T22:30:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc242/","title":"AtCoder Beginner Contest 242 C~E Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed D - Sequence Query\rProblem Summary\rWe have an empty sequence $A$. Process $Q$ commands in order, each of three types:\n1 x: Add $x$ to $A$ (without deduplication) 2 x k: Find the $k$-th largest value among elements $\\le x$ in $A$. 3 x k: Find the $k$-th smallest value among elements $\\ge x$ in $A$. $1\\le Q\\le 2\\times 10^5$\n$1\\le x\\le 10^{18}$\n==$1\\le k\\le 5$==\nAnalysis\rGiven $1\\le k\\le 5$, we can use multiset.\nmultiset supports binary search. For details, see here.\nFor each query:\n1 x: Directly insert into multiset 2 x k: Use upper_bound, then move iterator backward $k$ steps 3 x k: Use lower_bound, then move iterator forward $k$ steps Due to small $k$, moving iterators is negligible.\nTime complexity: Optimal $\\mathcal O(Q)$, average $\\mathcal O(Q\\log Q)$, worst $\\mathcal O(Q\\log Q)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { multiset\u0026lt;long long\u0026gt; s; int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while(q--) { int op; long long x; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;op, \u0026amp;x); if(op == 1) s.insert(x); else { int k; scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); if(op == 2) { bool bad = false; auto it = s.upper_bound(x); for(; k--; --it) if(it == s.begin()) { bad = true; break; } if(bad) puts(\u0026#34;-1\u0026#34;); else printf(\u0026#34;%lld\\n\u0026#34;, *it); } else { auto it = s.lower_bound(x); for(; --k; ++it) if(it == s.end()) break; if(it == s.end()) puts(\u0026#34;-1\u0026#34;); else printf(\u0026#34;%lld\\n\u0026#34;, *it); } } } return 0; } E - Putting Candies\rProblem Summary\rGiven sequence $A=(A_0,A_1,\\dots,A_{N-1})$.\nStart with an empty plate. Takahashi adds $A_{(X\\bmod N)}$ candies each time (where $X$ is current candy count).\nFind total candies after $K$ operations.\n$2\\le N\\le 2\\times 10^5$\n$1\\le K\\le 10^{12}$\n$1\\le A_i\\le 10^6$\nAnalysis\rBy pigeonhole principle, $A_{(X\\bmod N)}$ must repeat within $N$ operations.\nThis becomes a periodic problem. We record time mappings to reconstruct cycles.\nTime complexity: $\\mathcal O(n)$, space complexity: $\\mathcal O(n)$.\nCode\rCode reference: AtCoder Editorial\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 using namespace std; using LL = long long; LL A[maxn], S[maxn]; int pre[maxn]; int main() { int n; LL k; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%lld\u0026#34;, A + i); for(int i=1; i\u0026lt;n; i++) pre[i] = -1; int time, s; for(int i=0; i\u0026lt;n; i++) { S[i + 1] = S[i] + A[S[i] % n]; if(pre[S[i + 1] % n] != -1) { s = pre[S[i + 1] % n]; time = i + 1; break; } pre[S[i + 1] % n] = i + 1; } if(k \u0026lt;= s) printf(\u0026#34;%lld\\n\u0026#34;, S[k]); else { int p = time - s; LL X = S[time] - S[s], t = k - s - 1; printf(\u0026#34;%lld\\n\u0026#34;, S[s + t % p + 1] + t / p * X); } return 0; } F - Skate\rProblem Summary\rGiven $H\\times W$ grid with $N$ obstacles at $(X_i,Y_i)$.\nStart at $(s_x,s_y)$, slide in up/down/left/right until hitting an obstacle, stopping at the preceding cell. Find minimum steps to reach $(g_x,g_y)$. Output -1 if impossible.\n$1\\le H,W\\le 10^9$\n==$1\\le N\\le 10^5$==\n$1\\le s_x,g_x,X_i\\le H$\n$1\\le s_y,g_y,Y_i\\le W$\n$(s_x,s_y)\\ne(g_x,g_y)\\ne(X_i,Y_i)$\nAll $(X_i,Y_i)$ are distinct.\nAnalysis\rDespite large grid dimensions, $N$ is manageable. Use BFS with map/set to track rows/columns. For each coordinate, binary search nearby obstacles.\nCode\rNotes:\nRow/column coordinates must be sorted (can use set) Handle binary search boundaries carefully 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; using LL = long long; unordered_map\u0026lt;int, set\u0026lt;int\u0026gt;\u0026gt; row, col; unordered_map\u0026lt;LL, int\u0026gt; dis; inline LL pack(LL x, int y) { return x \u0026lt;\u0026lt; 31LL | y; } inline void unpack(const LL\u0026amp; b, int\u0026amp; x, int\u0026amp; y) { x = b \u0026gt;\u0026gt; 31LL, y = b \u0026amp; 0x7fffffff; } int main() { int h, w, n, sx, sy, gx, gy; scanf(\u0026#34;%d%d%d%d%d%d%d\u0026#34;, \u0026amp;h, \u0026amp;w, \u0026amp;n, \u0026amp;sx, \u0026amp;sy, \u0026amp;gx, \u0026amp;gy); for(int i=0; i\u0026lt;n; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); row[x].insert(y); col[y].insert(x); } LL target = pack(gx, gy); queue\u0026lt;pair\u0026lt;LL, int\u0026gt;\u0026gt; q; q.emplace(pack(sx, sy), 0); while(!q.empty()) { auto [p, d] = q.front(); q.pop(); if(!dis.emplace(p, d).second) continue; if(p == target) { printf(\u0026#34;%d\\n\u0026#34;, d); return 0; } int x, y; unpack(p, x, y), ++d; if(row.count(x)) { auto\u0026amp; s = row[x]; auto it = s.lower_bound(y); if(it != s.end()) q.emplace(pack(x, *it - 1), d); if(it != s.begin()) q.emplace(pack(x, *--it + 1), d); } if(col.count(y)) { auto\u0026amp; s = col[y]; auto it = s.lower_bound(x); if(it != s.end()) q.emplace(pack(*it - 1, y), d); if(it != s.begin()) q.emplace(pack(*--it + 1, y), d); } } puts(\u0026#34;-1\u0026#34;); return 0; } ","date":"2022-03-05T23:01:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc241/","title":"AtCoder Beginner Contest 241 (Sponsored by Panasonic) D~F Solution"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed C - Knight Fork\rProblem Statement\rDetermine if there exists an integer coordinate point on the 2D plane whose Euclidean distances to both $(x_1,y_1)$ and $(x_2,y_2)$ are $\\sqrt{5}$.\nInput Format\r$x_1~y_1~x_2~y_2$\nOutput Format\rPrint Yes if such a point exists; otherwise, print No.\nSample Cases\r$x_1$ $y_1$ $x_2$ $y_2$ Output $0$ $0$ $3$ $3$ Yes $0$ $1$ $2$ $3$ No $1000000000$ $1000000000$ $999999999$ $999999999$ Yes Analysis\r$$\r(a-c)^2+(b-d)^2=5\\\\\r\\{a-c,b-d\\}=\\{1,2\\}\r$$\nThus, for the point $(0,0)$, the points with distance $\\sqrt{5}$ are shown below (similar for other points):\nWe generate all points with distance $\\sqrt{5}$ from $(x_1,y_1)$ and check their distances to $(x_2,y_2)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; using namespace std; using LL = long long; const int d[8] = {-1, 1, 2, 2, 1, -1, -2, -2}; inline LL sqr2(const LL\u0026amp; x, const LL\u0026amp; y) { return x * x + y * y; } int main() { LL x1, y1, x2, y2; scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2); x1 -= x2, y1 -= y2; for(int i=0; i\u0026lt;8; i++) if(sqr2(x1 + d[i], y1 + d[(i + 2) \u0026amp; 7]) == 5) { puts(\u0026#34;Yes\u0026#34;); return 0; } puts(\u0026#34;No\u0026#34;); return 0; } D - Prime Sum Game\r==Water problem warning==\nProblem Statement\rTakahashi and Aoki play a game as follows:\nTakahashi selects an integer $A\\le N\\le B$. Aoki selects an integer $C\\le M\\le D$. If $N+M$ is prime, Aoki wins. Otherwise, Takahashi wins. Determine the winner when both play optimally.\n$1\\le A\\le B\\le 100$\n$1\\le C\\le D\\le 100$\nInput Format\r$A~B~C~D$\nOutput Format\rPrint the winner\u0026rsquo;s name: Takahashi or Aoki.\nSample Cases\r$A$ $B$ $C$ $D$ Output $2$ $3$ $3$ $4$ Aoki $1$ $100$ $50$ $60$ Takahashi $3$ $14$ $1$ $5$ Aoki Analysis\rThe key is understanding \u0026ldquo;optimal play\u0026rdquo;:\nTakahashi wins if there exists an $N$ such that $N+M$ is never prime for any $M$. Aoki wins if for every $N$, there exists an $M$ making $N+M$ prime. Given small constraints, we brute-force all pairs. Time complexity is $\\mathcal O(BD)$.\nCode\rP.S. Surprisingly, runtime is 4ms (expected ~30ms).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;cstdio\u0026gt; using namespace std; inline bool isprime(int x) { for(int t=__builtin_sqrt(x), i=2; i\u0026lt;=t; i++) if(x % i == 0) return false; return true; } int main() { int a, b, c, d; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); for(int i=a; i\u0026lt;=b; i++) { int j = c; for(; j\u0026lt;=d; j++) if(isprime(i + j)) break; if(j \u0026gt; d) { puts(\u0026#34;Takahashi\u0026#34;); return 0; } } puts(\u0026#34;Aoki\u0026#34;); return 0; } E - Subtree K-th Max\rProblem Statement\rGiven a tree with $N$ nodes (1-based) rooted at node 1. Each node $v$ has a value $X_v$.\nAnswer $Q$ queries $(V_i,K_i)$:\nFind the K-th largest value (without deduplication) in the subtree rooted at $V_i$. $2\\le N,Q\\le 10^5$\n$0\\le X_i\\le 10^9$\n$1\\le A_i,B_i,V_i\\le N$\n==$1\\le K_i\\le 20$==\nInput Format\r$N~Q$\n$X_1~\\dots~X_N$\n$A_1~B_1$\n$\\vdots$\n$A_{N-1}~B_{N-1}$\n$V_1~K_1$\n$\\vdots$\n$V_Q~K_Q$\nOutput Format\rPrint $Q$ lines. The i-th line contains the answer to the i-th query.\nSample Cases\rSee AtCoder for details.\nAnalysis\rGiven $1\\le K\\le 20$, precompute the top-20 values for each node\u0026rsquo;s subtree. Use DFS to merge node values and children\u0026rsquo;s top-20 lists. Sorting can be optimized with priority_queue. Time complexity is $\\mathcal O(N+Q)$.\nCode\rSample implementation uses DFS with priority_queue (190ms runtime):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define maxn 100005 using namespace std; int x[maxn]; vector\u0026lt;int\u0026gt; G[maxn], dp[maxn]; void dfs(int v, int par) { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; q.push(x[v]); for(int u: G[v]) if(u != par) { dfs(u, v); for(int val: dp[u]) { q.push(val); if(q.size() \u0026gt; 20) q.pop(); } } while(!q.empty()) { dp[v].push_back(q.top()); q.pop(); } } int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, x + i); for(int i=1; i\u0026lt;n; i++) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); G[--a].push_back(--b); G[b].push_back(a); } dfs(0, -1); while(q--) { int v, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;v, \u0026amp;k); const auto\u0026amp; d = dp[--v]; printf(\u0026#34;%d\\n\u0026#34;, d[d.size() - k]); } return 0; } ","date":"2022-02-25T23:08:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc239/","title":"Denso Create Programming Contest 2022 (AtCoder Beginner Contest 239) Solutions to Problems C~E"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - kcal\rProblem Statement\rWe have a beverage that contains $A$ kilocalories per 100 milliliters. How many kilocalories does $B$ milliliters of this beverage contain?\n$0\\le A, B\\le 1000$\nInput Format\r$A~B$\nOutput Format\rOutput the number of kilocalories in $B$ milliliters. Maximum allowable floating-point precision error is $10^{-6}$.\nSamples\r$A$ $B$ Output $45$ $200$ $90$ $37$ $450$ $166.5$ $0$ $1000$ $0$ $50$ $0$ $0$ Analysis\rThe answer is simply $\\frac{AB}{100}$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); a *= b; printf(\u0026#34;%d.%d\\n\u0026#34;, a / 100, a % 100); return 0; } B - Permutation Check\rProblem Statement\rGiven a sequence $A=(A_1,A_2,\\dots,A_N)$ of length $N$, determine whether $A$ is a permutation of $(1, 2, \\dots, N)$.\n$1\\le A_i\\le N\\le 10^3$\nInput Format\r$N$\n$A_1~A_2~\\dots~A_N$\nOutput Format\rPrint Yes if $A$ is a permutation of $(1, 2, \\dots, N)$, otherwise print No.\nSamples\rSample Input 1\r1 2 5 3 1 2 4 5 Sample Output 1\r1 Yes $(3,1,2,4,5)$ is a permutation of $(1,2,3,4,5)$, so output Yes.\nSample Input 2\r1 2 6 3 1 4 1 5 2 Sample Output 2\r1 No $(3,1,4,1,5,2)$ is not a permutation of $(1,2,3,4,5,6)$, so output No.\nSample Input 3\r1 2 3 1 2 3 Sample Output 3\r1 Yes Sample Input 4\r1 2 1 1 Sample Output 4\r1 Yes Analysis\rSince $1\\le A_i\\le N$, $A$ is a permutation if and only if all numbers from $1$ to $N$ appear exactly once. We can track occurrences using an array with $\\mathcal O(n)$ time complexity.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;cstdio\u0026gt; #define maxn 1005 using namespace std; bool used[maxn]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); if(used[a]) { puts(\u0026#34;No\u0026#34;); return 0; } used[a] = true; } puts(\u0026#34;Yes\u0026#34;); return 0; } C - POW\rProblem Statement\rGiven integers $A$, $B$, and $C$, determine whether $A^C$ is less than, greater than, or equal to $B^C$.\n$-10^9\\le A,B\\le 10^9$\n$1\\le C\\le 10^9$\nInput Format\r$A~B~C$\nOutput Format\rOutput:\n\u0026lt; if $A^C \u003c B^C$, \u0026gt; if $A^C \u003e B^C$, = if $A^C = B^C$. Samples\r$A$ $B$ $C$ Output $3$ $2$ $4$ \u0026gt; $-7$ $7$ $2$ = $-8$ $6$ $3$ \u0026lt; Analysis\rFor even $C$, compare absolute values. For odd $C$, compare original values. This simplifies to comparing $|A|$ vs $|B|$ (if $C$ is even) or $A$ vs $B$ (if $C$ is odd).\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); if(!(c \u0026amp; 1)) { if(a \u0026lt; 0) a = -a; if(b \u0026lt; 0) b = -b; } puts(a \u0026lt; b? \u0026#34;\u0026lt;\u0026#34;: a \u0026gt; b? \u0026#34;\u0026gt;\u0026#34;: \u0026#34;=\u0026#34;); return 0; } D - Kth Excluded\rProblem Statement\rGiven a sorted sequence $A=(A_1,A_2,\\dots,A_N)$ of positive integers and $Q$ queries, find the $K_i$-th smallest positive integer not present in $A$.\n$1\\le N,Q\\le 10^5$\n$1\\le A_1 \u003c A_2 \u003c \\dots \u003c A_N\\le10^{18}$\n$1\\le K_i\\le 10^{18}$\nInput Format\r$N~Q$\n$A_1~A_2~\\dots~A_N$\n$K_1$\n$K_2$\n$\\hspace{5pt}\\vdots$\n$K_Q$\nOutput Format\rOutput $Q$ lines, each containing the answer for the corresponding query.\nSamples\rSample Input 1\r1 2 3 4 5 4 3 3 5 6 7 2 5 3 Sample Output 1\r1 2 3 2 9 4 The missing positive integers are $1,2,4,8,9,10,11,\\dots$. The 2nd, 5th, and 3rd smallest are $2$, $9$, $4$.\nSample Input 2\r1 2 3 4 5 2 1 2 3 4 5 1 10 Sample Output 2\r1 2 6 15 Analysis\rPrecompute how many elements in $A$ are less than each possible $k$, then use binary search to find the position where $k$ falls. Time complexity: $\\mathcal O(Q \\log N)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 100005 using namespace std; using LL = long long; LL a[maxn]; int main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%lld\u0026#34;, a + i); a[i] -= i; } while(q--) { LL k; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;k); printf(\u0026#34;%lld\\n\u0026#34;, k + (upper_bound(a, a + n, k) - a)); } return 0; } E - White and Black Balls\rProblem Statement\rCount the number of valid arrangements of $N$ white and $M$ black balls such that for every prefix of length $i$, the number of white balls $w_i$ and black balls $b_i$ satisfy $w_i \\le b_i + K$. Modulo $10^9+7$.\n$0\\le N,M\\le10^6$\n$1\\le N+M$\n$0\\le K\\le N$\nInput Format\r$N~M~K$\nOutput Format\rOutput the count modulo $10^9+7$.\nSamples\r$N$ $M$ $K$ Output $2$ $3$ $1$ $9$ $1$ $0$ $0$ $0$ $1000000$ $1000000$ $1000000$ $192151600$ Analysis\rThe valid count equals the Catalan-like number $\\binom{N+M}{N} - \\binom{N+M}{M+K+1}$ when $N \\le M + K$, otherwise $0$. This uses combinatorial subtraction for paths crossing a boundary.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;atcoder/modint\u0026gt; using namespace std; using modint = atcoder::modint1000000007; modint f(int n, int m) { if(n \u0026lt; 0 || m \u0026lt; 0) return 0; modint ret = 1; for(int i=1; i\u0026lt;=m; i++) ret = ret * (n + i) / i; return ret; } int main() { int n, m, k; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); if(n \u0026gt; m + k) puts(\u0026#34;0\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, (f(n, m) - f(n - k - 1, m + k + 1)).val()); return 0; } ","date":"2021-07-07T16:40:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc205/","title":"AtCoder Beginner Contest 205 A~E Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Square Inequality\rProblem Statement\rGiven three integers $A$, $B$, and $C$, determine if $A^2 + B^2 \u003c C^2$ holds.\n$0 \\le A,B,C \\le 1000$\nInput Format\r$A~B~C$\nOutput Format\rPrint Yes if $A^2 + B^2 \u003c C^2$; otherwise, print No.\nSamples\r$A$ $B$ $C$ Output $2$ $2$ $4$ Yes $10$ $10$ $10$ No $3$ $4$ $5$ No Analysis\rDirectly compute according to the problem statement.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); puts(a * a + b * b \u0026lt; c * c? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Intersection\rProblem Statement\rGiven two sequences of length $N$: $A = (A_1, A_2, A_3, \\dots, A_N)$ and $B = (B_1, B_2, B_3, \\dots, B_N)$. Find the number of integers $x$ satisfying:\nFor all $1 \\le i \\le N$, $A_i \\le x \\le B_i$. $1 \\le N \\le 100$\n$1 \\le A_i \\le B_i \\le 1000$\nInput Format\r$N$\n$A_1~A_2~\\dots~A_N$\n$B_1~B_2~\\dots~B_N$\nOutput Format\rPrint the answer.\nSamples\rSample Input1\r1 2 3 2 3 2 7 5 Sample Output1\r1 3 Possible $x$ values: $3$, $4$, $5$.\nSample Input2\r1 2 3 3 1 5 3 10 7 3 Sample Output2\r1 0 No valid $x$ exists.\nSample Input3\r1 2 3 3 3 2 5 6 9 8 Sample Output3\r1 2 Analysis\rThe constraints can be decomposed into:\nFor all $1 \\le i \\le N$, $A_i \\le x$. For all $1 \\le i \\le N$, $x \\le B_i$. This simplifies to $\\max(A) \\le x \\le \\min(B)$. The valid count is $\\max(0, \\min(B) - \\max(A) + 1)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n, maxa = 1, minb = 1000; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); if(a \u0026gt; maxa) maxa = a; } while(n--) { int b; scanf(\u0026#34;%d\u0026#34;, \u0026amp;b); if(b \u0026lt; minb) minb = b; } if(maxa \u0026gt; minb) puts(\u0026#34;0\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, minb - maxa + 1); return 0; } C - IPFL\rProblem Statement\rGiven a string $S$ of length $2N$ consisting of uppercase letters. Process $Q$ queries. Each query consists of three integers $T_i, A_i, B_i$:\nIf $T_i = 1$: swap the $A_i$-th and $B_i$-th characters of $S$. If $T_i = 2$: swap the first $N$ and last $N$ characters of $S$. Output $S$ after all queries.\n$1 \\le N \\le 2 \\times 10^5$\n$|S| = 2N$\n$1 \\le Q \\le 3 \\times 10^5$\n$1 \\le T_i \\le 2$, $1 \\le A_i \u003c B_i \\le 2N$ if $T_i = 1$; $A_i = B_i = 0$ if $T_i = 2$.\nInput Format\r$N$\n$S$\n$Q$\n$T_1~A_1~B_1$\n$T_2~A_2~B_2$\n$\\hspace{18pt}\\vdots$\n$T_Q~A_Q~B_Q$\nSamples\rSample Input1\r1 2 3 4 5 2 FLIP 2 2 0 0 1 1 4 Sample Output1\r1 LPFI $\\text{FLIP} \\to \\text{IPFL} \\to \\text{LPFI}$\nSample Input2\r1 2 3 4 5 6 7 8 9 2 FLIP 6 1 1 3 2 0 0 1 1 2 1 2 3 2 0 0 1 1 4 Sample Output2\r1 ILPF Analysis\rThe $\\mathcal O(NQ)$ simulation approach would TLE. Optimize by tracking flip state:\nMaintain flipped flag. For $T_i = 2$, toggle flipped. For $T_i = 1$, adjust indices based on flipped status to compute actual positions. Time complexity: $\\mathcal O(N + Q)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;cstdio\u0026gt; #define maxn 400005 using namespace std; char s[maxn]; int n; inline void swap(char\u0026amp; x, char\u0026amp; y) { x ^= y ^= x ^= y; } inline char\u0026amp; calc(int pos) { return s[pos \u0026lt; n? pos + n: pos - n]; } int main() { scanf(\u0026#34;%d%s\u0026#34;, \u0026amp;n, s); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); bool flipped = false; while(q--) { int t, a, b; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;t, \u0026amp;a, \u0026amp;b); a --, b --; if(t == 2) flipped = !flipped; else if(flipped) swap(calc(a), calc(b)); else swap(s[a], s[b]); } if(flipped) for(int i=0; i\u0026lt;n; i++) swap(s[i], s[n + i]); puts(s); return 0; } D - RGB Coloring 2\rProblem Statement\rGiven a simple undirected graph with $N$ vertices and $M$ edges. Count valid colorings using three colors where adjacent vertices have different colors.\n$1 \\le N \\le 20$\n$0 \\le M \\le \\frac{N(N-1)}{2}$\nInput Format\r$N~M$\n$A_1~B_1$\n$A_2~B_2$\n$\\hspace{12pt}\\vdots$\n$A_M~B_M$\nOutput Format\rPrint the answer.\nSamples\rSample Input1\r1 2 3 4 3 3 1 2 2 3 3 1 Sample Output1\r1 6 Valid colorings: RGB, RBG, GRB, GBR, BRG, BGR.\nSample Input2\r1 3 0 Sample Output2\r1 27 Sample Input3\r1 2 3 4 5 6 7 4 6 1 2 2 3 3 4 2 4 1 3 1 4 Sample Output3\r1 0 Sample Input4\r1 20 0 Sample Output4\r1 3486784401 Analysis\rFor each connected component, count valid colorings via DFS. Multiply results across components. Total attempts are bounded by $3 \\times 2^{N-1}$.\nCode\rSeems no one noticed that unsigned int could be used\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 25 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; int col[maxn], dep[maxn]; inline int next(int c) { return (c + 1) % 3; } int paint(int v) { for(int u: G[v]) if(col[v] == col[u]) return 0; int ans = 1; for(int u: G[v]) { if(dep[u] == -1) dep[u] = dep[v] + 1; if(dep[u] == dep[v] + 1) { col[u] = next(col[v]); int res = paint(u); col[u] = next(col[u]); res += paint(u); col[u] = -1; if(res == 0) return 0; ans *= res; } } return ans; } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G[--x].push_back(--y); G[y].push_back(x); } for(int i=0; i\u0026lt;n; i++) col[i] = dep[i] = -1; unsigned int ans = 1; for(int i=0; i\u0026lt;n; i++) if(dep[i] == -1) { col[i] = dep[i] = 0; ans *= 3U * paint(i); } printf(\u0026#34;%u\\n\u0026#34;, ans); return 0; } E - Permutation\rProblem Statement\rCount permutations of $(1, 2, \\dots, N)$ satisfying:\nFor each $1 \\le i \\le M$, among the first $X_i$ elements, at most $Z_i$ are $\\le Y_i$. $2 \\le N \\le 18$\n$0 \\le M \\le 100$\n$1 \\le X_i, Y_i \u003c N$\n$0 \\le Z_i \u003c N$\nInput Format\r$N~M$\n$X_1~Y_1~Z_1$\n$X_2~Y_2~Z_2$\n$\\hspace{18pt}\\vdots$\n$X_M~Y_M~Z_M$\nOutput Format\rPrint the count.\nSamples\rSample Input1\r1 2 3 1 2 2 1 Sample Output1\r1 4 Valid permutations: $(1,2,3)$, $(2,3,1)$, $(3,1,2)$, $(3,2,1)$.\nSample Input2\r1 2 3 5 2 3 3 2 4 4 3 Sample Output2\r1 90 Sample Input3\r1 18 0 Sample Output3\r1 6402373705728000 Analysis\rUse bitmask DP. Let dp[mask] represent the number of valid ways to select the subset mask. For each bit added, check constraints. Time complexity: $\\mathcal O(2^N \\cdot (N + M))$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 20 using namespace std; using LL = long long; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; lim[maxn]; LL dp[1 \u0026lt;\u0026lt; maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int x, y, z; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); if(z \u0026lt; y) lim[x].emplace_back(y, z); } int mx = 1 \u0026lt;\u0026lt; n; dp[0] = 1LL; for(int st=0; st\u0026lt;mx; st++) { vector\u0026lt;int\u0026gt; s; for(int i=0; i\u0026lt;n; i++) if(st \u0026gt;\u0026gt; i \u0026amp; 1) s.push_back(i); int cnt = __builtin_popcount(st); bool ok = true; for(auto [y, z]: lim[cnt]) { int tot = 0; for(auto x: s) if(x \u0026lt; y \u0026amp;\u0026amp; ++tot \u0026gt; z) { ok = false; break; } if(!ok) break; } if(ok) for(int x: s) dp[st] += dp[st ^ (1 \u0026lt;\u0026lt; x)]; } printf(\u0026#34;%lld\\n\u0026#34;, dp[mx - 1]); return 0; } ","date":"2021-06-13T11:31:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc199/","title":"AtCoder Beginner Contest 199 (Sponsored by Panasonic) A~E Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Century\rProblem Statement\rIn which century does the year $N$ fall?\nA century consists of 100 consecutive years. For example, the 1st century is years [1,100], the 2nd century is years [101,200], etc.\n$1\\le N\\le 3000$\nInput Format\r$N$\nOutput Format\rPrint the answer as an integer.\nSample Cases\r$N$ Output $2021$ $21$ $200$ $2$ Analysis\rWe can derive that year $N$ belongs to the $\\lceil \\frac N {100}\\rceil$ century.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;%d\\n\u0026#34;, n % 100 == 0? n / 100: n / 100 + 1); return 0; } B - 200th ABC-200\rProblem Statement\rPerform the following operations $K$ times on integer $N$:\nIf $N$ is a multiple of 200, divide it by 200. Otherwise, append 200 to $N$ (e.g., 123 becomes 123200). $1\\le N\\le 10^5$\n$1\\le K\\le 20$\nInput Format\r$N~K$\nOutput Format\rPrint the final $N$.\nSample Cases\r$N$ $K$ Output $2021$ $4$ $50531$ $40000$ $2$ $1$ $8691$ $20$ $84875488281$ Analysis\rWe simulate the process while proving the result fits in long long:\nAppending 200 to any $N$ makes it divisible by 200 (ends with two zeros). After appending, dividing by 200 reduces digit count. Thus, $N$ remains strictly below $2^{63}$. Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { long long n; int k; scanf(\u0026#34;%lld%d\u0026#34;, \u0026amp;n, \u0026amp;k); while(k--) n = n % 200LL == 0LL? n / 200LL: n * 1000LL + 200LL; printf(\u0026#34;%lld\\n\u0026#34;, n); return 0; } C - Ringo\u0026rsquo;s Favorite Numbers 2\rProblem Statement\rGiven sequence $A=(A_1,A_2,\\dots,A_N)$, find all pairs $(i,j)$ satisfying:\n$1\\le i \u003c j\\le N$ $|A_i-A_j|$ is a multiple of 200. $2\\le N\\le 2\\times 10^5$\n$1\\le A_i\\le 10^9$\nOutput Format\r$N$\n$A_1~A_2~\\dots~A_N$\nSample Cases\r$A$ Output $(123,223,123,523,200,2000)$ $4$ $(1,2,3,4,5)$ $0$ $(199,100,200,400,300,500,600,200)$ $9$ Analysis\rWe use modulo 200 buckets to count pairs in $\\mathcal O(n)$ time:\nElements in the same remainder bucket form valid pairs. For each element, add current bucket count to the answer before updating the bucket. Note: The answer must be of type long long!\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define MOD 200 using namespace std; int cnt[MOD]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); long long ans = 0LL; while(n--) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); ans += cnt[x %= MOD] ++; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } D - Happy Birthday! 2\rProblem Statement\rGiven sequence $A=(A_1,A_2,\\dots,A_N)$, find two distinct subsequences $B$ and $C$ (different indices, not necessarily contiguous) such that $\\sum B\\equiv \\sum C\\pmod{200}$.\n$2\\le N\\le 200$\n$1\\le A_i\\le 10^9$\nInput Format\r$N$\n$A_1~A_2~\\dots~A_N$\nOutput\rIf no solution exists, print No.\nOtherwise, output:\n$\\text{Yes}$\n$x~B'_1~B'_2~\\dots~B'_x$\n$y~C'_1~C'_2~\\dots~C'_y$\nSample Cases\rSee AtCoder for details.\nAnalysis\rWhen $N\\ge 8$, pigeonhole principle guarantees a solution (255 subsets mod 200). For $N\u003c8$, brute-force all subsets.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 10 #define MOD 200 using namespace std; int a[maxn]; vector\u0026lt;int\u0026gt; bkt[MOD]; inline void print(const vector\u0026lt;int\u0026gt;\u0026amp; v) { printf(\u0026#34;%llu\u0026#34;, v.size()); for(int x: v) printf(\u0026#34; %d\u0026#34;, x + 1); putchar(\u0026#39;\\n\u0026#39;); } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if(n \u0026gt; 8) n = 8; for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); int lim = 1 \u0026lt;\u0026lt; n; for(int st=0; st\u0026lt;lim; st++) { int s = 0; vector\u0026lt;int\u0026gt; pos; for(int i=0; i\u0026lt;n; i++) if(st \u0026gt;\u0026gt; i \u0026amp; 1) s = (s + a[i]) % MOD, pos.push_back(i); if(!bkt[s].empty()) { puts(\u0026#34;Yes\u0026#34;); print(bkt[s]); print(pos); return 0; } else bkt[s] = pos; } puts(\u0026#34;No\u0026#34;); return 0; } E - Patisserie ABC 2\rProblem Statement\rThere are $N^3$ triples $(i,j,k)$ ($1\\le i,j,k\\le N$), ordered by:\nAscending $i+j+k$ For equal sums, ascending $i$, then $j$ Find the $K$-th triple.\n$1\\le N\\le 10^6$\n$1\\le K\\le N^3$\nInput Format\r$N~K$\nOutput Format\rPrint the $K$-th triple separated by spaces.\nSample Cases\r$N$ $K$ Output $2$ $5$ $1 2 2$ $1000000$ $1000000000000000000$ $1000000 1000000 1000000$ $9$ $47$ $3 1 4$ Analysis\rIterate possible sums $s$ and compute valid triples count using inclusion-exclusion:\nNumber of solutions to $i+j+k=s$ in $[1,N]$ is $f(s) - 3f(s-N) + 3f(s-2N)$ where $f(n) = \\binom{n-1}{2}$ for $n\\ge3$. Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstdio\u0026gt; using namespace std; using LL = long long; int n; inline int max(int x, int y) { return x \u0026gt; y? x: y; } inline int min(int x, int y) { return x \u0026lt; y? x: y; } inline LL f(LL n) { return n-- \u0026gt; 2? n * (n - 1LL) \u0026gt;\u0026gt; 1LL: 0LL; } inline LL count(int s) { return f(s) - 3 * (f(s - n) - f(s - (n \u0026lt;\u0026lt; 1))); } int main() { LL k; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;k); int lim = n * 3; for(int sum=3; sum\u0026lt;=lim; sum++) { LL cnt = count(sum); if(k \u0026gt; cnt) { k -= cnt; continue; } for(int a=1; a\u0026lt;=n; a++) { int minb = max(1, sum - a - n), maxb = min(n, sum - a - 1); if(minb \u0026gt; maxb) continue; int num = maxb - minb + 1; if(k \u0026lt;= num) { int b = minb + k - 1; int c = sum - a - b; printf(\u0026#34;%d %d %d\\n\u0026#34;, a, b, c); return 0; } k -= num; } } return 0; } ","date":"2021-06-10T22:16:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc200/","title":"KYOCERA Programming Contest 2021 (AtCoder Beginner Contest 200) A~E Problem Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Rock-paper-scissors\rThree people play rock-paper-scissors to a draw. Two of them chose $x$ and $y$ respectively. Determine the third person\u0026rsquo;s choice.\n$0\\le x,y\\le 2$ (0=Rock, 1=Scissors, 2=Paper)\nInput Format\r$x,y$\nOutput Format\rOutput the integer representing the third person\u0026rsquo;s choice.\nSamples\r$x$ $y$ Output $0$ $1$ $2$ $0$ $0$ $0$ Analysis\rA three-way draw occurs in two cases (let $z$ be the third person\u0026rsquo;s choice):\n$x=y=z$ All three choices are distinct The formula can be derived as:\n$z=\\begin{cases}x \u0026 (x=y)\\\\3-x-y \u0026 (x\\ne y)\\end{cases}$\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); printf(\u0026#34;%d\\n\u0026#34;, x == y? x: 3 - x - y); return 0; } B - Nuts\rThere are $N$ trees. The $i$-th tree has $A_i$ nuts. A person collects $\\max(0,A_i-10)$ nuts from each tree. Calculate the total collected nuts.\n$1\\le N,A_i\\le 1000$\nInput Format\r$N$\n$A_1~\\dots~A_N$\nOutput Format\rOutput the total.\nSamples\rSample Input 1\r1 2 3 6 17 28 Sample Output 1\r1 25 Collected nuts: $0+7+18=25$\nSample Input 2\r1 2 4 8 9 10 11 Sample Output 2\r1 1 Only the last tree contributes 1 nut.\nAnalysis\rSimulate according to the problem statement.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n, ans = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while(n--) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); if(a \u0026gt; 10) ans += a - 10; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } C - Tour\rA country has $N$ cities and $M$ one-way roads. Count the number of valid ordered pairs $(X,Y)$ where one can travel from city $X$ to city $Y$ through any number of roads (including staying at the same city).\n$2\\le N\\le 2000$\n$0\\le M\\le \\min(2000,N(N-1))$\nAll roads are distinct and not self-looping.\nInput Format\r$N~M$\n$A_1~B_1$\n$\\vdots$\n$A_M~B_M$\nOutput Format\rOutput the count.\nSamples\rSample Input 1\r1 2 3 4 3 3 1 2 2 3 3 2 Sample Output 1\r1 7 Valid pairs: (1,1), (1,2), (1,3), (2,2), (2,3), (3,2), (3,3)\nSample Input 2\r1 3 0 Sample Output 2\r1 3 Only self-pairs are valid.\nAnalysis\rModel the country as a directed unweighted graph. Perform DFS from each node to count reachable nodes. Time complexity: $\\mathcal O(n^2)$.\nCode\rNote: Reset the vis array before each DFS!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 2005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; bool vis[maxn]; int ans; void dfs(int v) { if(vis[v]) return; vis[v] = true, ans ++; for(int u: G[v]) dfs(u); } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G[--x].push_back(--y); } ans = 0; for(int i=0; i\u0026lt;n; i++) { for(int j=0; j\u0026lt;n; j++) vis[j] = false; dfs(i); } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Cooking\rTwo people wash $N$ dishes. Dish $i$ takes $T_i$ minutes. Calculate the minimum time to wash all dishes when working in parallel.\n$1\\le N\\le 100$\n$1\\le T_i\\le 10^3$\nInput Format\r$N$\n$T_1~T_2~\\dots~T_N$\nOutput Format\rOutput the minimal total time.\nSamples\rSample Input 1\r1 2 5 8 3 7 2 5 Sample Output 1\r1 13 Optimal split: 13 (8+5) vs 10 (3+7+2)\nSample Input 2\r1 2 2 1000 1 Sample Output 2\r1 1000 Sample Input 3\r1 2 9 3 14 15 9 26 5 35 89 79 Sample Output 3\r1 138 Analysis\rClassic 0-1 knapsack problem. Find the maximum subset sum not exceeding half of total time. Answer is total minus this subset sum.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #define maxn 105 #define maxv 100005 using namespace std; int dp[maxv], w[maxn]; inline void setmax(int\u0026amp; x, int y) { if(y \u0026gt; x) x = y; } int main() { int n, v = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d\u0026#34;, w + i); v += w[i]; } int t = v; v \u0026gt;\u0026gt;= 1; for(int i=0; i\u0026lt;n; i++) for(int j=v; j\u0026gt;=w[i]; j--) setmax(dp[j], dp[j - w[i]] + w[i]); printf(\u0026#34;%d\\n\u0026#34;, t - dp[v]); return 0; } E - Rush Hour 2\rA country has $N$ cities and $M$ bidirectional roads. The travel time through road $i$ at time $t$ is $C_i+\\lfloor\\frac{D_i}{t+1}\\rfloor$. Find the earliest time to reach city $N$ from city $1$, or output -1.\n$2\\le N\\le 10^5$\n$2\\le M\\le 10^5$\n$0\\le C_i,D_i\\le 10^9$\nInput Format\r$N~M$\n$A_1~B_1~C_1~D_1$\n$\\vdots$\n$A_M~B_M~C_M~D_M$\nOutput Format\rOutput the minimal time or -1.\nSamples\rSample Input 1\r1 2 2 1 1 2 2 3 Sample Output 1\r1 4 Depart at t=1: 1+2+‚åä3/2‚åã=4\nSample Input 2\r1 2 3 4 2 3 1 2 2 3 1 2 2 1 1 1 1 1 Sample Output 2\r1 3 Multiple roads and self-loops allowed.\nSample Input 3\r1 2 3 4 2 1 2 3 4 3 4 5 6 Sample Output 3\r1 -1 No valid path exists.\nAnalysis\rModel as graph and use Dijkstra\u0026rsquo;s algorithm. For each edge, optimal departure time is around $\\lfloor\\sqrt{D}\\rfloor-1$. Time complexity: $\\mathcal O(M\\log N)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;tuple\u0026gt; #define maxn 100005 #define INF 9223372036854775807LL using namespace std; using Road = tuple\u0026lt;int, int, int\u0026gt;; using LL = long long; using pli = pair\u0026lt;LL, int\u0026gt;; vector\u0026lt;Road\u0026gt; G[maxn]; LL dist[maxn]; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); while(m--) { int a, b, c, d; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); if(--a == --b) continue; G[a].emplace_back(b, c, d); G[b].emplace_back(a, c, d); } dist[0] = 0LL; for(int i=1; i\u0026lt;n; i++) dist[i] = INF; priority_queue\u0026lt;pli, vector\u0026lt;pli\u0026gt;, greater\u0026lt;pli\u0026gt;\u0026gt; q; q.emplace(0LL, 0); while(!q.empty()) { auto [t, u] = q.top(); q.pop(); if(dist[u] != t) continue; for(auto [v, c, d]: G[u]) { LL t2 = sqrt((long double) d) - 0.5; if(t2 \u0026lt; t) t2 = t; t2 += LL(c) + LL(d) / (t2 + 1LL); if(t2 \u0026lt; dist[v]) q.emplace(dist[v] = t2, v); } } if(dist[n - 1] == INF) puts(\u0026#34;-1\u0026#34;); else printf(\u0026#34;%lld\\n\u0026#34;, dist[n - 1]); return 0; } ","date":"2021-06-07T19:02:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc204/","title":"AtCoder Beginner Contest 204 A~E Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Three Dice\rA person rolled three dice with top faces showing $a$, $b$, and $c$. Find the sum of their bottom faces.\nThe dice used are standard, meaning the sum of opposite faces is $7$.\n$1\\le a,b,c\\le 6$\nInput Format\r$a~b~c$\nOutput Format\rPrint the answer.\nSamples\r$a$ $b$ $c$ Answer $1$ $4$ $3$ $13$ $5$ $6$ $4$ $6$ Analysis\rSince opposite faces sum to $7$, the answer is $(7-a)+(7-b)+(7-c)=21-a-b-c$.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); printf(\u0026#34;%d\\n\u0026#34;, 21 - a - b - c); return 0; } B - 180¬∞\rGiven a string $S$ consisting of 0, 1, 6, 8, 9. Rotate it 180¬∞ and output the result.\nHow to rotate a string 180¬∞:\nReverse the string. Replace 6 with 9 and 9 with 6. $1\\le |S|\\le10^5$\nInput Format\r$S$\nOutput Format\rPrint the rotated string.\nSamples\r$S$ Output 0601889 6881090 86910 01698 01010 01010 Analysis\rDirectly simulate the rotation process.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 using namespace std; char s[maxn]; int main() { int n = 0; char c; while((c = getchar()) != \u0026#39;\\n\u0026#39;) s[n++] = c; while(n--) putchar(s[n] == \u0026#39;6\u0026#39;? \u0026#39;9\u0026#39;: s[n] == \u0026#39;9\u0026#39;? \u0026#39;6\u0026#39;: s[n]); putchar(\u0026#39;\\n\u0026#39;); return 0; } C - Made Up\rGiven three sequences $A$, $B$, $C$ of length $N$. Count the number of pairs $(i,j)$ satisfying $A_i=B_{C_j}$.\n$1\\le N\\le 10^5$\n$1\\le A_i,B_i,C_i\\le N$\nInput Format\r$N$\n$A_1~A_2~\\dots~A_N$\n$B_1~B_2~\\dots~B_N$\n$C_1~C_2~\\dots~C_N$\nOutput Format\rPrint the count.\nSamples\rSample Input 1\r1 2 3 4 3 1 2 2 3 1 2 2 3 2 Sample Output 1\r1 4 Valid pairs: $(1,1),(1,3),(2,2),(3,2)$.\nSample Input 2\r1 2 3 4 4 1 1 1 1 1 1 1 1 1 2 3 4 Sample Output 2\r1 16 All pairs are valid.\nSample Input 3\r1 2 3 4 3 2 3 3 1 3 3 1 1 1 Sample Output 3\r1 0 No valid pairs.\nAnalysis\rAn $O(n^2)$ brute-force approach would TLE. Instead, count frequencies using bucket arrays $\\mathrm{acnt}$ and $\\mathrm{bcnt}$, then compute the sum $\\sum_{i=1}^n\\mathrm{acnt}_i\\mathrm{bcnt}_i$.\nCode\rNote: Use long long to avoid overflow!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 using namespace std; using LL = long long; int acnt[maxn], b[maxn], bcnt[maxn]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); acnt[a] ++; } for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, b + i); for(int i=0; i\u0026lt;n; i++) { int c; scanf(\u0026#34;%d\u0026#34;, \u0026amp;c); bcnt[b[--c]] ++; } LL ans = 0LL; for(int i=1; i\u0026lt;=n; i++) ans += LL(acnt[i]) * LL(bcnt[i]); printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } D - aab aba baa\rFind the $K$-th lexicographically smallest string consisting of $A$ as and $B b`s.\n$1\\le A,B\\le30$\n$1\\le K\\le S$ ($S$ is the total number of valid strings)\nInput Format\r$A~B~K$\nOutput Format\rPrint the required string.\nSamples\r$A$ $B$ $K$ Output $2$ $2$ $4$ baab $30$ $30$ $118264581564861424$ (30 bs + 30 as) Analysis\rLet $\\mathrm{dp}(a,b)$ be the count of strings with $a$ as and $b` `b`s. The recursive formula is: $\\mathrm{dp}(a,b)=\\mathrm{dp}(a-1,b)+\\mathrm{dp}(a,b-1)$. Construct the string greedily by comparing $K$ with $\\mathrm{dp}(a-1,b)$ at each step.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; #define maxn 35 using namespace std; using LL = long long; LL dp[maxn][maxn]; int main() { int a, b; LL k; scanf(\u0026#34;%d%d%lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;k); for(int i=0; i\u0026lt;=a; i++) dp[i][0] = 1; for(int i=0; i\u0026lt;=b; i++) dp[0][i] = 1; for(int i=1; i\u0026lt;=a; i++) for(int j=1; j\u0026lt;=b; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; while(a \u0026amp;\u0026amp; b) { LL t = dp[a - 1][b]; if(k \u0026lt;= t) putchar(\u0026#39;a\u0026#39;), a --; else putchar(\u0026#39;b\u0026#39;), b --, k -= t; } while(a--) putchar(\u0026#39;a\u0026#39;); while(b--) putchar(\u0026#39;b\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); return 0; } E - Count Descendants\rGiven an $N$-node tree rooted at node 1. The parent of node $i$ ($2\\le i\\le N$) is $P_i$. Answer $Q$ queries: count nodes $u$ where:\nThe path from $u$ to root has exactly $D_i$ edges. $U_i$ lies on this path (including endpoints). $1\\le N\\le 2\\times10^5$\n$1\\le P_i ","date":"2021-06-06T11:28:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc202/","title":"AISing Programming Contest 2021 (AtCoder Beginner Contest 202) A~E Problem Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Chinchirorin\rProblem Statement\rGiven three integers $a,b,c$, if two of them are equal, output the third one; otherwise, output $0$.\n$1\\le a,b,c\\le 6$\nInput Format\r$a~b~c$\nOutput Format\rOutput the third value if two of $a,b,c$ are equal; otherwise, output $0$.\nSamples\r$a$ $b$ $c$ Output $2$ $5$ $2$ $5$ $4$ $5$ $6$ $0$ $1$ $1$ $1$ $1$ Analysis\rProblem A remains straightforward. Directly check the three possible equality cases.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); if(a == b) printf(\u0026#34;%d\\n\u0026#34;, c); else if(b == c) printf(\u0026#34;%d\\n\u0026#34;, a); else if(a == c) printf(\u0026#34;%d\\n\u0026#34;, b); else puts(\u0026#34;0\u0026#34;); return 0; } B - AtCoder Condominium\rProblem Statement\rGiven $N$ and $K$, compute $\\sum\\limits_{i=1}^N\\sum\\limits_{j=1}^K \\overline{i0j}$.\n$1\\le N,K\\le 9$\nInput Format\r$N~K$\nOutput Format\rOutput $\\sum\\limits_{i=1}^N\\sum\\limits_{j=1}^K \\overline{i0j}$.\nSamples\r$N$ $K$ Output $1$ $2$ $203$ $3$ $3$ $1818$ Analysis\rBrute-force works, but here\u0026rsquo;s an $\\mathcal O(1)$ approach:\nSince $\\overline{i0j}=100i+j$ and $1+2+\\dots+N=\\frac{N(N+1)}2$, we derive:\n$\\sum\\limits_{i=1}^N\\sum\\limits_{j=1}^K \\overline{i0j}=\\frac{100N(N+1)K+K(K+1)N}2$ Code\r1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;cstdio\u0026gt; using namespace std; inline int sum(int x) { return x * (x + 1) \u0026gt;\u0026gt; 1; } int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); printf(\u0026#34;%d\\n\u0026#34;, sum(n) * k * 100 + sum(k) * n); return 0; } C - Friends and Travel costs\rProblem Statement\rThere are $10^{100}+1$ villages numbered $0,1,\\dots,10^{100}$. Moving between adjacent villages costs $1$ yen.\nTaro starts at village $0$ with $K$ yen and wants to reach the highest possible village.\nHe has $N$ friends. The $i$-th friend gives $B_i$ yen when Taro reaches village $A_i$.\nFind the highest village Taro can reach.\n$1\\le N\\le 2\\times10^5$\n$1\\le K\\le 10^9$\n$1\\le A_i\\le 10^{18}$\n$1\\le B_i\\le 10^9$\nInput Format\r$N~K$\n$A_1~B_1$\n$A_2~B_2$\n$\\dots$\n$A_N~B_N$\nOutput\rOutput the highest village number Taro can reach.\nSamples\rSample Input 1\r1 2 3 2 3 2 1 5 10 Sample Output 1\r1 4 Sample Input 2\r1 2 3 4 5 6 5 1000000000 1 1000000000 2 1000000000 3 1000000000 4 1000000000 5 1000000000 Sample Output 2\r1 6000000000 Use 64-bit integers.\nSample Input 3\r1 2 3 4 3 2 5 5 2 1 2 2 Sample Output 3\r1 10 A village may contain multiple friends.\nAnalysis\rSort friends by $A_i$. Process intervals between friends, checking if Taro can reach each $A_i$ with remaining funds.\nCode\rNote: Sorting uses a priority queue.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #define maxn 200005 #define INF 18446744073709551615ULL using namespace std; using ULL = unsigned long long; using pll = pair\u0026lt;ULL, ULL\u0026gt;; int main() { int n; ULL k; scanf(\u0026#34;%d%llu\u0026#34;, \u0026amp;n, \u0026amp;k); priority_queue\u0026lt;pll, vector\u0026lt;pll\u0026gt;, greater\u0026lt;pll\u0026gt; \u0026gt; q; for(int i=0; i\u0026lt;n; i++) { ULL a, b; scanf(\u0026#34;%llu%llu\u0026#34;, \u0026amp;a, \u0026amp;b); q.emplace(a, b); } ULL lastv = 0ULL; q.emplace(INF, 0ULL); while(!q.empty()) { auto [a, b] = q.top(); q.pop(); ULL cost = a - lastv; if(k \u0026lt; cost) { printf(\u0026#34;%llu\\n\u0026#34;, lastv + k); return 0; } k -= cost; lastv = a, k += b; } return 0; } D - Pond\rProblem Statement\rGiven an $N\\times N$ matrix $A$, find the minimum median among all $K\\times K$ submatrices. The median is the $(\\left\\lfloor\\frac{K^2}2\\right\\rfloor+1)$-th largest value.\n$1\\le K\\le N\\le 800$\n$1\\le A_{i,j}\\le 10^9$\nExample illustration:\nInput Format\r$N~K$\n$A_{1,1}~A_{1,2}~\\dots~A_{1,N}$\n$\\vdots$\n$A_{N,1}~A_{N,2}~\\dots~A_{N,N}$\nOutput Format\rOutput the answer.\nSamples\rSample Input 1\r1 2 3 4 3 2 1 7 0 5 8 11 10 4 2 Sample Output 1\r1 4 Sample Input 2\r1 2 3 4 3 3 1 2 3 4 5 6 7 8 9 Sample Output 2\r1 5 Analysis\rBinary search the answer. For each candidate value, use matrix prefix sums to count elements exceeding it in each submatrix. Time complexity $\\mathcal O(n^2\\log\\max\\{A\\})$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;cstdio\u0026gt; #define maxn 805 #define INF 2147483647 using namespace std; int a[maxn][maxn], dp[maxn][maxn], n, k, target; inline int count(int x1, int y1, int x2, int y2) { return dp[x2][y2] - dp[x1 - 1][y2] - dp[x2][y1 - 1] + dp[x1 - 1][y1 - 1]; } inline bool check(int x) { for(int i=1; i\u0026lt;=n; i++) for(int j=1; j\u0026lt;=n; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + (a[i][j] \u0026gt; x); for(int x2=k; x2\u0026lt;=n; x2++) for(int y2=k; y2\u0026lt;=n; y2++) { int x1 = x2 - k + 1, y1 = y2 - k + 1; if(count(x1, y1, x2, y2) \u0026lt; target) return true; } return false; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); target = (k * k \u0026gt;\u0026gt; 1) + 1; int l = INF, r = 0, ans = 0; for(int i=1; i\u0026lt;=n; i++) for(int j=1; j\u0026lt;=n; j++) { scanf(\u0026#34;%d\u0026#34;, a[i] + j); if(a[i][j] \u0026gt; r) r = a[i][j]; if(a[i][j] \u0026lt; l) l = a[i][j]; } while(l \u0026lt;= r) { int mid = l + r \u0026gt;\u0026gt; 1; if(check(mid)) ans = mid, r = mid - 1; else l = mid + 1; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } E - White Pawn\rProblem Statement\rOn a $(2N+1)\\times(2N+1)$ chessboard, a white pawn starts at $(0,N)$. $M$ black squares exist at $(X_i,Y_i)$. The pawn moves:\nDown to white $(i+1,j)$, Diagonally down-left to black $(i+1,j-1)$, Diagonally down-right to black $(i+1,j+1)$. Find how many columns in the last row are reachable.\n$1\\le N\\le 10^9$\n$0\\le M\\le 2\\times 10^5$\nInput Format\r$N~M$\n$X_1~Y_1$\n$\\vdots$\n$X_M~Y_M$\nOutput Format\rOutput the count.\nSamples\rSample Input 1\r1 2 3 4 5 2 4 1 1 1 2 2 0 4 2 Sample Output 1\r1 3 Sample Input 2\r1 2 1 1 1 1 Sample Output 2\r1 0 Analysis\rProcess black squares row-wise. Maintain reachable columns using a set. For each black row, update reachable positions based on adjacent cells.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) using namespace std; int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; black; black.reserve(m); while(m--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); black.emplace_back(x, y); } m = black.size(); sort(black.begin(), black.end()); set\u0026lt;int\u0026gt; cols; cols.insert(n); for(int l=0, r=0; l\u0026lt;m; l=r) { while(r \u0026lt; m \u0026amp;\u0026amp; black[r].first == black[l].first) r ++; vector\u0026lt;int\u0026gt; rem, add; for(int i=l; i\u0026lt;r; i++) { int y = black[i].second; bool ok = cols.count(y - 1) || cols.count(y + 1); if(cols.count(y)) { if(!ok) rem.push_back(y); } else if(ok) add.push_back(y); } for(int y: rem) cols.erase(y); for(int y: add) cols.insert(y); } printf(\u0026#34;%llu\\n\u0026#34;, cols.size()); return 0; } ","date":"2021-06-03T21:11:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc203/","title":"AtCoder Beginner Contest 203 (Sponsored by Panasonic) A~E Problem Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Tiny Arithmetic Sequence\rProblem Statement\rGiven a sequence $A=(A_1,A_2,A_3)$, can it be rearranged such that $A_3-A_2=A_2-A_1$?\n$1\\le A_i\\le 100$\nInput Format\r$A_1~A_2~A_3$\nOutput Format\rPrint Yes if possible; otherwise, print No.\nSample Cases\r$A$ Output $(5,1,3)$ Yes $(1,4,3)$ No $(5,5,5)$ Yes Analysis\rIt\u0026rsquo;s easy to observe that if $A_3-A_2=A_2-A_1$ holds, then $A_1\\le A_2\\le A_3$ or $A_3\\le A_2\\le A_1$ must be true. Thus, we can sort $A$ in ascending order and check if the condition holds.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int a[3]; scanf(\u0026#34;%d%d%d\u0026#34;, a, a + 1, a + 2); sort(a, a + 3); puts(a[2] - a[1] == a[1] - a[0]? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Do you know the second highest mountain?\rProblem Statement\rThere are $N$ mountains. The $i$-th mountain has a name $S_i$ and height $T_i$. Output the name of the second highest mountain.\n$2\\le N\\le 1000$\n$1\\le |S_i|\\le 15$\n$1\\le T_i\\le 10^5$\n$S_i\\ne S_j~(i\\ne j)$\n$T_i\\ne T_j~(i\\ne j)$\n$S_i$ consists of uppercase/lowercase letters and digits.\nInput Format\r$N$\n$S_1~T_1$\n$S_2~T_2$\n$\\vdots$\n$S_N~T_N$\nOutput Format\rPrint the name of the second highest mountain.\nSample Cases\rSample Input 1\r1 2 3 4 3 Everest 8849 K2 8611 Kangchenjunga 8586 Sample Output 1\r1 K2 The second highest mountain is K2.\nSample Input 2\r1 2 3 4 5 4 Kita 3193 Aino 3189 Fuji 3776 Okuhotaka 3190 Sample Output 2\r1 Kita The second highest mountain is Kita.\nSample Input 3\r1 2 3 4 5 4 QCFium 2846 chokudai 2992 kyoprofriends 2432 penguinman 2390 Sample Output 3\r1 QCFium The second highest mountain is QCFium.\nAnalysis\rThis problem requires finding the $S_i$ corresponding to the second largest element in $T$. We can use a priority queue to maintain the top two elements efficiently.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; using pis = pair\u0026lt;int, string\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin \u0026gt;\u0026gt; n; priority_queue\u0026lt;pis, vector\u0026lt;pis\u0026gt;, greater\u0026lt;pis\u0026gt; \u0026gt; q; while(n--) { string s; int h; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; h; q.emplace(h, s); if(q.size() \u0026gt; 2) q.pop(); } cout \u0026lt;\u0026lt; q.top().second \u0026lt;\u0026lt; endl; return 0; } C - Secret Number\rProblem Statement\rA 4-digit PIN consists of digits 0-9 (may start with 0). A string $S_0S_1\\dots S_9$ determines the presence of each digit:\nIf $S_i=$ o, the PIN must contain digit $i$; If $S_i=$ x, the PIN must not contain digit $i$; If $S_i=$ ?, the PIN may or may not contain digit $i$. Count the number of valid PINs.\n$S$ is a 10-character string of o, x, or ?.\nInput Format\r$S$\nOutput Format\rPrint the total count as an integer.\nSample Cases\r$S$ Answer ooo???xxxx $108$ o?oo?oxoxo $0$ xxxxx?xxxo $15$ Edge Case: $S=$ ??????????, Answer: $10000$ Analysis\rSince there are only 10000 possible PINs, we can brute-force all combinations. For each candidate PIN, check compliance with $S$ in $\\mathcal O(|S|)$ time.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;cstdio\u0026gt; using namespace std; char s[15]; inline bool valid(int a, int b, int c, int d) { bool used[10] = {false}; used[a] = used[b] = used[c] = used[d] = true; for(int i=0; i\u0026lt;10; i++) if(s[i] == \u0026#39;o\u0026#39;) { if(!used[i]) return false; } else if(s[i] == \u0026#39;x\u0026#39; \u0026amp;\u0026amp; used[i]) return false; return true; } int main() { scanf(\u0026#34;%s\u0026#34;, s); int ans = 0; for(int a=0; a\u0026lt;10; a++) for(int b=0; b\u0026lt;10; b++) for(int c=0; c\u0026lt;10; c++) for(int d=0; d\u0026lt;10; d++) ans += valid(a, b, c, d); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Game in Momotetsu World\rProblem Statement\rA $H\\times W$ grid has cells colored blue (+) or red (-). A token starts at $(1,1)$. Takahashi and Aoki take turns moving it right or down. The current player gains 1 point for blue cells or loses 1 point for red cells. The game ends at $(H,W)$. Determine the winner if both play optimally.\n$1\\le H,W\\le 2000$\nInput Format\r$H~W$\n$A_{1,1}A_{1,2}\\dots A_{1,W}$\n$A_{2,1}A_{2,2}\\dots A_{2,W}$\n$\\vdots$\n$A_{H,1}A_{H,2}\\dots A_{H,W}$\nOutput Format\rPrint Takahashi, Aoki, or Draw.\nAnalysis\rDefine $d$ as the score difference (Takahashi ‚àí Aoki). Using dynamic programming:\nFor $(i+j)$ even (Aoki\u0026rsquo;s turn): $dp(i,j) = \\min(dp(i+1,j) - add(i+1,j), dp(i,j+1) - add(i,j+1))$ For $(i+j)$ odd (Takahashi\u0026rsquo;s turn): $dp(i,j) = \\max(dp(i+1,j) + add(i+1,j), dp(i,j+1) + add(i,j+1))$ $add(i,j)$ is the score change upon entering $(i,j)$. The result depends on $dp(0,0)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 2005 using namespace std; int dp[maxn], add[maxn][maxn]; int main() { int h, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;h, \u0026amp;w); for(int i=0; i\u0026lt;h; i++) { char tmp[maxn]; scanf(\u0026#34;%s\u0026#34;, tmp); for(int j=0; j\u0026lt;w; j++) add[i][j] = tmp[j] == \u0026#39;+\u0026#39;? 1: -1; } dp[w - 1] = 0; for(int j=w-2; j\u0026gt;=0; j--) dp[j] = j + h \u0026amp; 1? dp[j + 1] + add[h - 1][j + 1]: dp[j + 1] - add[h - 1][j + 1]; for(int i=h-2; i\u0026gt;=0; i--) { dp[w - 1] = i + w \u0026amp; 1? dp[w - 1] + add[i + 1][w - 1]: dp[w - 1] - add[i + 1][w - 1]; for(int j=w-2; j\u0026gt;=0; j--) if(i + j \u0026amp; 1) dp[j] = min(dp[j] - add[i + 1][j], dp[j + 1] - add[i][j + 1]); else dp[j] = max(dp[j] + add[i + 1][j], dp[j + 1] + add[i][j + 1]); } if(dp[0] \u0026gt; 0) puts(\u0026#34;Takahashi\u0026#34;); else if(dp[0] \u0026lt; 0) puts(\u0026#34;Aoki\u0026#34;); else puts(\u0026#34;Draw\u0026#34;); return 0; } E - Xor Distances\rProblem Statement\rGiven a tree with $N$ nodes and edge weights, compute $\\sum_{1\\le i","date":"2021-05-18T19:30:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc201/","title":"Mynavi Programming Contest 2021 (AtCoder Beginner Contest 201) A~E Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Div\rProblem Statement\rTwo boys want to divide $N$ candies. How many ways are there to distribute them (each boy must get at least one candy)?\n$1\\le N\\le 15$\nInput Format\r$N$\nOutput Format\rPrint the answer as an integer.\nSample\r$N$ Output $2$ $1$ $1$ $0$ $3$ $2$ Analysis\rThe problem reduces to splitting $N$ into two positive integers $A$ and $B$ (where $A+B$ and $B+A$ count as distinct). The possible pairs are:\n$A$ $B$ $1$ $N-1$ $2$ $N-2$ $\\dots$ $\\dots$ $N-1$ $1$ This table has $N-1$ entries, so we directly output $N-1$. Code\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;%d\\n\u0026#34;, n - 1); return 0; } B - Palindrome with leading zeros\rProblem Statement\rGiven an integer $N$, can we prepend any number (including zero) of 0s to its decimal representation to make it a palindrome?\n$0\\le N\\le 10^9$\nInput Format\r$N$\nOutput Format\rPrint Yes or No.\nSample\r$N$ Output $1210$ Yes $777$ Yes $123456789$ No Analysis\rIf prepending zeros can make $N$ a palindrome, then trimming all trailing zeros from $N$ must also yield a palindrome. Thus, we trim trailing zeros and check if the resulting string is a palindrome.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;cstdio\u0026gt; using namespace std; char s[10]; int main() { char c; int len = 0; while((c = getchar()) != \u0026#39;\\n\u0026#39;) s[len++] = c; while(len \u0026gt; 0 \u0026amp;\u0026amp; s[--len] == \u0026#39;0\u0026#39;); for(int i=0; i\u0026lt;=len; i++) if(s[i] != s[len - i]) { puts(\u0026#34;No\u0026#34;); return 0; } puts(\u0026#34;Yes\u0026#34;); return 0; } C - Compass Walking\rProblem Statement\rIn a 2D plane, a person moves exactly $R$ units per step. What is the minimum steps needed to go from $(0,0)$ to $(X,Y)$?\nNote: The distance between $(x_1, y_1)$ and $(x_2,y_2)$ is $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$.\n$1\\le R\\le 10^5$\n$0\\le X,Y\\le 10^5$\n$(X,Y)\\ne(0,0)$\nInput Format\r$R~X~Y$\nOutput Format\rPrint the minimum number of steps.\nSample\r$R$ $X$ $Y$ Output $5$ $15$ $0$ $3$ $5$ $11$ $0$ $3$ $3$ $4$ $4$ $2$ Analysis\rLet $d=\\sqrt{X^2+Y^2}$ (Euclidean distance). The solution depends on:\nIf $d = R$: 1 step. If $d \u003c R$: 2 steps (two orthogonal steps form a hypotenuse). If $d \u003e R$: $\\lceil\\frac{d}{R}\\rceil$ steps. Code\rPrecision issues were tricky, but using long double worked.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int r, x, y; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;r, \u0026amp;x, \u0026amp;y); long double dist = hypotl(x, y); if(dist == r) puts(\u0026#34;1\u0026#34;); else if(dist \u0026lt; r) puts(\u0026#34;2\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, int(ceill(dist / r))); return 0; } D - Send More Money\rProblem Statement\rGiven three lowercase strings $S_1,S_2,S_3$, assign each unique letter a distinct digit (0-9) such that $N_1 + N_2 = N_3$ when converted to numbers (no leading zeros). Output any solution or UNSOLVABLE.\n$1\\le |S_1|,|S_2|,|S_3|\\le 10$\nTime Limit: 5 sec\nInput Format\r$S_1$\n$S_2$\n$S_3$\nOutput Format\rPrint $N_1$, $N_2$, $N_3$ on three lines, or UNSOLVABLE.\nSample\r$S_1$ $S_2$ $S_3$ Output a b c 1 2 3 x x y 1 1 2 p q p UNSOLVABLE Analysis\rIf the total unique letters exceed 10, output UNSOLVABLE. Otherwise, brute-force all permutations of digit assignments (up to $10!$ possibilities) and validate.\nCode\rUsing permutations for enumeration:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxl 15 using namespace std; using LL = long long; char s1[maxl], s2[maxl], s3[maxl], ch[maxl]; set\u0026lt;char\u0026gt; chars; int pos[26], num[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; #define N (num[pos[str[i] - \u0026#39;a\u0026#39;]]) inline LL parse(const char* str) { LL res = 0LL; for(int i=0; str[i]; i++) res = res * 10LL + N; return res; } inline void print(const char* str) { for(int i=0; str[i]; i++) putchar(N + \u0026#39;0\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); } #undef N inline void add(const char* str) { for(int i=0; str[i]; i++) chars.insert(str[i]); } inline bool isok(const char* str) { return num[pos[str[0] - \u0026#39;a\u0026#39;]] != 0; } int main() { scanf(\u0026#34;%s%s%s\u0026#34;, s1, s2, s3); add(s1), add(s2), add(s3); if(chars.size() \u0026gt; 11) { puts(\u0026#34;UNSOLVABLE\u0026#34;); return 0; } int cnt = 0; for(char x: chars) pos[x - \u0026#39;a\u0026#39;] = cnt++; do { if(isok(s1) \u0026amp;\u0026amp; isok(s2) \u0026amp;\u0026amp; isok(s3) \u0026amp;\u0026amp; (parse(s1) + parse(s2) == parse(s3))) { print(s1); print(s2); print(s3); return 0; } } while(next_permutation(num, num + 10)); puts(\u0026#34;UNSOLVABLE\u0026#34;); return 0; } P.S. This code runs surprisingly fast\u0026hellip; took only 109ms\u0026hellip;\nE - Unique Color\rProblem Statement\rGiven a tree with $N$ vertices, each vertex has a color $C_i$. A vertex $x$ is good if:\nThe shortest path from vertex $1$ to $x$ contains no duplicate colors (excluding $x$ itself). Output all good vertices in ascending order.\n$2\\le N\\le 10^5$\n$1\\le C_i\\le 10^5$\nInput Format\r$N$\n$C_1~\\dots~C_N$\n$A_1~B_1$\n$\\vdots$\n$A_{N-1}~B_{N-1}$\nOutput Format\rList all good vertices, one per line.\nAnalysis\rUse DFS to track colors along the path. Maintain a used array to check color uniqueness. Time complexity: $\\mathcal O(N)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 100005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; bool used[maxn]; int color[maxn]; set\u0026lt;int\u0026gt; res; void dfs(int v, int par) { if(used[color[v]]) { for(int u: G[v]) if(u != par) dfs(u, v); return; } used[color[v]] = true; res.insert(v); for(int u: G[v]) if(u != par) dfs(u, v); used[color[v]] = false; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%d\u0026#34;, color + i); while(--n) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G[x].push_back(y); G[y].push_back(x); } dfs(1, -1); for(int v: res) printf(\u0026#34;%d\\n\u0026#34;, v); return 0; } ","date":"2021-04-13T21:29:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc198/","title":"AtCoder Beginner Contest 198 A~E Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Original Problem Links: Luogu; AtCoder\nApproach\rGenerate subsequent digits as (last digit -1)/last digit/(last digit +1) based on the previous digit, enqueue them, then output the K-th dequeued integer.\nNotes\rUsing int instead of long long will cause WA! When last digit is 0, next digit cannot be -1 (special case) When last digit is 9, next digit cannot be 10 (special case) Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; typedef long long LL; int main(int argc, char** argv) { int k; scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); queue\u0026lt;LL\u0026gt; q; for(int i=1; i\u0026lt;10; i++) q.push(i); while(true) { LL x = q.front(); q.pop(); if(--k == 0) { printf(\u0026#34;%lld\\n\u0026#34;, x); return 0; } int r = x % 10LL; x *= 10LL; x += r; if(r \u0026gt; 0) q.push(x - 1); q.push(x); if(r \u0026lt; 9) q.push(x + 1); } return 0; } ","date":"2021-04-01T19:53:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc161/","title":"AtCoder Beginner Contest 161D Solution"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Difference Max\rProblem Statement\rGiven four integers $a$, $b$, $c$, and $d$.\nChoose integers $x$ and $y$ such that $a \\le x \\le b$ and $c \\le y \\le d$. Find the maximum possible value of $x - y$.\nConstraints:\n$-100 \\le a \\le b \\le 100$\n$-100 \\le c \\le d \\le 100$\nInput Format\r1 2 a b c d Output Format\rPrint the maximum value of $x - y$.\nSample Cases\r$a$ $b$ $c$ $d$ Output 0 10 0 10 10 -100 -100 100 100 200 -100 100 -100 100 200 Analysis\rTo maximize $x - y$, $x$ should be as large as possible ($x = b$) and $y$ as small as possible ($y = c$). Thus, directly output $b - c$.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c, d; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); printf(\u0026#34;%d\\n\u0026#34;, b - c); return 0; } B - Round Down\rProblem Statement\rGiven a number $X$, compute $\\lfloor X \\rfloor$.\nConstraints:\n$0 \\le X \\le 10^{100}$\nInput Format\r1 X Output Format\rPrint $\\lfloor X \\rfloor$.\nSample Cases\rX Output 5.90 5 0 0 84939825309432908832902189.9092309409809091329 84939825309432908832902189 Analysis\rTruncate all characters starting from the decimal point. For example: $5\\sout{.90}$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char c; while((c = getchar()) != \u0026#39;\\n\u0026#39;) { if(c == \u0026#39;.\u0026#39;) return 0; putchar(c); } return 0; } C - Doubled\rProblem Statement\rCount how many integers between 1 and $N$ (inclusive) are formed by concatenating two identical positive integers.\nConstraints:\n$1 \\le N \u003c 10^{12}$\nInput Format\r1 N Output Format\rPrint the count.\nSample Cases\rN Output 33 3 1333 13 10000000 999 Analysis\rThe problem reduces to finding the largest $X$ such that concatenating $X$ twice does not exceed $N$. Use binary search with the right boundary set to $\\sqrt{N}$ to avoid overflow.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; typedef long long LL; inline bool check(const LL\u0026amp; x, const LL\u0026amp; n) { LL p = 1LL; while(p \u0026lt;= x) p *= 10LL; return x * p + x \u0026lt;= n; } int main() { LL n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); LL l = 0LL, r = sqrt(n); while(l \u0026lt; r) { LL mid = l + r + 1LL \u0026gt;\u0026gt; 1LL; if(check(mid, n)) l = mid; else r = mid - 1; } printf(\u0026#34;%lld\\n\u0026#34;, l); return 0; } D - Hanjo\rProblem Statement\rTile an $H \\times W$ grid using $A$ $2 \\times 1$ dominoes and $B$ $1 \\times 1$ squares. Count the number of ways to fully cover the grid.\nConstraints:\n$1 \\le H, W, HW \\le 16$\n$0 \\le A, B$\n$2A + B = HW$\nInput Format\r1 H W A B Output Format\rPrint the number of valid tilings.\nSample Cases\rH W A B Output 2 2 1 2 4 3 3 4 1 18 4 4 8 0 36 Analysis\rUse backtracking to explore all placements. Track the current position and remaining tiles, placing dominoes horizontally or vertically while avoiding overlaps.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;cstdio\u0026gt; #define maxn 20 using namespace std; bool mat[maxn][maxn]; int h, w, a, b, ans; inline bool valid(int x, int y) { return !mat[x][y] \u0026amp;\u0026amp; x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; h \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; w; } void dfs(int i, int j, int usedA, int usedB) { if((usedA \u0026lt;\u0026lt; 1) + usedB == h * w) { ans ++; return; } if(i == h) return; int ni, nj; if(j == w - 1) ni = i + 1, nj = 0; else ni = i, nj = j + 1; if(mat[i][j]) { dfs(ni, nj, usedA, usedB); return; } mat[i][j] = true; // Rectangle (A) if(usedA \u0026lt; a) { if(valid(i, j + 1)) { mat[i][j + 1] = true; dfs(ni, nj, usedA + 1, usedB); mat[i][j + 1] = false; } if(valid(i + 1, j)) { mat[i + 1][j] = true; dfs(ni, nj, usedA + 1, usedB); mat[i + 1][j] = false; } } // Square (B) if(usedB \u0026lt; b) dfs(ni, nj, usedA, usedB + 1); mat[i][j] = false; } int main() { scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;h, \u0026amp;w, \u0026amp;a, \u0026amp;b); dfs(0, 0, 0, 0); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } E - Filters\rProblem Statement\rGiven sequences $A$, $T$, and $X$, compute the composite function $F(x) = f_N(\\dots f_2(f_1(x)) \\dots)$ for each query $x_i$, where:\n$f_i(x) = x + a_i$ if $t_i = 1$ $f_i(x) = \\max(x, a_i)$ if $t_i = 2$ $f_i(x) = \\min(x, a_i)$ if $t_i = 3$ Constraints:\n$1 \\le N, Q \\le 2 \\times 10^5$\n$|a_i|, |x_i| \\le 10^9$\nInput Format\r1 2 3 4 5 6 7 N a_1 t_1 a_2 t_2 ... a_N t_N Q x_1 x_2 ... x_Q Output Format\rPrint $Q$ lines, each containing $F(x_i)$.\nSample Input\r1 2 3 4 5 6 3 -10 2 10 1 10 3 5 -15 -10 -5 0 5 Sample Output\r1 2 3 4 5 0 0 5 10 10 Analysis\rThe composite function can be represented as $F(x) = \\min(c, \\max(b, x + a))$. Track three parameters $a$, $b$, and $c$ through the function chain:\nAdditive shifts accumulate in $a$. $\\max$ operations set lower bounds in $b$. $\\min$ operations set upper bounds in $c$. Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; typedef long long LL; const LL INF = LLONG_MAX \u0026gt;\u0026gt; 1LL; int main() { LL l = -INF, r = INF, add = 0LL; int n, q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while(n--) { LL a, t; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a, \u0026amp;t); if(t == 1) l += a, r += a, add += a; else if(t == 2) l = max(l, a), r = max(r, a); else l = min(l, a), r = min(r, a); } scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while(q--) { LL x; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); printf(\u0026#34;%lld\\n\u0026#34;, clamp(x + add, l, r)); } return 0; } ","date":"2021-04-01T19:53:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc196/","title":"AtCoder Beginner Contest 196 A~E Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Health M Death\rProblem Statement\rA magician is fighting a monster with HP $H$.\nThe magician can defeat the monster when its HP is a multiple of $M$.\nCan the magician defeat the monster?\n$1\\le M,H\\le 1000$\nInput Format\r$M~H$\nOutput Format\rPrint Yes if the magician can defeat the monster; otherwise, print No.\nSample Cases\r$M$ $H$ Output $10$ $120$ Yes $10$ $125$ No Analysis\rCheck if $H$ is a multiple of $M$.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int m, h; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;m, \u0026amp;h); puts(h % m == 0? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Many Oranges\rProblem Statement\rWe have many oranges. Each orange weighs between $A$ and $B$ grams (inclusive, possibly non-integer).\nThe total weight of these oranges is exactly $W$ kilograms.\nFind the minimum and maximum possible number of oranges.\n$1\\le A\\le B\\le 1000$\n$1\\le W\\le 1000$\nInput Format\r$A~B~W$\nOutput Format\rPrint the minimum and maximum number of oranges separated by a space. If the scenario is impossible, print UNSATISFIABLE.\nSample Cases\r$A$ $B$ $W$ Output $100$ $200$ $2$ $10 20$ $120$ $150$ $2$ $14 16$ $300$ $333$ $1$ UNSATISFIABLE Analysis\rFor the minimum number, assume each orange has maximum weight $B$: $min = \\lceil \\frac{W \\times 1000}{B} \\rceil$.\nFor the maximum number, assume each orange has minimum weight $A$: $max = \\lfloor \\frac{W \\times 1000}{A} \\rfloor$.\nIf $min \u003e max$, output UNSATISFIABLE; otherwise, output $min$ and $max$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;w); w *= 1000; int min = w % b == 0? w / b: w / b + 1; int max = w / a; if(min \u0026gt; max) puts(\u0026#34;UNSATISFIABLE\u0026#34;); else printf(\u0026#34;%d %d\\n\u0026#34;, min, max); return 0; } C - Comma\rProblem Statement\rWhen writing an integer, we place a comma every three digits from the right. For example, $1234567$ becomes 1,234,567, and $777$ remains 777.\nHow many commas are needed when writing all integers from $1$ to $N$ inclusive?\n$1\\le N\\le 10^{15}$\nInput Format\r$N$\nOutput Format\rPrint the total number of commas.\nSample Cases\r$N$ Output $1010$ $11$ $27182818284590$ $107730272137364$ Analysis\rCount commas by digit positions. For each power of 1000 starting from $10^3$, add the count of numbers greater than or equal to that power.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;cstdio\u0026gt; using namespace std; typedef long long LL; int main() { LL n, ans = 0LL; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for(LL p=1000LL; p\u0026lt;=n; p*=1000LL) ans += n - p + 1; printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } D - Shipping Center\rProblem Statement\rWe have $N$ packages (1 to $N$) and $M$ boxes (1 to $M$).\nPackage $i$ has size $W_i$ and value $V_i$.\nBox $i$ can hold exactly one package with size $\\leq X_i$.\nFor $Q$ queries, each specifying $L$ and $R$, determine the maximum total value when boxes $L$ to $R$ are unavailable.\n$1\\le N,M,Q\\le 50$\n$1\\le W_i,V_i,X_i\\le 10^6$\n$1\\le L\\le R\\le M$\nInput Format\r$N~M~Q$\n$W_1~V_1$\n$\\vdots$\n$W_N~V_N$\n$X_1~\\dots~X_M$\n$L_1~R_1$\n$\\vdots$\n$L_Q~R_Q$\nOutput Format\rPrint $Q$ lines containing answers for each query.\nSample Input\r1 2 3 4 5 6 7 8 3 4 3 1 9 5 3 7 8 1 8 6 9 4 4 1 4 1 3 Sample Output\r1 2 3 20 0 9 Analysis\rSort boxes by size. For each query, greedily assign the most valuable package that fits each available box.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 55 using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; pii bags[maxn], boxes[maxn]; bool taken[maxn]; int main() { int n, m, q; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;q); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;bags[i].second, \u0026amp;bags[i].first); sort(bags, bags + n, greater\u0026lt;pii\u0026gt;()); for(int i=0; i\u0026lt;m; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;boxes[i].first), boxes[i].second = i; sort(boxes, boxes + m); while(q--) { int l, r, ans = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); l --, r --; fill(taken, taken + n, false); for(int i=0; i\u0026lt;m; i++) { auto [size, idx] = boxes[i]; if(idx \u0026lt; l || idx \u0026gt; r) { int j = 0; for(; j\u0026lt;n; j++) if(!taken[j] \u0026amp;\u0026amp; bags[j].second \u0026lt;= size) break; if(j \u0026lt; n) ans += bags[j].first, taken[j] = true; } } printf(\u0026#34;%d\\n\u0026#34;, ans); } return 0; } E - Lucky 7 Battle\rProblem Statement\rGiven a digit string $S$ of length $N$ and a string $X$ of A and T of length $N$, Takahashi and Aoki play a game:\nOn turn $i$, if $X_i$ is A, Aoki chooses to append $S_i$ or 0 to string $T$; otherwise, Takahashi chooses. After $N$ turns, if $T$ represents a number divisible by 7, Takahashi wins; else, Aoki wins. Determine the winner when both play optimally.\n$1\\le N\\le 10^5$\nInput Format\r$N$\n$S$\n$X$\nOutput Format\rPrint Takahashi or Aoki.\nSample Cases\rSee AtCoder.\nAnalysis\rUse memoization to track the winner for each (turn, current modulo 7). The current player wins if any choice leads to their victory.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define maxn 200005 using namespace std; char s[maxn], x[maxn]; int n, dp[maxn][7]; int winner(int i, int r) { if(dp[i][r] != -1) return dp[i][r]; if(i \u0026gt;= n) return dp[i][r] = r == 0; if(winner(i + 1, 10 * r % 7) == TA) { if(x[i] == \u0026#39;T\u0026#39;) return dp[i][r] = TA; } else if(x[i] == \u0026#39;A\u0026#39;) return dp[i][r] = AO; if(winner(i + 1, (10 * r + s[i] - \u0026#39;0\u0026#39;) % 7) == TA) { if(x[i] == \u0026#39;T\u0026#39;) return dp[i][r] = TA; } else if(x[i] == \u0026#39;A\u0026#39;) return dp[i][r] = AO; return dp[i][r] = x[i] == \u0026#39;A\u0026#39;; } int main() { scanf(\u0026#34;%d%s%s\u0026#34;, \u0026amp;n, s, x); memset(dp, -1, sizeof(dp)); puts(winner(0, 0) == TA? \u0026#34;Takahashi\u0026#34;: \u0026#34;Aoki\u0026#34;); return 0; } ","date":"2021-03-25T20:24:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc195/","title":"Panasonic Programming Contest (AtCoder Beginner Contest 195) A~E Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - I Scream\rProblem Statement\rIn Japan, there are four types of ice cream products:\nProducts with at least 15% milk solids and 8% milk fat are called \u0026ldquo;ice cream\u0026rdquo;; Products with at least 10% milk solids and 3% milk fat that are not ice cream are called \u0026ldquo;ice milk\u0026rdquo;; Products with at least 3% milk solids that are neither ice cream nor ice milk are called \u0026ldquo;lacto ice\u0026rdquo;; Products that do not fall into any of the above categories are called \u0026ldquo;flavored ice\u0026rdquo;. Here, milk solids consist of milk fat and milk solids-not-fat.\nGiven an ice cream product containing A% milk solids-not-fat and B% milk fat, determine its category.\nConstraints:\n$0\\le A,B\\le 100$ $0\\le A+B\\le 100$ Input Format\rA B\nOutput Format\rOutput the category number:\n1 for ice cream 2 for ice milk 3 for lacto ice 4 for flavored ice Sample Cases\rA B Output 10 8 1 1 2 3 0 0 4 Analysis\rCalculate total milk solids by adding A and B, then check the conditions sequentially.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); a += b; if(a \u0026gt;= 15 \u0026amp;\u0026amp; b \u0026gt;= 8) puts(\u0026#34;1\u0026#34;); else if(a \u0026gt;= 10 \u0026amp;\u0026amp; b \u0026gt;= 3) puts(\u0026#34;2\u0026#34;); else if(a \u0026gt;= 3) puts(\u0026#34;3\u0026#34;); else puts(\u0026#34;4\u0026#34;); return 0; } B - Job Assignment\rProblem Statement\rA company has N employees. Employee i can complete Job A in A_i minutes and Job B in B_i minutes. Assign each job to one employee (possibly the same). The completion time t is:\nA_i + B_i if both jobs go to employee i max(A_i, B_j) if different employees take the jobs Find the minimum possible t.\nConstraints:\n$2 \\le N \\le 1000$ $1 \\le A_i, B_i \\le 10^5$ Input Format\r1 2 3 4 N A_1 B_1 ... A_N B_N Output Format\rPrint the minimal t.\nSample Cases\rPlease refer to AtCoder.\nAnalysis\rBrute-force all possible (i,j) pairs with O(N¬≤) complexity. Optimizations exist but are more complex.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #define maxn 1005 #define INF 2147483647 using namespace std; int a[maxn], b[maxn]; inline void setmin(int\u0026amp; x, int y) { if(y \u0026lt; x) x = y; } inline int max(int x, int y) { return x \u0026gt; y ? x : y; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d%d\u0026#34;, a + i, b + i); int ans = INF; for(int i=0; i\u0026lt;n; i++) { setmin(ans, a[i] + b[i]); // Same employee for(int j=i+1; j\u0026lt;n; j++) { setmin(ans, max(a[i], b[j])); setmin(ans, max(a[j], b[i])); } } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } C - Squared Error\rProblem Statement\r$$\\sum_{i=2}^{N} \\sum_{j=1}^{i-1} (A_i - A_j)^2$$Constraints:\n$2 \\le N \\le 3 \\times 10^5$ $|A_i| \\le 200$ Input Format\r1 2 N A_1 A_2 ... A_N Output Format\rPrint the computed sum.\nSample Cases\rSample Input 1\r1 2 3 2 8 4 Sample Output 1\r1 56 Sample Input 2\r1 2 5 -5 8 9 -4 -3 Sample Output 2\r1 950 Analysis\r$$\\text{Result} = (N-1)\\sum A_i^2 - 2\\sum_{i=1}^N (S_i \\cdot A_i)$$\nwhere S_i is the sum of previous elements.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #define maxn 300005 using namespace std; using LL = long long; int main() { int n, s1 = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); LL s2 = 0, m = 0LL; for(int i=0; i\u0026lt;n; i++) { LL x; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); m += x * s1; s1 += x, s2 += x * x; } m \u0026lt;\u0026lt;= 1LL, s2 *= n - 1LL; printf(\u0026#34;%lld\\n\u0026#34;, s2 - m); return 0; } D - Journey\rProblem Statement\rOn a graph with N nodes and no edges initially, perform operations until the graph becomes connected:\nRandomly select a vertex (uniform probability). Add an edge between current and selected vertex, then move to it. Compute the expected number of operations.\nConstraints:\n$2 \\le N \\le 10^5$ Input Format\r1 N Output Format\rPrint the answer with absolute error ‚â§1e-6.\nSample Cases\rN Output 2 2 3 4.5 Analysis\r$$\\sum_{i=1}^{N-1} \\frac{N}{i}$$Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); double res = 0; for(int i=1; i\u0026lt;n; i++) res += double(n) / i; printf(\u0026#34;%.8lf\\n\u0026#34;, res); return 0; } E - Mex Min\rProblem Statement\rGiven sequence A of length N, compute the minimum mex over all length-M contiguous subarrays.\nConstraints:\n$1 \\le M \\le N \\le 1.5 \\times 10^6$ $0 \\le A_i \\le N$ Input Format\r1 2 N M A_1 A_2 ... A_N Output Format\rPrint the minimal mex.\nSample Cases\rPlease refer to AtCoder.\nAnalysis\rMaintain a sliding window count and track zeros using a set for efficient mex calculation.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #define maxn 1500005 using namespace std; int cnt[maxn], a[maxn]; set\u0026lt;int\u0026gt; s; inline void setmin(int\u0026amp; x, int y) { if(y \u0026lt; x) x = y; } int main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); for(int i=0; i\u0026lt;m; i++) cnt[a[i]] ++; for(int i=0; i\u0026lt;n; i++) if(cnt[i] == 0) s.insert(i); s.insert(n); int ans = *s.begin(); n -= m; for(int i=0; i\u0026lt;n; i++) { if(cnt[a[i + m]]++ == 0) s.erase(a[i + m]); if(--cnt[a[i]] == 0) s.insert(a[i]); setmin(ans, *s.begin()); } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","date":"2021-03-17T21:25:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc194/","title":"AtCoder Beginner Contest 194 A~E Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Discount\rProblem Statement\rA product originally priced at $A$ yen is now sold for $B$ yen. What percentage discount is applied?\n$1\\le B \u003c A\\le 10^5$\nInput Format\r$A~B$\nOutput Format\rOutput the answer (without %). Absolute or relative error up to $10^{-2}$ is allowed.\nSamples\r$A$ $B$ Output $100$ $80$ $20.0$ $7$ $6$ $14.285714$ $99999$ $99998$ $0.0010000100001$ Analysis\rThe answer can be directly calculated using $\\frac{A-B}{A}$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;tuple\u0026gt; using namespace std; int main() { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;%.6lf\u0026#34;, (a - b) * 100.0 / a); return 0; } B - Play Snuke\rProblem Statement\rTakahashi wants to buy a product called Play Snuke.\nThere are $N$ stores selling Play Snuke. It takes $A_i$ minutes for Takahashi to reach the $i$-th store, which sells the product at $P_i$ yen with $X_i$ units in stock.\nTakahashi will visit one of these stores to buy a Play Snuke.\nHowever, each store sells one unit of Play Snuke at $0.5, 1.5, 2.5,\\dots$ minutes after opening.\nDetermine if Takahashi can buy the product. If possible, output the minimum amount he needs to pay.\n$1\\le N\\le 10^5$\n$1\\le A_i, P_i, X_i\\le 10^9$\nInput Format\r$N$\n$A_1~P_1~X_1$\n$\\vdots$\n$A_N~P_N~X_N$\nOutput Format\rIf Takahashi can buy Play Snuke, output the minimum cost; otherwise, output -1.\nSamples\rSample Input1\r1 2 3 4 3 3 9 5 4 8 5 5 7 5 Sample Output1\r1 8 Takahashi can choose store 2 and pay 8 yen.\nSample Input2\r1 2 3 4 3 5 9 5 6 8 5 7 7 5 Sample Output2\r1 -1 All stores will have sold out when Takahashi arrives.\nSample Input3\r1 2 3 4 5 6 7 8 9 10 11 10 158260522 877914575 602436426 24979445 861648772 623690081 433933447 476190629 262703497 211047202 971407775 628894325 731963982 822804784 450968417 430302156 982631932 161735902 880895728 923078537 707723857 189330739 910286918 802329211 404539679 303238506 317063340 492686568 773361868 125660016 Sample Output3\r1 861648772 Analysis\rFor store $i$, if $X_i \u003e A_i$, the product is still available when Takahashi arrives. Among all valid stores, select the minimum $P_i$. If no store satisfies $X_i \u003e A_i$, output -1.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 #define INF 2147483647 using namespace std; int main() { int n, ans = INF; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int a, p, x; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;p, \u0026amp;x); if(x \u0026gt; a \u0026amp;\u0026amp; p \u0026lt; ans) ans = p; } if(ans == INF) puts(\u0026#34;-1\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } C - Unexpressed\rProblem Statement\rGiven an integer $N$, how many integers between $1$ and $N$ (inclusive) cannot be expressed as $a^b$ where $a$ and $b$ are integers greater than or equal to $2$?\n$1\\le N\\le 10^{10}$\nInput Format\r$N$\nOutput Format\rOutput the answer.\nSamples\r$N$ Output $8$ $6$ $100000$ $99634$ Analysis\rThere are relatively few numbers expressible as $a^b$. Enumerate all possible $a$ ($2\\le a\\le \\sqrt N$), collect all $a^b$ values not exceeding $N$ in a set (for deduplication), then compute $N - \\text{final set size}$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; using LL = long long; set\u0026lt;LL\u0026gt; s; int main() { LL n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); LL tmp = sqrt(n); for(LL a=2; a\u0026lt;=tmp; a++) { LL res = a; // res = a ^ b while((res *= a) \u0026lt;= n) s.insert(res); } printf(\u0026#34;%lld\\n\u0026#34;, n - s.size()); return 0; } D - Poker\rProblem Statement\rRefer to the original problem.\nInput Format\r$K$\n$S$\n$T$\nOutput Format\rOutput Takahashi\u0026rsquo;s winning probability as a decimal between $0$ and $1$. Absolute or relative error up to $10^{-5}$ is allowed.\nSamples\r$K$ $S$ $T$ Output $2$ 1144# 2233# $0.4444444444444$ $2$ 9988# 1122# $1.0$ $6$ 1122# 2228# $0.0019323671498$ $10^5$ 3226# 3597# $0.6296297942426$ Analysis\r$$\\begin{cases}\rC_xC_y \u0026 (x \\ne y)\\\\\rC_x(C_x - 1) \u0026 (x = y)\\\\\r\\end{cases}$$\nEnumerate all valid $(x, y)$ pairs and divide the result by $(9K - 8)(9K - 9)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;cstdio\u0026gt; using namespace std; using LL = long long; char s[7], t[7]; int score(const char* cards) { int cnt[10]; for(int i=0; i\u0026lt;10; i++) cnt[i] = i; for(int i=0; i\u0026lt;5; i++) cnt[cards[i] - \u0026#39;0\u0026#39;] *= 10; int res = 0; for(int x: cnt) res += x; return res; } int main() { int k; scanf(\u0026#34;%d%s%s\u0026#34;, \u0026amp;k, s, t); int cnt[10]; for(int i=1; i\u0026lt;10; i++) cnt[i] = k; for(int i=0; i\u0026lt;4; i++) cnt[s[i] - \u0026#39;0\u0026#39;] --, cnt[t[i] - \u0026#39;0\u0026#39;] --; LL win = 0LL; for(int x=1; x\u0026lt;10; x++) if(cnt[x]) { s[4] = \u0026#39;0\u0026#39; + x; int sscore = score(s); for(int y=1; y\u0026lt;10; y++) if(cnt[y]) { t[4] = \u0026#39;0\u0026#39; + y; if(sscore \u0026gt; score(t)) win += cnt[x] * LL(cnt[y] - (x == y)); } } LL tmp = 9LL * k - 8LL; printf(\u0026#34;%.8lf\\n\u0026#34;, double(win) / tmp / double(tmp - 1LL)); return 0; } ","date":"2021-03-08T21:24:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc193/","title":"Caddi Programming Contest 2021 (AtCoder Beginner Contest 193) A~D Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Star\rProblem Statement\rWhat is the difference between the next multiple of 100 greater than X and X itself?\n$1\\le X\\le 10^5$\nInput Format\r$X$\nOutput Format\rPrint the answer.\nSample\r$X$ Output $140$ $60$ $1000$ $100$ Analysis\rThe next multiple of 100 greater than $X$ is $(\\lfloor X/100\\rfloor+1)\\times 100$. Thus, output $(\\lfloor X/100\\rfloor+1)\\times 100-X$.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); printf(\u0026#34;%d\\n\u0026#34;, (x / 100 + 1) * 100 - x); return 0; } B - uNrEaDaBlE sTrInG\rProblem Statement\rA string is unreadable if all characters at odd positions (1st, 3rd, 5th, etc., 1-based) are lowercase letters and all even positions are uppercase. Determine if $S$ is unreadable.\n$1\\le |S|\\le 1000$\n$S$ consists of uppercase and lowercase letters.\nInput Format\r$S$\nOutput Format\rPrint Yes if $S$ is unreadable, otherwise No.\nSample\r$S$ Output $\\text{dIfFiCuLt}$ Yes $\\text{eASY}$ No $\\text{a}$ Yes Analysis\rCheck each position according to the rules.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char c; int n = 0; while((c = getchar()) != \u0026#39;\\n\u0026#39;) { if(n++ % 2 == 0) { if(c \u0026lt; \u0026#39;a\u0026#39; || c \u0026gt; \u0026#39;z\u0026#39;) { puts(\u0026#34;No\u0026#34;); return 0; } continue; } if(c \u0026lt; \u0026#39;A\u0026#39; || c \u0026gt; \u0026#39;Z\u0026#39;) { puts(\u0026#34;No\u0026#34;); return 0; } } puts(\u0026#34;Yes\u0026#34;); return 0; } C - Kaprekar Number\rProblem Statement\rFor natural number $x$, define:\n$g1(x)$: $x$\u0026rsquo;s digits sorted in descending order $g2(x)$: $x$\u0026rsquo;s digits sorted in ascending order (leading zeros removed) $f(x) = g1(x) - g2(x)$ Example: $g1(314)=431$, $g2(3021)=123$, $f(271)=594$.\nGiven $N$ and $K$, perform $K$ iterations of $N := f(N)$ and output the final $N$.\n$0\\le N\\le 10^9$\n$1\\le K\\le 10^5$\nInput Format\r$N~K$\nOutput Format\rPrint the final $N$.\nSample\r$N$ $K$ Output $314$ $2$ $693$ $1000000000$ $100$ $0$ $6174$ $100000$ $6174$ Analysis\rUse bucket sort to compute $f(n)$ efficiently, achieving $\\mathcal O(K)$ total complexity.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int cnt[10]; int f(int x) { for(int i=0; i\u0026lt;10; i++) cnt[i] = 0; while(x \u0026gt; 0) { cnt[x % 10] ++; x /= 10; } int g1 = 0, g2 = 0, t = 1; for(int i=0; i\u0026lt;10; i++) while(cnt[i]--) { g1 += i * t, g2 = g2 * 10 + i; t *= 10; } return g1 - g2; } int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); while(k--) n = f(n); printf(\u0026#34;%d\\n\u0026#34;, n); return 0; } D - Base n\rProblem Statement\rGiven large integer $X$ (not fitting in long long) and $M$. Let $d$ be the maximum digit in $X$. Count how many $n \u003e d$ satisfy that treating $X$ as a base-$n$ number yields a decimal value ‚â§ $M$.\n$X$ has no leading zeros, 1 to 60 digits.\n$1\\le M\\le 10^{18}$\nInput Format\r$X$\n$M$\nOutput Format\rPrint the count.\nSample\rSamples omitted. Visit AtCoder for details.\nAnalysis\rValid $n$ range: $d \u003c n \\le \\text{max possible}$. Use binary search to find the maximum $n$ and subtract $d$.\nCode\rKey points:\nBinary search boundaries Overflow handling during value computation Edge case when $X$ is single-digit Without further ado, let\u0026rsquo;s dive into the code! ‚Üì~~~~~~‚Üì~~~~~~‚Üì\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; using namespace std; typedef unsigned long long ULL; char x[65]; ULL m; inline void setmax(int\u0026amp; x, int y) { if(y \u0026gt; x) x = y; } inline bool check(const ULL\u0026amp; base) { // Returns: (x -\u0026gt; base) \u0026lt;= m? ULL t = 0ULL; for(int i=0; x[i]; i++) { if(t \u0026gt; m / base) return false; t *= base; if((t += x[i] - \u0026#39;0\u0026#39;) \u0026gt; m) return false; } return true; } int main() { scanf(\u0026#34;%s%llu\u0026#34;, x, \u0026amp;m); int d = 0; for(int i=0; x[i]; i++) setmax(d, x[i] - \u0026#39;0\u0026#39;); if(x[1] == \u0026#39;\\0\u0026#39;) { puts(d \u0026gt; m? \u0026#34;0\u0026#34;: \u0026#34;1\u0026#34;); return 0; } ULL l = d, r = m; while(l \u0026lt; r) { ULL mid = l + r + 1ULL \u0026gt;\u0026gt; 1ULL; if(check(mid)) l = mid; else r = mid - 1ULL; } printf(\u0026#34;%llu\\n\u0026#34;, l - d); return 0; } ","date":"2021-02-28T21:33:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc192/","title":"AtCoder Beginner Contest 192 A~D Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Vanishing Pitch\rProblem Summary\rA ball travels at $V~\\text{m/s}$. It becomes invisible after flying for $T$ seconds and remains invisible after $S$ seconds. Can the person see the ball after it has flown $D$ meters? Output Yes or No.\nConstraints:\n$1\\le V\\le 1000$\n$1\\le T \u003c S\\le 1000$\n$1\\le D\\le 1000$\nInput Format\rV T S D\nOutput Format\rOutput the answer.\nSamples\r$V$ $T$ $S$ $D$ Output $10$ $3$ $5$ $20$ Yes $10$ $3$ $5$ $30$ No Analysis\rIf $VT \\le D \\le VS$, the ball is invisible after flying $D$ meters (output No); otherwise, output Yes.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int v, t, s, d; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;v, \u0026amp;t, \u0026amp;s, \u0026amp;d); puts((v * t \u0026lt;= d \u0026amp;\u0026amp; d \u0026lt;= v * s)? \u0026#34;No\u0026#34;: \u0026#34;Yes\u0026#34;); return 0; } B - Remove It\rProblem Summary\rGiven an integer sequence $A$ of length $N$, remove all occurrences of $X$ and output the remaining elements in their original order.\nConstraints:\n$1\\le N\\le 10^5$\n$1\\le X\\le 10^9$\n$1\\le A_i\\le 10^9$\nInput Format\rLine 1: N X\nLine 2: A_1 A_2 ... A_N\nOutput Format\rOutput the filtered sequence with elements separated by spaces.\nSamples\rSample Input 1\r1 2 5 5 3 5 6 5 4 Sample Output 1\r1 3 6 4 After removing all 5s from [3,5,6,5,4], we get [3,6,4].\nSample Input 2\r1 2 3 3 3 3 3 Sample Output 2\rOutput a blank line when all elements are removed.\nAnalysis\rThe problem does not require actual deletion of all $X$ elements; simply skip outputting elements equal to $X$ during printing.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n, x; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;x); while(n--) { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); if(a != x) printf(\u0026#34;%d \u0026#34;, a); } putchar(\u0026#39;\\n\u0026#39;); return 0; } C - Digital Graffiti\rProblem Summary\rGiven a $H \\times W$ grid where each cell is black (#) or white (.). The outermost cells are guaranteed to be white. The black cells form a polygon. Find the number of edges of this polygon.\nConstraints:\n$3\\le H,W\\le 10$\nInput Format\rLine 1: H W\nLines 2~H+1: Grid rows.\nOutput Format\rPrint the number of edges.\nSample\rSample Input\r1 2 3 4 5 6 5 5 ..... .###. .###. .###. ..... Sample Output\r1 4 The shape is a quadrilateral.\nCustom Test Case\rInput\r1 2 3 4 5 6 5 5 ..... ..#.. .###. .#.#. ..... Output\r1 12 Analysis\rThe number of vertices of a polygon equals its number of edges. A cell is a vertex if among its four adjacent cells, exactly one or three are white. Count such vertices by checking all $2 \\times 2$ squares.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;cstdio\u0026gt; #define maxn 15 using namespace std; char c[maxn][maxn]; int main() { int h, w, ans = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;h, \u0026amp;w); for(int i=0; i\u0026lt;h; i++) scanf(\u0026#34;%s\u0026#34;, c[i]); for(int i=0; i\u0026lt;h-1; i++) for(int j=0; j\u0026lt;w-1; j++) { int cnt = 0; cnt += c[i][j] == \u0026#39;.\u0026#39;; cnt += c[i][j + 1] == \u0026#39;.\u0026#39;; cnt += c[i + 1][j] == \u0026#39;.\u0026#39;; cnt += c[i + 1][j + 1] == \u0026#39;.\u0026#39;; if(cnt == 1 || cnt == 3) ans ++; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Circle Lattice Points\rProblem Summary\rCount the number of lattice points (integer coordinates) inside or on a circle with center $(X,Y)$ and radius $R$.\nConstraints:\n$|X|, |Y| \\le 10^5$\n$0 \\le R \\le 10^5$\n$X, Y, R$ may have up to 4 decimal places.\nInput Format\rX Y R\nOutput Format\rPrint the total count.\nSamples\rSample Input 1\r1 0.2 0.8 1.1 Sample Output 1\r1 3 The red marks in the figure indicate valid lattice points.\nSample Input 2\r1 100 100 1 Sample Output 2\r1 5 Note: Points exactly on the circle are counted.\nSample Input 3\r1 42782.4720 31949.0192 99999.99 Sample Output 3\r1 31415920098 Analysis\rPrecision handling: Multiply all values by $10^4$ to avoid floating-point errors. For each integer $x$ coordinate within the circle\u0026rsquo;s horizontal range, use binary search to find the maximum and minimum $y$ coordinates and count valid lattice points.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include \u0026lt;cstdio\u0026gt; #define DIV 10000LL using namespace std; typedef long long LL; LL x, y, R; inline LL read() { // Returns: input * 10000. LL res = 0LL; int num = 0; bool flag = false, negative = false; for(char c=getchar(); c != \u0026#39; \u0026#39; \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;; c=getchar()) { if(c == \u0026#39;-\u0026#39;) negative = true; else if(c == \u0026#39;.\u0026#39;) flag = true; else { res *= 10LL; res += c - \u0026#39;0\u0026#39;; if(flag) num ++; } } for(int i=num; i\u0026lt;4; i++) res *= 10LL; return negative? -res: res; } inline LL in_circle(const LL\u0026amp; dx, const LL\u0026amp; dy) { return dx * dx + dy * dy \u0026lt;= R * R; } inline LL findtop(LL i) { i *= DIV; LL l = y, r = y + R; while(l \u0026lt; r) { LL mid = l + r + 1LL \u0026gt;\u0026gt; 1LL; if(in_circle(i - x, mid - y)) l = mid; else r = mid - 1LL; } return l; } inline LL ceildiv(const LL\u0026amp; a) { // Returns: ceil(a / DIV). if(a \u0026lt; 0LL) return a / DIV; if(a % DIV == 0LL) return a / DIV; return a / DIV + 1LL; } inline LL floordiv(const LL\u0026amp; a) { // Returns: floor(a / DIV). if(a \u0026gt;= 0LL) return a / DIV; if(a % DIV == 0LL) return a / DIV; return a / DIV - 1LL; } int main() { x = read(), y = read(), R = read(); LL ans = 0LL, left = ceildiv(x - R), right = floordiv(x + R); for(LL i=left; i\u0026lt;=right; i++) { LL top = findtop(i); LL bottom = (y \u0026lt;\u0026lt; 1LL) - top; ans += floordiv(top) - ceildiv(bottom) + 1LL; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2021-02-09T19:03:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc191/","title":"AtCoder Beginner Contest 191 A~D Problem Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Very Very Primitive Game\rProblem Statement\rTakahashi and Aoki are playing a game. The rules are as follows:\nInitially, Takahashi and Aoki have $A$ and $B$ candies, respectively. They take turns eating one candy. The first player unable to eat loses. If $C=0$, Takahashi goes first; if $C=1$, Aoki goes first. Output the winner\u0026rsquo;s name.\n$0\\le A,B\\le 100$\n$C \\in \\{0,1\\}$\nInput Format\r$A~B~C$\nOutput Format\rPrint the winner.\nSample Cases\rA B C Output 2 1 0 Takahashi 2 2 0 Aoki 2 2 1 Takahashi Analysis\rIf Aoki starts first ($C=1$), he wins when $B \u003e A$. For Takahashi starting first ($C=0$), increment $B$ by 1 to simulate Aoki\u0026rsquo;s first move scenario, then check if $B \u003e A$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); if(c == 0) b ++; puts(b \u0026gt; a? \u0026#34;Aoki\u0026#34;: \u0026#34;Takahashi\u0026#34;); return 0; } B - Magic 3\rProblem Statement\rA magician battles a monster. He can use $N$ spells. The $i$-th spell has cooldown $X_i$ seconds and deals $Y_i$ damage. The monster is immune to spells with cooldown $\\geq S$ or damage $\\leq D$. Can the magician damage the monster?\n$1\\le N\\le 100$\n$1\\le X_i, Y_i\\le 10^9$\n$1\\le S, D\\le 10^9$\nInput Format\r$N~S~D$\n$X_1~Y_1$\n$X_2~Y_2$\n$\\vdots$\n$X_N~Y_N$\nOutput Format\rPrint Yes if possible, otherwise No.\nSample Cases\rSample Input 1\r1 2 3 4 5 4 9 9 5 5 15 5 5 15 15 15 Sample Output 1\r1 Yes With $S=D=9$:\nSpell No. Cooldown Damage Can Damage Monster? 1 5 sec ‚úì 5 ‚úó ‚úó 2 15 sec ‚úó 5 ‚úó ‚úó 3 5 sec ‚úì 15 ‚úì ‚úì 4 15 sec ‚úó 15 ‚úì ‚úó Sample Input 2\r1 2 3 4 3 691 273 691 997 593 273 691 273 Sample Output 2\r1 No Sample Input 3\r1 2 3 4 5 6 7 8 7 100 100 10 11 12 67 192 79 154 197 142 158 20 25 17 108 Sample Output 3\r1 Yes Only the 7th spell works.\nAnalysis\rFor each spell, check if $X_i \u003c S$ and $Y_i \u003e D$ hold. Output Yes if any spell satisfies both conditions.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n, s, d; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;s, \u0026amp;d); while(n--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); if(x \u0026lt; s \u0026amp;\u0026amp; y \u0026gt; d) { puts(\u0026#34;Yes\u0026#34;); return 0; } } puts(\u0026#34;No\u0026#34;); return 0; } C - Bowls and Dishes\rProblem Statement\rThere are $N$ dishes numbered $1,2,\\dots,N$ and $M$ conditions. Condition $i$ is satisfied if both dishes $A_i$ and $B_i$ contain at least one ball. $K$ people each place a ball in dish $C_i$ or $D_i$. Find the maximum number of satisfied conditions.\n$2\\le N\\le 100$\n$1\\le M\\le 100$\n$1\\le A_i \u003c B_i\\le N$\n$1\\le K\\le 16$\n$1\\le C_i \u003c D_i\\le N$\nInput Format\r$N~M$\n$A_1~B_1$\n$\\vdots$\n$A_M~B_M$\n$K$\n$C_1~D_1$\n$\\vdots$\n$C_K~D_K$\nOutput Format\rPrint the maximum count.\nSample Cases\rSample Input 1\r1 2 3 4 5 6 7 8 9 4 4 1 2 1 3 2 4 3 4 3 1 2 1 3 2 3 Sample Output 1\r1 2 Choosing dishes 1, 3, 2 satisfies conditions 1 and 2.\nSample Input 2\r1 2 3 4 5 6 7 8 9 10 4 4 1 2 1 3 2 4 3 4 4 3 4 1 2 2 4 2 4 Sample Output 2\r1 4 Choosing dishes 3, 1, 2, 4 satisfies all conditions.\nSample Input 3\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 6 12 2 3 4 6 1 2 4 5 2 6 1 5 4 5 1 3 1 2 2 6 2 3 2 5 5 3 5 1 4 2 6 4 6 5 6 Sample Output 3\r1 9 Analysis\rEnumerate all $2^K$ choices using bitmasking. For each combination, track which dishes have balls and count satisfied conditions. Time complexity is $\\mathcal O(M2^K)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int a[105], b[105], c[20], d[20]; int main() { int n, m, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;m; i++) { scanf(\u0026#34;%d%d\u0026#34;, a + i, b + i); a[i] --, b[i] --; } scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); for(int i=0; i\u0026lt;k; i++) { scanf(\u0026#34;%d%d\u0026#34;, c + i, d + i); c[i] --, d[i] --; } int limit = 1 \u0026lt;\u0026lt; k, ans = 0; for(int st=0; st\u0026lt;limit; st++) { bool hasdish[105] = {false}; for(int i=0; i\u0026lt;k; i++) if(st \u0026amp; (1 \u0026lt;\u0026lt; i)) hasdish[c[i]] = true; else hasdish[d[i]] = true; int cnt = 0; for(int i=0; i\u0026lt;m; i++) cnt += hasdish[a[i]] \u0026amp;\u0026amp; hasdish[b[i]]; if(cnt \u0026gt; ans) ans = cnt; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Staircase Sequences\rProblem Statement\rCount the number of arithmetic sequences with sum $N$ and common difference 1 (allowing negative terms).\n$1\\le N\\le 10^{12}$\nInput Format\r$N$\nOutput Format\rPrint the count.\nSample Cases\rN Output 12 4 1 2 63761198400 1920 Analysis\r$$\\frac {(a+b)(b-a+1)} 2 = N$$$$(a+b)(b-a+1) = 2N$$\nWe count pairs of factors of $2N$ with different parity (one even, one odd). Multiply the result by 2 to account for negative sequences. Time complexity is $\\mathcal O(\\sqrt N)$.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;cstdio\u0026gt; using namespace std; typedef long long LL; int main() { LL n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); n \u0026lt;\u0026lt;= 1LL; int cnt = 0; for(LL i=1; i*i\u0026lt;=n; i++) if(n % i == 0 \u0026amp;\u0026amp; i % 2 != n / i % 2) cnt ++; printf(\u0026#34;%d\\n\u0026#34;, cnt \u0026lt;\u0026lt; 1); return 0; } ","date":"2021-02-01T18:44:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc190/","title":"AtCoder Beginner Contest 190 A~D Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Slots\rProblem Statement\rGiven three uppercase English letters $C_1,C_2,C_3$, determine if they are all identical.\nInput Format\r$C_1C_2C_3$\nOutput Format\rPrint Won if $C_1,C_2,C_3$ are equal; otherwise, print Lost.\nSample\rInput Output SSS Won WVW Lost Analysis\rIf you can\u0026rsquo;t solve this problem, you might as well have not learned C++\u0026hellip;\nCode\rNote: Do not write Won as Yes or Lost as No!\n1 2 3 4 5 6 7 8 9 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { char a = getchar(), b = getchar(), c = getchar(); puts((a == b \u0026amp;\u0026amp; b == c)? \u0026#34;Won\u0026#34;: \u0026#34;Lost\u0026#34;); return 0; } B - Alcoholic\rProblem Statement\rA person will drink $N$ cups of alcohol in order. The $i$-th cup has $V_i$ milliliters with $P_i\\%$ alcohol content ($1\\le i\\le N$).\nHe gets drunk when the total alcohol consumed exceeds $X$ milliliters (consuming exactly $X$ milliliters won\u0026rsquo;t cause drunkenness).\nAfter drinking which cup will he get drunk for the first time?\n$1\\le N\\le 10^3$\n$0\\le X\\le 10^6$\n$1\\le V_i\\le 10^3$\n$0\\le P_i\\le 100$\nInput Format\r$N~X$\n$V_1~P_1$\n$\\vdots$\n$V_N~P_N$\nOutput Format\rPrint the cup number $i$ if he gets drunk after drinking the $i$-th cup. If he never gets drunk, print -1.\nSample\rSample Input1\r1 2 3 2 15 200 5 350 3 Sample Output1\r1 2 The first cup contains $200\\times5\\%=10$ ml of alcohol.\nThe second cup contains $350\\times3\\%=10.5$ ml of alcohol.\nAfter drinking the second cup, the total $20.5$ ml exceeds $15$ ml, so output $2$.\nSample Input2\r1 2 3 2 10 200 5 350 3 Sample Output2\r1 2 He doesn\u0026rsquo;t get drunk when exactly $X$ ml is consumed.\nSample Input3\r1 2 3 4 3 1000000 1000 100 1000 100 1000 100 Sample Output3\r1 -1 Seems he\u0026rsquo;s immune to alcohol\u0026hellip;\nAnalysis\rThe alcohol in the $i$-th cup is $V_i\\times P_i\\%$, i.e., $V_i\\times P_i/100$ ml.\nWe need to find the smallest $i$ where the cumulative sum exceeds $X$ ml. However, due to floating-point precision issues in C++, direct calculation may yield incorrect results.\n$$V_1\\times P_1 + V_2\\times P_2 + \\dots + V_i\\times P_i \u003e 100X$$\nThis allows integer arithmetic to avoid precision errors.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { int n, x; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;x); x *= 100; for(int i=1; i\u0026lt;=n; i++) { int v, p; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;v, \u0026amp;p); x -= v * p; if(x \u0026lt; 0) { printf(\u0026#34;%d\\n\u0026#34;, i); return 0; } } puts(\u0026#34;-1\u0026#34;); return 0; } C - Mandarin Orange\rProblem Statement\rThere are $N$ bowls arranged in a row. The $i$-th bowl contains $A_i$ oranges.\nTakahashi selects a triple $(l,r,x)$ satisfying:\n$1\\le l\\le r\\le N$ $x\\le A_i$ for all $l\\le i\\le r$ He eats $x$ oranges from each bowl between $l$ and $r$ (inclusive). Find the maximum number of oranges he can eat.\n$1\\le N\\le 10^4$\n$1\\le A_i\\le 10^5$\nInput Format\r$N$\n$A_1~\\dots~A_N$\nOutput Format\rPrint the maximum number of oranges.\nSample\rSample Input1\r1 2 6 2 4 4 9 4 9 Sample Output1\r1 20 Choosing $(2,6,4)$ yields $5\\times4=20$ oranges.\nSample Input2\r1 2 6 200 4 4 9 4 9 Sample Output2\r1 200 Choosing $(1,1,200)$ yields $200$ oranges.\nAnalysis\rFor each $(l,r)$, the optimal $x$ is the minimum $A_i$ in $[l,r]$. Compute $(r-l+1)\\times\\min(A_l,\\dots,A_r)$ for all possible $(l,r)$ and find the maximum.\nTime complexity: $\\mathcal O(n^2)$\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #define maxn 10005 #define INF 2147483647 using namespace std; int a[maxn]; inline void setmin(int\u0026amp; a, int b) {if(b \u0026lt; a) a = b;} inline void setmax(int\u0026amp; a, int b) {if(b \u0026gt; a) a = b;} int main(int argc, char** argv) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); int ans = 0; for(int l=0; l\u0026lt;n; l++) { int m = INF; for(int r=l; r\u0026lt;n; r++) { setmin(m, a[r]); setmax(ans, (r - l + 1) * m); } } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Logical Expression\rProblem Statement\rGiven $N$ strings $S_1,S_2,...,S_N$ (each being AND or OR), count the number of tuples $(x_0,x_1,...,x_N)$ satisfying:\n$x_i$ is $\\text{True}$ or $\\text{False}$ $y_0=x_0$ For $i\\ge 1$: $y_i=y_{i-1}\\land x_i$ if $S_i$ is AND, else $y_i=y_{i-1}\\lor x_i$ $1\\le N\\le 60$\nInput Format\r$N$\n$S_1$\n$\\vdots$\n$S_N$\nOutput Format\rPrint the count.\nSample\rSee original contest page for details.\nAnalysis\r$$f(N)=\\begin{cases} f(N-1) \u0026 (S_N=\\text{AND})\\\\\rf(N-1)\\times2^N \u0026 (S_N=\\text{OR})\r\\end{cases}$$\nThis allows efficient computation while processing input.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); char c[4]; long long ans = 1LL, x = 1LL; while(n--) { x \u0026lt;\u0026lt;= 1LL; scanf(\u0026#34;%s\u0026#34;, c); if(c[0] == \u0026#39;O\u0026#39;) ans ^= x; // Equivalent to ans += x; this is faster } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2021-01-25T15:47:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc189/","title":"AtCoder Beginner Contest 189 A~D Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Don\u0026rsquo;t be late\rProblem Statement\rTakahashi plans to meet Aoki.\nThey will meet at a location $D$ meters away from Takahashi\u0026rsquo;s house in $T$ minutes.\nTakahashi will leave immediately and walk towards the meeting point at a speed of $S$ meters per minute.\nCan Takahashi arrive on time?\n$1\\le D\\le 10000$\n$1\\le T\\le 10000$\n$1\\le S\\le 10000$\nInput Format\r$D~T~S$\nOutput Format\rPrint Yes if Takahashi arrives on time or early; otherwise print No.\nSamples\rD T S Output 1000 15 80 Yes 2000 20 100 Yes 10000 1 1 No Analysis\rCheck whether $\\frac D S\\le T$ (simplified as $TS\\ge D$).\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { int d, t, s; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;d, \u0026amp;t, \u0026amp;s); puts(t * s \u0026gt;= d? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Substring\rProblem Statement\rGiven two strings $S$ and $T$.\nModify some characters in $S$ (possibly none) to make $T$ a substring of $S$.\nWhat is the minimum number of characters to modify?\nSubstring: e.g., xxx is a substring of yxxxy but not of xxyxx.\n$1\\le |T|\\le |S|\\le 1000$\n$S$ and $T$ consist of lowercase English letters.\nInput Format\r$S~T$\nOutput Format\rPrint the minimum number of characters to modify.\nSamples\rSample Input1\r1 2 cabacc abc Sample Output1\r1 1 Sample Input2\r1 2 codeforces atcoder Sample Output2\r1 6 Analysis\rSlide $T$ over $S$ and find the position with the minimum number of differing characters.\nCode\rThis is essentially brute force enumeration :)\nNote: If following the code below, ensure to handle the case where $S$ and $T$ have equal lengths first!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;cstdio\u0026gt; #define maxn 1005 using namespace std; char s[maxn], t[maxn]; int main(int argc, char** argv) { scanf(\u0026#34;%s%s\u0026#34;, s, t); int tlen = 0, ans = maxn; for(; t[tlen]; tlen++); if(s[tlen] == \u0026#39;\\0\u0026#39;) { ans = 0; for(int i=0; i\u0026lt;tlen; i++) if(s[i] != t[i]) ans ++; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } for(int i=0; s[i+tlen]; i++) { int cnt = 0; for(int j=0; j\u0026lt;tlen; j++) if(s[i + j] != t[j]) cnt ++; if(cnt \u0026lt; ans) ans = cnt; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } C - Sum of product of pairs\rProblem Statement\rGiven $N$ integers $A_1,A_2,\\dots,A_N$.\nCompute ${\\sum\\limits_{i=1}^{N-1}\\sum\\limits_{j=i+1}^NA_iA_j} \\mod {(10^9+7)}$, i.e., the sum of products of all pairs $(i,j)$ where $1\\le i \\lt j\\le N$, modulo $(10^9 + 7)$.\nInput Format\r$N$\n$A_1~A_2~\\dots~A_N$\nOutput Format\rPrint the result.\nSamples\rSample Input1\r1 2 3 1 2 3 Sample Output1\r1 11 $1\\times2+1\\times3+2\\times3=11$.\nSample Input2\r1 2 4 141421356 17320508 22360679 244949 Sample Output2\r1 437235829 Don\u0026rsquo;t forget to take modulo $(10^9 + 7)$!\nAnalysis\r$${\\sum\\limits_{i=1}^{N-1}\\sum\\limits_{j=i+1}^NA_iA_j} \\mod {(10^9+7)}$$$${(\\sum\\limits_{i=2}^{N}\\sum\\limits_{j=0}^{i-1}A_iA_j)} \\mod {(10^9+7)}$$$${\\sum\\limits_{i=2}^{N}A_i(\\sum\\limits_{j=0}^{i-1}A_j)} \\mod {(10^9+7)}$$\nMaintain a cumulative sum while iterating through the array.\nCode\rProcess input incrementally.\nUse long long despite modulo operations:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;cstdio\u0026gt; #define maxn 200005 #define MOD 1000000007LL using namespace std; typedef long long LL; int main(int argc, char** argv) { int n; LL sum, res = 0LL; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;sum); while(--n) // Loop (n-1) times { LL x; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); res += sum * x; sum += x; res %= MOD, sum %= MOD; } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } D - Friends\rProblem Statement\rThere are $N$ people numbered $1$ to $N$.\nGiven $M$ relationships, where the $i$-th states \u0026ldquo;Person $A_i$ and $B_i$ are friends.\u0026rdquo; (may contain duplicates).\nIf $X$ and $Y$ are friends, and $Y$ and $Z$ are friends, then $X$ and $Z$ are friends.\nTakahashi wants to divide these people into groups where no two people in the same group are friends. What is the minimum number of groups required?\n$2\\le N\\le 2\\times10^5$\n$0\\le M\\le 2\\times10^5$\n$1\\le A_i,B_i\\le N$\n$A_i \\ne B_i$\nInput Format\r$N~M$\n$A_1~B_1$\n$A_2~B_2$\n$\\vdots$\n$A_M~B_M$\nOutput Format\rPrint the answer.\nSamples\rSample Input1\r1 2 3 4 5 3 1 2 3 4 5 1 Sample Output1\r1 3 Three groups: $\\{1,3\\}$, $\\{2,4\\}$, $\\{5\\}$.\nSample Input2\r1 2 3 4 5 6 7 8 9 10 11 4 10 1 2 2 1 1 2 2 1 1 2 1 3 1 4 2 3 2 4 3 4 Sample Output2\r1 4 Note duplicate relationships.\nSample Input3\r1 2 3 4 5 10 4 3 1 4 1 5 9 2 6 Sample Output3\r1 3 Analysis\rFind all connected components (friend circles) and output the size of the largest component.\nCode\rUse BFS/DFS or Union-Find to find connected components. Here BFS is implemented.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #define maxn 200005 using namespace std; vector\u0026lt;int\u0026gt; G[maxn]; bool vis[maxn]; int bfs(int x) { queue\u0026lt;int\u0026gt; q; q.push(x); int cnt = 0; while(!q.empty()) { x = q.front(); q.pop(); if(vis[x]) continue; vis[x] = true, cnt ++; for(int v: G[x]) q.push(v); } return cnt; } int main(int argc, char** argv) { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;m; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G[x].push_back(y); G[y].push_back(x); } int ans = bfs(0); for(int i=1; i\u0026lt;n; i++) if(!vis[i]) { int cnt = bfs(i); if(cnt \u0026gt; ans) ans = cnt; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","date":"2021-01-13T21:16:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc177/","title":"AtCoder Beginner Contest 177 A~D Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Three-Point Shot\rProblem Statement\rTwo teams have scores of $X$ and $Y$ points respectively. Determine if the team with fewer points can overtake the other after gaining three points.\n$0\\le X,Y\\le 100$\n$X \\ne Y$\n$X$ and $Y$ are integers.\nInput Format\r$X~Y$\nOutput Format\rPrint Yes if possible; otherwise, print No.\nSample\rX Y Output 3 5 Yes Analysis\rThis is straightforward: check if the difference between the two numbers is less than 3.\nCode\r1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(int argc, char** argv) { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); puts((abs(a - b) \u0026lt; 3)? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } B - Orthogonality\rProblem Statement\rGiven two arrays $A=\\{A_1,A_2,...,A_N\\}$ and $B=\\{B_1,B_2,...,B_N\\}$ of length $N$, determine if their dot product is zero. In other words, check if $\\sum\\limits_{i=1}^NA_iB_i = 0$.\n$1\\le N\\le 10^5$\n$-100\\le A_i,B_i\\le 100$ Note: Negative values may appear!\nInput Format\r$N$\n$A_1~A_2~...~A_N$\n$B_1~B_2~...~B_N$\nOutput Format\rPrint Yes if the dot product is zero; otherwise, print No.\nSamples\rSample Input 1\r1 2 3 2 -3 6 4 2 Sample Output 1\r1 Yes $N = 2$\n$A = \\{-3,6\\}$\n$B = \\{4,2\\}$\nDot product: $(-3)\\times4 + 6\\times2 = 0$, so output Yes.\nSample Input 2\r1 2 3 2 4 5 -1 -3 Sample Output 2\r1 No $N = 2$\n$A = \\{4,5\\}$\n$B = \\{-1,-3\\}$\nDot product: $4\\times(-1) + 5\\times(-3) = -19$, so output No.\nSample Input 3\r1 2 3 3 1 3 5 3 -6 3 Sample Output 3\r1 Yes $N = 3$\n$A = \\{1,3,5\\}$\n$B = \\{3,-6,3\\}$\nDot product: $1\\times3 + 3\\times(-6) + 5\\times3 = 0$, so output Yes.\nAnalysis\rCompute the dot product directly as described.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 using namespace std; int a[maxn]; int main(int argc, char** argv) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); int res = 0; for(int i=0; i\u0026lt;n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); res += x * a[i]; } puts(res == 0? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } C - ABC Tournament\rProblem Statement\rThere are $2^N$ players, each with a unique rank $A_i$. The tournament consists of $N$ knockout rounds. Determine the index of the runner-up (the player eliminated in the final round).\n$1\\le N\\le 16$\n$1\\le A_i \\le 10^9$\nAll $A_i$ are distinct.\nInput Format\r$N$\n$A_1~A_2~...~A_{2^N}$\nOutput Format\rPrint the index of the runner-up.\nSamples\rSample Input 1\r1 2 2 1 4 2 5 Sample Output 1\r1 2 Players: 1,4,2,5\nRound 1: 1 vs 4 (4 wins), 2 vs 5 (5 wins)\nRound 2: 4 vs 5 (5 wins). Runner-up: 2 (eliminated in round 2).\nSample Input 2\r1 2 2 3 1 5 4 Sample Output 2\r1 1 Players: 3,1,5,4\nRound 1: 3 vs 1 (3 wins), 5 vs 4 (5 wins)\nRound 2: 3 vs 5 (5 wins). Runner-up: 1 (eliminated in round 2).\nSample Input 3\r1 2 4 6 13 12 5 3 7 10 11 16 9 8 15 2 1 14 4 Sample Output 3\r1 2 Blogger‚Äôs note: Manual calculation shows that simply sorting and selecting the second-highest value is incorrect!\nAnalysis\rSimulate the tournament using a queue. Track pairs of (rank, index) and compare adjacent pairs in each round. The final two elements determine the runner-up.\nCode\rNotes:\nUse long long for ranks. Use pair to track indices. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; using LL = long long; using pli = pair\u0026lt;LL, int\u0026gt;; int main(int argc, char** argv) { queue\u0026lt;pli\u0026gt; q; int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); n = 1 \u0026lt;\u0026lt; n; for(int i=1; i\u0026lt;=n; i++) { LL x; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); q.emplace(x, i); } while(q.size() \u0026gt; 2) { pli x = q.front(); q.pop(); pli y = q.front(); q.pop(); if(x \u0026lt; y) q.push(y); else q.push(x); } pli x = q.front(); q.pop(); pli y = q.front(); printf(\u0026#34;%d\\n\u0026#34;, x \u0026lt; y? x.second: y.second); return 0; } D - Snuke Prime\rProblem Statement\rTakahashi uses $N$ services. Each service $i$ costs $c_i$ yuan per day, active from day $a_i$ to $b_i$ inclusive. Alternatively, a subscription service costs $C$ yuan per day, granting unlimited access. Determine the minimum total cost.\n$1\\le N\\le 2\\times 10^5$\n$1\\le C\\le 10^9$\n$1\\le a_i\\le b_i\\le 10^9$\n$1\\le c_i\\le 10^9$\nInput Format\r$N~C$\n$a_1~b_1~c_1$\n$a_2~b_2~c_2$\n$...$\n$a_N~b_N~c_N$\nOutput Format\rPrint the minimum total cost.\nSamples\rSample Input 1\r1 2 3 2 6 1 2 4 2 2 4 Sample Output 1\r1 10 Sample Input 2\r1 2 3 4 5 6 5 1000000000 583563238 820642330 44577 136809000 653199778 90962 54601291 785892285 50554 5797762 453599267 65697 468677897 916692569 87409 Sample Output 2\r1 163089627821228 Optimal solution: Do not use the subscription.\nSample Input 3\r1 2 3 4 5 6 5 100000 583563238 820642330 44577 136809000 653199778 90962 54601291 785892285 50554 5797762 453599267 65697 468677897 916692569 87409 Sample Output 3\r1 88206004785464 Custom Sample\rInput:\n1 2 3 2 7 1 3 5 2 6 4 Output:\n1 31 Subscribe on days 2 and 3.\nAnalysis\rSplit each service into two events: $(a_i-1, +c_i)$ and $(b_i, -c_i)$. Sort events by time. Track the daily cost (fee) and compute the minimum cost for each interval between events using min(C, fee).\nCode\rNotes:\nUse long long for all variables. Use pair to store events. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long LL; typedef pair\u0026lt;LL, LL\u0026gt; pll; int main(int argc, char** argv) { int n; LL c; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;c); priority_queue\u0026lt;pll, vector\u0026lt;pll\u0026gt;, greater\u0026lt;pll\u0026gt; \u0026gt; q; while(n--) { LL x, y, z; scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); q.emplace(--x, z); q.emplace(y, -z); } LL ans = 0LL, fee = 0LL, last = 0LL; while(!q.empty()) { auto [day, cost] = q.top(); q.pop(); if(last != day) { ans += min(c, fee) * (day - last); last = day; } fee += cost; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } Alternative code for compatibility:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long LL; typedef pair\u0026lt;LL, LL\u0026gt; pll; int main(int argc, char** argv) { int n; LL c; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;c); priority_queue\u0026lt;pll, vector\u0026lt;pll\u0026gt;, greater\u0026lt;pll\u0026gt; \u0026gt; q; while(n--) { LL x, y, z; scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); q.push(pll(--x, z)); q.push(pll(y, -z)); } LL ans = 0LL, fee = 0LL, last = 0LL; while(!q.empty()) { LL day = q.top().first, cost = q.top().second; q.pop(); if(last != day) { ans += min(c, fee) * (day - last); last = day; } fee += cost; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2021-01-13T16:25:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc188/","title":"AtCoder Beginner Contest 188 A~D Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Large Digits\rProblem Statement\rGiven two three-digit integers $A$ and $B$, find the maximum of their digit sums.\nDigit Sum: For example, the digit sum of $123$ is $1+2+3=6$.\nConstraints:\n$100\\le A,B\\le 999$\nInput Format\r$A~~B$\nOutput Format\rOutput the maximum digit sum of $A$ and $B$.\nSample\rInput Output 123 234 9 593 953 17 100 999 27 Analysis\rDirectly implement as per the problem description.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(int argc, char** argv) { char a[10], b[10]; scanf(\u0026#34;%s%s\u0026#34;, a, b); int as = 0, bs = 0; for(int i=0; a[i]; i++) as += a[i] - \u0026#39;0\u0026#39;; for(int i=0; b[i]; i++) bs += b[i] - \u0026#39;0\u0026#39;; printf(\u0026#34;%d\\n\u0026#34;, max(as, bs)); return 0; } B - Gentle Pairs\rProblem Statement\rThere are $N$ points with coordinates $(x_i,y_i)$, where all $x$-coordinates are distinct.\nHow many pairs of points satisfy $-1 \\le \\text{slope} \\le 1$?\nConstraints:\n$1\\le N\\le 10^3$\n$|x_i|,|y_i|\\le 10^3$\n$x_i \\ne x_j$ ($i \u003c j$)\nInput Format\r$N$\n$x_1~y_1$\n$\\vdots$\n$x_n~y_n$\nOutput Format\rOutput the answer.\nSample\rSample Input1\r1 2 3 4 3 0 0 1 2 2 1 Sample Output1\r1 2 There are three points: $(0,0)$, $(1,2)$, and $(2,1)$.\nFrom $(0,0)$ to $(1,2)$, slope is $2$; From $(0,0)$ to $(2,1)$, slope is $\\frac{1}{2}$; From $(1,2)$ to $(2,1)$, slope is $-1$. There are 2 valid pairs.\nSample Input2\r1 2 1 -691 273 Sample Output2\r1 0 Only one point exists. Output $0$.\nSample Input3\r1 2 3 4 5 6 7 8 9 10 11 10 -31 -35 8 -36 22 64 5 73 -14 8 18 -58 -41 -85 1 -88 -21 -85 -11 82 Sample Output3\r1 11 Analysis\r$$-1 \\le \\frac{y_1-y_2}{x_1-x_2} \\le 1$$$$|\\frac{y_1-y_2}{x_1-x_2}| \\le 1$$$$|y_1-y_2|\\le|x_1-x_2|$$\nWe use integer operations to avoid floating-point errors.\nCode\rEnumerate all pairs.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #define maxn 1005 using namespace std; int x[maxn], y[maxn]; inline bool slope_check(int x1, int y1, int x2, int y2) { int dx = abs(x1 - x2), dy = abs(y1 - y2); return dy \u0026lt;= dx; } int main(int argc, char** argv) { int n, cnt = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d%d\u0026#34;, x + i, y + i); for(int i=0; i\u0026lt;n-1; i++) for(int j=i+1; j\u0026lt;n; j++) if(slope_check(x[i], y[i], x[j], y[j])) cnt ++; printf(\u0026#34;%d\\n\u0026#34;, cnt); return 0; } C - 1-SAT\rProblem Statement\rGiven $N$ strings $S_1,S_2,...,S_N$. Each string consists of lowercase letters and may have at most one ! at the beginning.\nFind any string $S$ such that both $S$ and !+$S$ exist in the list. If none exist, output satisfiable.\nConstraints:\n$1\\le N\\le 10^5$\n$1\\le |S_i|\\le 10$\nInput Format\r$N$\n$S_1$\n$\\vdots$\n$S_N$\nOutput Format\rIf a valid string exists, output any such string.\nOtherwise, output satisfiable.\nSample\rSample Input1\r1 2 3 4 5 6 7 6 a !a b !c d !d Sample Output1\r1 a $S_1$ is a and $S_2$ is !a, so $S_1$ is valid.\n$S_5$ is d and $S_6$ is !d, so d is also a valid output.\nSample Input2\r1 2 3 4 5 6 7 8 9 10 11 10 red red red !orange yellow !blue cyan !green brown !gray Sample Output2\r1 satisfiable No valid string exists.\nAnalysis\rA brute-force $\\mathcal O(N^2)$ approach is infeasible.\nOptimization:\nStore strings starting with ! (after removing !) in a set. Check other strings against this set in $\\mathcal O(\\log N)$ per query.\nOverall complexity: $\\mathcal O(N\\log N)$. Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;string\u0026gt; v; set\u0026lt;string\u0026gt; s; int main(int argc, char** argv) { ios::sync_with_stdio(false); cin.tie(0); int n; cin \u0026gt;\u0026gt; n; while(n--) { string x; cin \u0026gt;\u0026gt; x; if(x[0] == \u0026#39;!\u0026#39;) s.insert(x.substr(1)); else v.push_back(x); } for(int i=0; i\u0026lt;v.size(); i++) if(s.find(v[i]) != s.end()) { cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; \u0026#34;satisfiable\\n\u0026#34;; return 0; } D - Choose Me\rProblem Statement\rRefer to the original problem page for details.\nConstraints:\n$1\\le N\\le 10^5$\n$1\\le A_i,B_i\\le 10^9$\nInput Format\r$N$\n$A_1~B_1$\n$\\vdots$\n$A_N~B_N$\nOutput Format\rOutput the minimum number of cities to visit.\nSample\rSample Input1\r1 2 3 4 5 4 2 1 2 2 5 1 1 3 Sample Output1\r1 1 After visiting the third city, Aoki gets 5 votes and Takahashi gets 6.\nSample Input2\r1 2 3 4 5 6 5 2 1 2 1 2 1 2 1 2 1 Sample Output2\r1 3 Visiting any three cities gives Aoki 4 votes and Takahashi 9.\nSample Input3\r1 2 1 273 691 Sample Output3\r1 1 Analysis\rOur goal is to minimize the vote difference. Initially, the difference is the sum of all $A_i$.\nEach city $i$ reduces the difference by $2A_i + B_i$. We greedily select cities with the largest reduction first using a priority queue.\nCode\rNote: Must use long long to avoid overflow.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; typedef long long LL; priority_queue\u0026lt;LL\u0026gt; q; int main(int argc, char** argv) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); LL diff = 0; while(n--) { LL ao, ta; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;ao, \u0026amp;ta); diff += ao; q.push(ao + ao + ta); } int ans = 0; while(!q.empty()) { ans ++; if((diff -= q.top()) \u0026lt; 0) { printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } q.pop(); } return 0; } ","date":"2021-01-03T14:06:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc187/","title":"AtCoder Beginner Contest 187 A~D Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Payment\rProblem Statement\rIf paying with a ¬•1000 banknote (assuming available), how much change will the clerk return when paying for an item costing ¬•N?\n$1\\le N\\le 10000$\nInput Format\r$N$\nOutput Format\rSingle line with the change amount.\nSamples\rInput Output 1900 100 3000 0 Analysis\rSpecial cases:\nIf $N$ is divisible by 1000, output 0. Otherwise, output $1000 - (n\\mod1000)$. Code\r1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if(n % 1000 == 0) puts(\u0026#34;0\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;, 1000 - n % 1000); return 0; } B - Judge Status Summary\rProblem Statement\rA user solved a programming problem, receiving test results in four statuses: AC, WA, TLE, RE. Given $N$ test cases with results $S_1, S_2, \\dots, S_N$, count and output the occurrences of each status.\n$1\\le N\\le 10^5$\nEach $S_i$ is AC, WA, TLE, or RE.\nInput Format\r$N$\n$S_1$\n$S_2$\n$:$\n$S_N$\nOutput Format\r1 2 3 4 AC x [AC count] WA x [WA count] TLE x [TLE count] RE x [RE count] Note: Use lowercase \u0026lsquo;x\u0026rsquo; instead of \u0026lsquo;√ó\u0026rsquo;!\nSamples\rSample Input 1\r1 2 3 4 5 6 7 6 AC TLE AC AC WA TLE Sample Output 1\r1 2 3 4 AC x 3 WA x 1 TLE x 2 RE x 0 Counts: 3, 1, 2, 0 respectively.\nSample Input 2\r1 2 3 4 5 6 7 8 9 10 11 10 AC AC AC AC AC AC AC AC AC AC Sample Output 2\r1 2 3 4 AC x 10 WA x 0 TLE x 0 RE x 0 All test cases passed.\nAnalysis\rThough other methods exist, we use map for simplicity (may be overkill).\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; map\u0026lt;string, int\u0026gt; cnt; int main(int argc, char** argv) { ios::sync_with_stdio(false); int n; cin\u0026gt;\u0026gt;n; for(int i=0; i\u0026lt;n; i++) { string s; cin\u0026gt;\u0026gt;s; cnt[s] ++; } cout\u0026lt;\u0026lt;\u0026#34;AC x \u0026#34;\u0026lt;\u0026lt;cnt[\u0026#34;AC\u0026#34;]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;WA x \u0026#34;\u0026lt;\u0026lt;cnt[\u0026#34;WA\u0026#34;]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;TLE x \u0026#34;\u0026lt;\u0026lt;cnt[\u0026#34;TLE\u0026#34;]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;RE x \u0026#34;\u0026lt;\u0026lt;cnt[\u0026#34;RE\u0026#34;]\u0026lt;\u0026lt;endl; return 0; } C - H and V\rProblem Statement\rGiven a grid with $H$ rows and $W$ columns. Cell $(i,j)$ ($1\\le i\\le H$, $1\\le j\\le W$) is either # (black) or . (white). Select any rows and columns to paint red. How many selection methods leave exactly $K$ black cells?\n$1\\le H, W\\le 6$\n$1\\le K\\le HW$\nInput Format\r$H~W~K$\n$c_{1,1}~c_{1,2}~\\dots~c_{1,W}$\n$c_{2,1}~c_{2,2}~\\dots~c_{2,W}$\n$\\vdots$\n$c_{H,1}~c_{H,2}~\\dots~c_{H,W}$\nOutput Format\rSingle line with the valid method count.\nSamples\rSample Input 1\r1 2 3 2 3 2 ..# ### Sample Output 1\r1 5 Five methods involving row 1 and/or columns 1-3.\nSample Input 2\r1 2 3 2 3 4 ..# ### Sample Output 2\r1 1 Only possible by selecting nothing.\nSample Input 3\r1 2 3 2 2 3 ## ## Sample Output 3\r1 0 Impossible.\nSample Input 4\r1 2 3 4 5 6 7 6 6 8 ..##.. .#..#. #....# ###### #....# #....# Blogger\u0026rsquo;s note: This is the largest test case. Local runtime check ensures no TLE.\nSample Output 4\r1 208 Analysis\rBrute-force enumeration using bitmasking. Paint selected rows/columns to white (.), then count remaining black cells.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define maxn 6 using namespace std; char c[maxn][maxn]; int h, w, k; int cnt = 0; int main(int argc, char** argv) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;h, \u0026amp;w, \u0026amp;k); for(int i=0; i\u0026lt;h; i++) scanf(\u0026#34;%s\u0026#34;, c[i]); int m1 = 1 \u0026lt;\u0026lt; h, m2 = 1 \u0026lt;\u0026lt; w, ans = 0; for(int hs=0; hs\u0026lt;m1; hs++) for(int ws=0; ws\u0026lt;m2; ws++) { char tmp[maxn][maxn]; // Cannot modify original, make copy memcpy(tmp, c, sizeof(c)); for(int i=0; i\u0026lt;h; i++) // Rows if(hs \u0026amp; (1 \u0026lt;\u0026lt; i)) for(int j=0; j\u0026lt;w; j++) tmp[i][j] = \u0026#39;.\u0026#39;; for(int i=0; i\u0026lt;w; i++) // Columns if(ws \u0026amp; (1 \u0026lt;\u0026lt; i)) for(int j=0; j\u0026lt;h; j++) tmp[j][i] = \u0026#39;.\u0026#39;; // NOT tmp[i][j]! int cnt = 0; for(int i=0; i\u0026lt;h; i++) for(int j=0; j\u0026lt;w; j++) if(tmp[i][j] == \u0026#39;#\u0026#39;) cnt ++; if(cnt == k) ans ++; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } D - Chat in a Circle\rProblem Statement\r$N$ people arrive sequentially to form a circle. Each person\u0026rsquo;s comfort equals the smaller friendliness value of their immediate neighbors (first person gets 0). Maximize total comfort.\n$2\\le N\\le 2\\times10^5$\n$1\\le A_i\\le 10^9$\nInput Format\r$N$\n$A_1~A_2~\\dots~A_N$\nOutput Format\rSingle line with maximum total comfort.\nSamples\rSample Input 1\r1 2 4 2 2 1 3 Sample Output 1\r1 7 Comfort sum: 0+3+2+2=7.\nSample Input 2\r1 2 7 1 1 1 1 1 1 1 Sample Output 2\r1 6 Analysis\rGreedy approach: Sort descending, insert each person into position yielding maximum current comfort. Use priority queue.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 200005 using namespace std; int a[maxn], n; struct Position { int lf, rf, comfort; inline Position(int l, int r) { lf = l, rf = r; comfort = min(l, r); } inline bool operator\u0026lt;(const Position\u0026amp; p) const { return comfort \u0026lt; p.comfort; } }; priority_queue\u0026lt;Position\u0026gt; q; inline bool cmp(int x, int y) {return x \u0026gt; y;} int main(int argc, char** argv) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); sort(a, a + n, cmp); q.push(Position(a[0], a[1])); long long res = a[0]; for(int i=2; i\u0026lt;n; i++) { Position p = q.top(); if(q.size() \u0026gt; 1) q.pop(); res += p.comfort; q.push(Position(a[i], p.lf)); q.push(Position(a[i], p.rf)); } printf(\u0026#34;%lld\\n\u0026#34;, res); return 0; } ","date":"2020-07-20T11:59:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc173/","title":"AtCoder Beginner Contest 173 A~D Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Problem Analysis\rPossible issues with package upgrades or uninstallations related to spyder dependencies.\nAfter upgrading PyQt5 to version 5.15, conflicts occurred since spyder requires PyQt5\u0026lt;5.13, causing startup failures.\nSolution\rOpen Anaconda Prompt and execute:\n1 pip install spyder Explanation:\npip automatically installs dependency-compatible packages. For example, when installing spyder (which requires PyQt5\u0026lt;5.13), pip detects the installed PyQt5 5.15 and downgrades to the highest compatible version (PyQt5 5.12.3, the latest version below 5.13).\n20210923 EDIT:\nIf encountering \u0026ldquo;Access Denied\u0026rdquo; errors, add the --user option.\n","date":"2020-07-12T16:03:00+08:00","permalink":"https://goodcoder666.github.io/en/p/spyderfix/","title":"Resolving Anaconda Spyder Unresponsive Click Issue"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed The Python package management tool pip often suffers from slow speeds and frequent download errors. You can use Tsinghua University\u0026rsquo;s mirror site to replace the default download source. Both methods below work on any computer. Demonstration is performed on Windows 10 Version 1909.\nTemporary Method\rUse the mirror temporarily when installing packages via pip (command line):\n1 pip install \u0026lt;package-name\u0026gt; -i https://pypi.tuna.tsinghua.edu.cn/simple Permanent Method\rOpen command line and execute:\n1 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 1.1MB/s 2.2MB/s 6.8MB/s\nP.S. I found $N$ articles online all suggesting to manually create pip.ini files\u0026hellip;\n","date":"2020-07-12T14:56:00+08:00","permalink":"https://goodcoder666.github.io/en/p/pypi-tsmirror/","title":"Solving Slow pip Downloads (Using Tsinghua Mirror)"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A - Œ±lphabet\rProblem Summary\rInput an English letter $a$ and determine whether it is uppercase or lowercase.\nInput Format\r$a$\nOutput Format\rIf $a$ is lowercase, output a;\nIf $a$ is uppercase, output A.\nSample Input 1\r1 B Sample Output 1\r1 A Since B is uppercase, output A.\nSample Input 2\r1 a Sample Output 2\r1 a Since a is lowercase, output a.\nCode\r1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { char a = getchar(); if(\u0026#39;a\u0026#39; \u0026lt;= a \u0026amp;\u0026amp; a \u0026lt;= \u0026#39;z\u0026#39;) putchar(\u0026#39;a\u0026#39;); else putchar(\u0026#39;A\u0026#39;); return 0; } B - Mix Juice\rProblem Summary\rGiven an array $p_1, p_2, p_3, ..., p_N$ of length $N$, select $K$ elements such that their sum is minimized.\n$1\\le K\\le N\\le 1000$\n$1\\le p_i\\le 1000$ ($1\\le i\\le N$)\nInput Format\r$N K$\n$p_1~p_2~p_3~\\dots~p_N$\nOutput Format\rOne line containing the minimal sum.\nSample Input 1\r1 2 5 3 50 100 80 120 80 The minimal sum is $50+80+80=210$.\nSample Output 1\r1 210 Since B is uppercase, output A.\nSample Input 2\r1 2 1 1 1000 Sample Output 2\r1 1000 Only one element exists, so the minimal sum is $1000$. (Note added by author)\nCode\rTo minimize the sum, select the $K$ smallest elements in the array. Use the sort() function from \u0026lt;algorithm\u0026gt; to sort the array in ascending order, then sum the first $K$ elements.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #define maxn 1005 using namespace std; int a[maxn]; int main(int argc, char** argv) { int n, k, sum = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, a + i); sort(a, a + n); for(int i=0; i\u0026lt;k; i++) sum += a[i]; printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; } C - One Quadrillion and One Dalmatians\rProblem Summary\rThere are $1000000000000001$ ($10^{15}+1$) dogs named as:\na, b, .., z, aa, ab, .., az, ba, bb, .., bz, .., za, zb, .., zz, aaa, aab, .., aaz, aba, abb, .., abz, \u0026hellip;, zzz, aaaa, \u0026hellip;\nQuestion: What is the name of the $N$-th dog?\n$1\\le N\\le 10^{15}+1$\nInput Format\r$N$\nOutput Format\rOne line containing the name of the $N$-th dog.\nSamples\rMultiple samples are consolidated into a table for brevity:\nInput Output 2 b 27 aa 123456789 jjddja Code\rThis is equivalent to converting a decimal number to a base-26 representation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #define BASE 26LL using namespace std; int main(int argc, char** argv) { char s[12]; int cnt = 0; long long n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); while(n \u0026gt; 0) { n --; s[cnt++] = n % BASE + \u0026#39;a\u0026#39;; n /= BASE; } for(int i=cnt-1; i\u0026gt;=0; i--) putchar(s[i]); putchar(\u0026#39;\\n\u0026#39;); return 0; } D - Replacing\rProblem Summary\rGiven an array $A_1, A_2, \\dots, A_N$, perform $Q$ operations:\nIn the $i$-th operation, replace all occurrences of $B_i$ with $C_i$. Output the sum of all elements in $A$ after each operation (denoted as $S_i$). $1\\le N, Q, A_i, B_i, C_i\\le 10^5$ ($1\\le i\\le N$)\n$B_i\\ne C_i$\nInput Format\r$N$\n$A_1~A_2~...~A_N$\n$Q$\n$B_1~C_1$\n$B_2~C_2$\n$:$\n$B_Q~C_Q$\nOutput Format\r$S_1$\n$S_2$\n$:$\n$S_N$\nSample Input 1\r1 2 3 4 5 6 4 1 2 3 4 3 1 2 3 4 2 4 Sample Output 1\r1 2 3 11 12 16 Step Array $A$ Initial $\\{1, 2, 3, 4\\}$ $i=1$ $\\{2, 2, 3, 4\\}$ $i=2$ $\\{2, 2, 4, 4\\}$ $i=3$ $\\{4, 4, 4, 4\\}$ Sample Input 2\r1 2 3 4 5 6 4 1 1 1 1 3 1 2 2 1 3 5 Note: $B_i$ may not exist in the array.\nSample Output 2\r1 2 3 8 4 4 Sample Input 3\r1 2 3 4 5 6 2 1 2 3 1 100 2 100 100 1000 Sample Output 3\r1 2 3 102 200 2000 Code\rUse an array to track the frequency of each value in $A$. Also maintain the total sum of the array.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 using namespace std; typedef long long LL; int cnt[maxn]; LL sum = 0; inline LL s(const LL\u0026amp; i) { return cnt[i] * i; } int main(int argc, char** argv) { int n, q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i=0; i\u0026lt;n; i++) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); sum += t; cnt[t] ++; } scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while(q--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); sum -= s(x) + s(y); cnt[y] += cnt[x]; cnt[x] = 0; sum += s(y); printf(\u0026#34;%lld\\n\u0026#34;, sum); } return 0; } ","date":"2020-06-22T15:50:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc171/","title":"AtCoder Beginner Contest 171 A~D Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Recently (as of 2020/6/1 18:40 when this article was written), the pandemic situation has improved in China but continues to rage in the United States. This article will crawl COVID-19 data for the US from Tencent\u0026rsquo;s platform and generate charts.\nData Crawling\rCalling the API\rAPI endpoint: https://api.inews.qq.com/newsqa/v1/automation/modules/list?modules=FAutoCountryMerge\nObserving the retrieved data:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { ..., \u0026#34;data\u0026#34;: { \u0026#34;FAutoCountryMerge\u0026#34;: { ..., \u0026#34;ÁæéÂõΩ\u0026#34;: { \u0026#34;showDash\u0026#34;:false, \u0026#34;list\u0026#34;: [ {\u0026#34;date\u0026#34;:\u0026#34;01.28\u0026#34;,\u0026#34;confirm_add\u0026#34;:0,\u0026#34;confirm\u0026#34;:5,\u0026#34;heal\u0026#34;:0,\u0026#34;dead\u0026#34;:0}, ..., {\u0026#34;date\u0026#34;:\u0026#34;05.29\u0026#34;,\u0026#34;confirm_add\u0026#34;:25069,\u0026#34;confirm\u0026#34;:1768461,\u0026#34;heal\u0026#34;:510713,\u0026#34;dead\u0026#34;:103330}, {\u0026#34;date\u0026#34;:\u0026#34;05.30\u0026#34;,\u0026#34;confirm_add\u0026#34;:23290,\u0026#34;confirm\u0026#34;:1793530,\u0026#34;heal\u0026#34;:519569,\u0026#34;dead\u0026#34;:104542}, {\u0026#34;date\u0026#34;:\u0026#34;05.31\u0026#34;,\u0026#34;confirm_add\u0026#34;:20350,\u0026#34;confirm\u0026#34;:1816820,\u0026#34;heal\u0026#34;:535238,\u0026#34;dead\u0026#34;:105557}, {\u0026#34;date\u0026#34;:\u0026#34;06.01\u0026#34;,\u0026#34;confirm_add\u0026#34;:20350,\u0026#34;confirm\u0026#34;:1837170,\u0026#34;heal\u0026#34;:599867,\u0026#34;dead\u0026#34;:106195} ] }, ... } } } As shown in the code above, to get pandemic data for a country, use:\n1 json[\u0026#39;data\u0026#39;][\u0026#39;FAutoCountryMerge\u0026#39;][\u0026#39;\u0026lt;country name\u0026gt;\u0026#39;][\u0026#39;list\u0026#39;] For US data:\n1 json[\u0026#39;data\u0026#39;][\u0026#39;FAutoCountryMerge\u0026#39;][\u0026#39;ÁæéÂõΩ\u0026#39;][\u0026#39;list\u0026#39;] Code\rThe real implementation:\n1 2 3 4 from requests import get url = \u0026#39;https://api.inews.qq.com/newsqa/v1/automation/modules/list?modules=FAutoCountryMerge\u0026#39; data = get(url).json()[\u0026#39;data\u0026#39;][\u0026#39;FAutoCountryMerge\u0026#39;][\u0026#39;ÁæéÂõΩ\u0026#39;][\u0026#39;list\u0026#39;] Data Processing\rThe result in Python is a list object:\n1 2 3 4 5 6 7 8 [ {\u0026#34;date\u0026#34;:\u0026#34;01.28\u0026#34;,\u0026#34;confirm_add\u0026#34;:0,\u0026#34;confirm\u0026#34;:5,\u0026#34;heal\u0026#34;:0,\u0026#34;dead\u0026#34;:0}, ..., {\u0026#34;date\u0026#34;:\u0026#34;05.29\u0026#34;,\u0026#34;confirm_add\u0026#34;:25069,\u0026#34;confirm\u0026#34;:1768461,\u0026#34;heal\u0026#34;:510713,\u0026#34;dead\u0026#34;:103330}, {\u0026#34;date\u0026#34;:\u0026#34;05.30\u0026#34;,\u0026#34;confirm_add\u0026#34;:23290,\u0026#34;confirm\u0026#34;:1793530,\u0026#34;heal\u0026#34;:519569,\u0026#34;dead\u0026#34;:104542}, {\u0026#34;date\u0026#34;:\u0026#34;05.31\u0026#34;,\u0026#34;confirm_add\u0026#34;:20350,\u0026#34;confirm\u0026#34;:1816820,\u0026#34;heal\u0026#34;:535238,\u0026#34;dead\u0026#34;:105557}, {\u0026#34;date\u0026#34;:\u0026#34;06.01\u0026#34;,\u0026#34;confirm_add\u0026#34;:20350,\u0026#34;confirm\u0026#34;:1837170,\u0026#34;heal\u0026#34;:599867,\u0026#34;dead\u0026#34;:106195} ] This object contains daily US pandemic data:\ndate: From January 28 to present\nconfirm_add: Daily new confirmed cases\nconfirm: Cumulative confirmed cases\nheal: Cumulative recovered cases\ndead: Cumulative deaths\nData Filtering\rKey filtering steps:\nRemove confirm_add (daily new cases) as it\u0026rsquo;s less useful Add now_confirm (current confirmed cases) to track active infections, calculated as confirm - heal - dead Final data structure:\ndate: From January 28 to present\nconfirm_add: Daily new confirmed cases\nconfirm: Cumulative confirmed cases\nheal: Cumulative recovered cases\ndead: Cumulative deaths\nnow_confirm: Current confirmed cases\nCode\rTo improve chart quality, we start from the 35th data point. Modify to data instead of data[35:] to use all data.\n1 2 3 4 5 6 7 8 9 10 11 12 dates = [] confirms = [] now_confirms = [] heals = [] deads = [] for day_data in data[35:]: dates.append(day_data[\u0026#39;date\u0026#39;]) confirms.append(day_data[\u0026#39;confirm\u0026#39;]) heals.append(day_data[\u0026#39;heal\u0026#39;]) deads.append(day_data[\u0026#39;dead\u0026#39;]) now_confirms.append(confirms[-1] - heals[-1] - deads[-1]) Visualization\rReference: https://www.cnblogs.com/lone5wolf/p/10870200.html\n(Apologies for basic visualization implementation)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import matplotlib.pyplot as plt from matplotlib.font_manager import FontProperties plt.figure(figsize=(11.4, 7.7)) confirm_line, = plt.plot(dates, confirms, color=\u0026#39;#8B0000\u0026#39;) now_confirm_line, = plt.plot(dates, now_confirms, color=\u0026#39;red\u0026#39;, linestyle=\u0026#39;:\u0026#39;) heal_line, = plt.plot(dates, heals, color=\u0026#39;green\u0026#39;, linestyle=\u0026#39;--\u0026#39;) dead_line, = plt.plot(dates, deads, color=\u0026#39;black\u0026#39;, linestyle=\u0026#39;-.\u0026#39;) my_font = FontProperties(fname=r\u0026#39;fonts\\msyh.ttc\u0026#39;) plt.legend(handles=[confirm_line, now_confirm_line, heal_line, dead_line], labels=[\u0026#39;Cumulative Confirmed\u0026#39;, \u0026#39;Current Confirmed\u0026#39;, \u0026#39;Recovered\u0026#39;, \u0026#39;Deaths\u0026#39;], prop=my_font) plt.xlabel(\u0026#39;Date\u0026#39;, fontproperties=my_font) plt.ylabel(\u0026#39;Number of Cases\u0026#39;, fontproperties=my_font) plt.title(\u0026#39;US 2019-nCoV Pandemic Situation\u0026#39;, fontproperties=my_font) plt.gca().xaxis.set_major_locator(plt.MultipleLocator(7)) plt.savefig(\u0026#39;AmericaNCovData.png\u0026#39;) plt.show() Result\rComplete Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # -*- coding: utf-8 -*- from requests import get import matplotlib.pyplot as plt from matplotlib.font_manager import FontProperties url = \u0026#39;https://api.inews.qq.com/newsqa/v1/automation/modules/list?modules=FAutoCountryMerge\u0026#39; data = get(url).json()[\u0026#39;data\u0026#39;][\u0026#39;FAutoCountryMerge\u0026#39;][\u0026#39;ÁæéÂõΩ\u0026#39;][\u0026#39;list\u0026#39;] dates = [] confirms = [] now_confirms = [] heals = [] deads = [] for day_data in data[35:]: dates.append(day_data[\u0026#39;date\u0026#39;]) confirms.append(day_data[\u0026#39;confirm\u0026#39;]) heals.append(day_data[\u0026#39;heal\u0026#39;]) deads.append(day_data[\u0026#39;dead\u0026#39;]) now_confirms.append(confirms[-1] - heals[-1] - deads[-1]) plt.figure(figsize=(11.4, 7.7)) confirm_line, = plt.plot(dates, confirms, color=\u0026#39;#8B0000\u0026#39;) now_confirm_line, = plt.plot(dates, now_confirms, color=\u0026#39;red\u0026#39;, linestyle=\u0026#39;:\u0026#39;) heal_line, = plt.plot(dates, heals, color=\u0026#39;green\u0026#39;, linestyle=\u0026#39;--\u0026#39;) dead_line, = plt.plot(dates, deads, color=\u0026#39;black\u0026#39;, linestyle=\u0026#39;-.\u0026#39;) my_font = FontProperties(fname=r\u0026#39;fonts\\msyh.ttc\u0026#39;) plt.legend(handles=[confirm_line, now_confirm_line, heal_line, dead_line], labels=[\u0026#39;Cumulative Confirmed\u0026#39;, \u0026#39;Current Confirmed\u0026#39;, \u0026#39;Recovered\u0026#39;, \u0026#39;Deaths\u0026#39;], prop=my_font) plt.xlabel(\u0026#39;Date\u0026#39;, fontproperties=my_font) plt.ylabel(\u0026#39;Number of Cases\u0026#39;, fontproperties=my_font) plt.title(\u0026#39;US 2019-nCoV Pandemic Situation\u0026#39;, fontproperties=my_font) plt.gca().xaxis.set_major_locator(plt.MultipleLocator(7)) plt.savefig(\u0026#39;AmericaNCovData.png\u0026#39;) plt.show() Code download: GitHub\n","date":"2020-06-03T13:35:00+08:00","permalink":"https://goodcoder666.github.io/en/p/pws-tencent-us-19ncov/","title":"[Python Web Scraping] Crawling US COVID-19 Data from Tencent API + Generating Charts"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed The problem titles in this contest are unique, composed of symbols + (+English+) :)\nC - : (Colon)\rProblem Statement\rAt $A$ hours and $B$ minutes, what is the distance between the tips of the hour hand of length $H$ centimeters and the minute hand of length $M$ centimeters?\n$1\\le A, B\\le 1000$\n$0\\le H\\le 11$\n$0\\le M\\le 59$\n(Floating-point precision errors up to $10^{-9}$ are allowed)\nInput Format\r$A~B~H~M$\nOutput Format\rA single line with the distance between the two points.\nSamples\rSample Input 1\r1 3 4 9 0 Sample Output 1\r1 5.00000000000000000000 Sample Input 2\r1 3 4 10 40 Sample Output 2\r1 4.56425719433005567605 Analysis\r$$C^2=A^2+B^2-2AB\\cos\\theta$$\nNote: In C/C++, the parameter of the cos function is in radians. If Œ∏ is in degrees, use cos(theta / 180 * PI).\nCode\rFinally, the code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #define PI 3.1415926535897932 using namespace std; int main(int argc, char** argv) { int a, b, h, m; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;h, \u0026amp;m); int mangle = m * 6; double hangle = h * 30 + m * 0.5; double theta = abs(hangle - mangle); if(theta \u0026gt; 180) theta = 360 - theta; theta = theta / 180 * PI; printf(\u0026#34;%.13lf\\n\u0026#34;, sqrt(double(a * a + b * b) - 2.0 * a * b * cos(theta))); return 0; } D - . . (Double Dots)\rProblem Statement\rA cave has $N$ rooms and $M$ passages.\nRooms are numbered $1$ to $N$, passages are numbered $1$ to $M$. Each passage bidirectionally connects rooms $A_i$ and $B_i$ ($1\\le i\\le M$). Room $1$ is the exit.\nEach room (except room $1$) must have a sign pointing to an adjacent room. Following these signs from any room must yield the shortest path to the exit.\n$2\\le N\\le 10^5$\n$1\\le M\\le 2 \\times 10^5$\n$1\\le A_i, B_i\\le N$ ($1\\le i\\le M$)\n$A_i‚â†B_i$ ($1\\le i\\le M$)\nInput Format\r$N~M$\n$A_1~B_1$\n$\\vdots$\n$A_M~B_M$\nOutput Format\rIf no solution exists, output No.\nIf a solution exists:\nFirst line: Yes Line $i$: The room number pointed by the sign in room $i$ ($2\\le i\\le N$). Analysis\rClearly a BFS problem. Note: If the cave is disconnected, there is no solution.\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #define UNVISITED -1 #define maxn 100005 using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; vector\u0026lt;int\u0026gt; G[maxn]; int par[maxn]; int main(int argc, char** argv) { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=0; i\u0026lt;n; i++) par[i] = UNVISITED; for(int i=0; i\u0026lt;m; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G[--x].push_back(--y); G[y].push_back(x); } queue\u0026lt;pii\u0026gt; q; q.push(pii(0, -1)); while(!q.empty()) { int room = q.front().first, p = q.front().second; q.pop(); if(par[room] != UNVISITED) continue; par[room] = p; for(int i=0; i\u0026lt;G[room].size(); i++) q.push(pii(G[room][i], room)); } for(int i=1; i\u0026lt;n; i++) if(par[i] == UNVISITED) { puts(\u0026#34;No\u0026#34;); return 0; } puts(\u0026#34;Yes\u0026#34;); for(int i=1; i\u0026lt;n; i++) printf(\u0026#34;%d\\n\u0026#34;, par[i] + 1); return 0; } ","date":"2020-05-19T19:24:00+08:00","permalink":"https://goodcoder666.github.io/en/p/abc168/","title":"AtCoder Beginner Contest 168 Problems C~D Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Note: If the reader hasn\u0026rsquo;t learned about functions defined with def, please refer to here first\nDefinition Syntax\r1 \u0026lt;function_name\u0026gt; = lambda \u0026lt;parameters\u0026gt;: \u0026lt;return_value\u0026gt; Equivalent to:\n1 2 def \u0026lt;function_name\u0026gt;(\u0026lt;parameters\u0026gt;): return \u0026lt;return_value\u0026gt; Can also be defined as anonymous function (nameless function):\n1 lambda \u0026lt;parameters\u0026gt;: \u0026lt;return_value\u0026gt; We can confirm that lambda function objects have the same type (function) as those defined with def:\nInvocation\rFor anonymous functions, the invocation form is:\n1 (lambda \u0026lt;parameters\u0026gt;: \u0026lt;return_value\u0026gt;)(\u0026lt;arguments\u0026gt;) For named functions:\n1 \u0026lt;function_name\u0026gt;(\u0026lt;arguments\u0026gt;) Function to calculate $a+b$:\nNo Return Value\rlambda functions can also have no return value.\nExample:\nLambda functions without return value are generally used for performing actions, such as print('Hello World') etc.\n","date":"2020-04-21T18:32:00+08:00","permalink":"https://goodcoder666.github.io/en/p/python-lambda-functions/","title":"Python Functions: Lambda Functions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Links\rWant to study Python functions? see here\nHow to name functions? see here\nAlternative ways to pass parameters? see here\nI. Functions Without Parameters\rStructure\r1 2 3 def \u0026lt;function_name\u0026gt;(): # Mandatory \u0026lt;function_body\u0026gt; # Optional return \u0026lt;return_value\u0026gt; # Optional Example Program\rHello world program using functions:\n1 2 3 4 5 6 7 8 9 10 11 # prints \u0026#39;Hello World\\nDone\u0026#39; # Author: GoodCoder666 def getHelloWorldString(): return \u0026#39;Hello World\u0026#39; def print_hello_world(): print(getHelloWorldString()) print_hello_world() print(\u0026#39;Done\u0026#39;) # Output: # Hello World # Done Program Flow\r1 2 3 4 5 6 7 8 9 flowchat st=\u0026gt;start: Start: Call print_hello_world() e=\u0026gt;end: End get_str_call=\u0026gt;operation: print_hello_world() calls getHelloWorldString() return_str=\u0026gt;operation: getHelloWorldString() returns \u0026#39;Hello World\u0026#39; print_hi=\u0026gt;inputoutput: Return to print_hello_world(), output Hello World done=\u0026gt;inputoutput: Return to main program, output Done st-\u0026gt;get_str_call-\u0026gt;return_str-\u0026gt;print_hi-\u0026gt;done-\u0026gt;e II. Functions With Parameters\rPrerequisite Knowledge\rParameters: Values passed to the function, equivalent to variables within the function:\n1 2 3 4 def param_test(a, b): a, b = b, a print(a, b) param_test(5, 6) # Output: 6 5 This program is equivalent to:\n1 2 3 4 5 6 def param_test(): a, b = 5, 6 #-----Same below-----# a, b = b, a print(a, b) param_test() # Output: 6 5 Structure\r1 2 3 def \u0026lt;function_name\u0026gt;(\u0026lt;parameter_list\u0026gt;): # Mandatory \u0026lt;function_body\u0026gt; # Optional return \u0026lt;return_value\u0026gt; # Optional The parameter list uses commas to separate parameters, e.g., a, b or c (write directly if only one parameter).\nExample Program\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 # prints \u0026#39;Hi, {name}!\u0026#39; # Author: GoodCoder666 def get_greet_str(name): return \u0026#39;Hi, \u0026#39; + name + \u0026#39;!\u0026#39; def greet(name): print(get_greet_str(name)) greet(input(\u0026#34;What\u0026#39;s your name? \u0026#34;)) print(\u0026#39;Done\u0026#39;) # Input: GoodCoder666 # Output: # Hi, GoodCoder666! # Done Program Flow\r1 2 3 4 5 6 7 8 9 flowchat st=\u0026gt;start: Start: Call input(\u0026#34;What\u0026#39;s your name?\u0026#34;) e=\u0026gt;end: End call_greet=\u0026gt;operation: input returns username, call greet(\u0026lt;username\u0026gt;) call_get_greet_str=\u0026gt;operation: greet calls get_greet_str(\u0026lt;username\u0026gt;) print_hi=\u0026gt;inputoutput: Return to get_greet_str, output its return value done=\u0026gt;inputoutput: Return to main program, output Done st-\u0026gt;call_greet-\u0026gt;call_get_greet_str-\u0026gt;print_hi-\u0026gt;done-\u0026gt;e Functions Are Objects\rA function is also an object.\nProof\rDefine two functions first:\n1 2 3 4 def a(a, b): return a + b def b(): return a(1, 2) Item Supported/Exists Proof Assignment Y c = a works; c becomes callable Attributes Y type(a) returns class \u0026lt;'function'\u0026gt; Type Y ","date":"2020-04-21T13:22:00+08:00","permalink":"https://goodcoder666.github.io/en/p/python-def-functions/","title":"Python Functions: Defining Functions with def"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Core rules for naming:\nAllowed characters: A-Z a-z\nUnderscore: _\nDigits: 0-9 (Note: digits cannot be at the beginning)\n==Chinese variable names are theoretically allowed but strongly discouraged.==\nValid name examples\r1 2 3 abcdef\tGoodCoder\tAD_fhrygfuigfr A_a_007\t__NAME123\t_P_T_ _123456\tCc_Dd\t_ Invalid name examples\r1 2 3 666Code\tC++\t1+1=2\t(5)4 654ty54F\t0.123\t123456@qq.com ccf-csp\tatcoder\u0026amp;codeforces Naming styles\rFirst letter is usually lowercase (except for classes).\nSince spaces are not allowed in object names, there are two common styles:\n1 2 helloWorldStr = \u0026#39;Hello World\u0026#39; hello_world_str = \u0026#39;Hello World\u0026#39; helloWorldStr style: Capitalize the first letter of each word except the first hello_world_str style: Separate words with underscores Special case: Classes\rExample:\n1 2 3 class AppleTree: def dropApple(): print(\u0026#39;Apple dropped to the ground.\u0026#39;) AppleTree style: Capitalize the first letter of every word (including the first).\n","date":"2020-04-20T22:03:00+08:00","permalink":"https://goodcoder666.github.io/en/p/python-naming-standards/","title":"„ÄêPython„ÄëObject (Including Classes, Functions) Naming Conventions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Recently started learning Java and using the classic Eclipse IDE, but found the download speed too slow\u0026hellip;\nProblem Analysis\rEclipse downloads rely on third-party mirrors, which (on my machine) default to a North Korean mirror (defaults may vary across devices):\nClick Select Another Mirror:\nSelect a Chinese mirror:\n","date":"2020-04-10T19:48:00+08:00","permalink":"https://goodcoder666.github.io/en/p/eclipseinstmirrors/","title":"How to Solve Slow Eclipse Installation Package Downloads"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Recently tried to update Eclipse using the Help -\u0026gt; Check For Updates feature in this popular Java IDE, but it always reports no updates found:\nCheck for Available Updates\rFirst, visit the Eclipse Download Page to get the latest version (currently 2020-06):\nThen check your local Eclipse version (Help -\u0026gt; About Eclipse IDE):\nIf the online version matches your current version (as shown), then System.exit(0);\u0026hellip; Don\u0026rsquo;t blame Eclipse unnecessarily\u0026hellip;\nFix Detection Failure When Updates Exist\rOpen the \u0026ldquo;Available Software Sites\u0026rdquo; window:\nMethod 1: Click the \u0026ldquo;available software sites\u0026rdquo; link in the prompt window:\nMethod 2: Navigate to Window -\u0026gt; Prefrences -\u0026gt; Install/Update -\u0026gt; available software sites:\nLocate Latest Eclipse Release, check the red-dotted entry, click Apply and Close, then recheck updates.\n","date":"2020-04-08T22:12:00+08:00","permalink":"https://goodcoder666.github.io/en/p/eclipseupdmirror/","title":"Eclipse Check For Updates Always Fails to Find Updates - Solution"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed For the \u0026lt;\u0026lt; and \u0026gt;\u0026gt; operators, we can state:\n$a\u003c","date":"2020-04-04T10:41:00+08:00","permalink":"https://goodcoder666.github.io/en/p/java-binmove/","title":"Integer Shift Operators in Java"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed I. final Classes and Methods\rOfficial Documentation\rSource: Java Official Documentation -\u0026gt; Writing Final Classes and Methods\nYou can declare some or all of a class\u0026rsquo;s methods final. You use the final keyword in a method declaration to indicate that the method cannot be overridden by subclasses. The Object class does this‚Äîa number of its methods are final.\nYou might wish to make a method final if it has an implementation that should not be changed and it is critical to the consistent state of the object. For example, you might want to make the getFirstPlayer method in this ChessAlgorithm class final:\n1 2 3 4 5 6 7 8 class ChessAlgorithm { enum ChessPlayer { WHITE, BLACK } ... final ChessPlayer getFirstPlayer() { return ChessPlayer.WHITE; } ... } Methods called from constructors should generally be declared final. If a constructor calls a non-final method, a subclass may redefine that method with surprising or undesirable results.\nNote that you can also declare an entire class final. A class that is declared final cannot be subclassed. This is particularly useful, for example, when creating an immutable class like the String class.\nSummary\rA final Java class or method cannot be inherited.\nExamples\rClass (Integer source code):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package java.lang; import java.lang.annotation.Native; // import ... import static java.lang.String.UTF16; public final class Integer extends Number // Final class cannot be inherited, but can extend or implement other non-final classes implements Comparable\u0026lt;Integer\u0026gt;, Constable, ConstantDesc { @Native public static final int MIN_VALUE = 0x80000000; @Native public static final int MAX_VALUE = 0x7fffffff; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static final Class\u0026lt;Integer\u0026gt; TYPE = (Class\u0026lt;Integer\u0026gt;) Class.getPrimitiveClass(\u0026#34;int\u0026#34;); // Omitted n lines here /** use serialVersionUID from JDK 1.0.2 for interoperability */ @Native private static final long serialVersionUID = 1360826667806852920L; } Method:\n1 2 3 4 5 6 7 8 class ChessAlgorithm { enum ChessPlayer { WHITE, BLACK } // ... final ChessPlayer getFirstPlayer() { // Cannot be overridden, but can be called return ChessPlayer.WHITE; } // ... } II. final Attributes/Variables\rfinal attributes or variables in Java are similar to const variables in C/C++ and cannot be modified.\nExamples:\n1 2 3 4 5 6 7 8 9 public class Information { private static final int WIDTH = 170, HEIGHT = 135; // final attribute, can be private public static final int SIZE = WIDTH * HEIGHT; // can also be public public int getDifference() { final int difference = WIDTH - HEIGHT; // final variable in method return difference; } } ","date":"2020-04-01T14:40:00+08:00","permalink":"https://goodcoder666.github.io/en/p/java-final-syntax/","title":"Java final Keyword Syntax"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Recently encountered an issue while developing a Java game when handling images:\nComplete Error\r1 2 3 Exception in thread \u0026#34;AWT-EventQueue-0\u0026#34; java.lang.IllegalArgumentException: input == null! at java.desktop/javax.imageio.ImageIO.read(ImageIO.java:1356) at ImageIOTest.main.\u0026lt;init\u0026gt;(main.java:23) Code Snippet\r1 BufferedImage img = ImageIO.read(getClass().getResourceAsStream(FILENAME)); Solution\rSearched online and found many answers saying it\u0026rsquo;s incorrect image path. But I\u0026rsquo;ve checked the image path $555n$ times and found no issues:\nSo? Dead end?\nActually, modifying the code like this fixes it:\n1 BufferedImage img = ImageIO.read(new File(FILENAME)); ","date":"2020-03-29T17:39:00+08:00","permalink":"https://goodcoder666.github.io/en/p/java-image-iaein-solve/","title":"java.lang.IllegalArgumentException: input == null! Solution"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Problem\rtkinter.Text calls to edit_undo() and edit_redo() have no effect.\nAnalysis\rThis occurs because the undo parameter of Text is not set to True. Only after setting this can edit_undo() and edit_redo() be \u0026ldquo;activated\u0026rdquo;.\nThis error is difficult to detect since it doesn\u0026rsquo;t throw an error message. Discovered after extensive research\u0026hellip;\nHope the Python official team can improve this aspect in the future.\nSolution\r1 2 3 4 5 6 7 8 9 10 11 12 from tkinter import * root = Tk() root.title(\u0026#39;Undo/redo test\u0026#39;) text = Text(root, undo=True) # ^^^^^^^^^ # Important! text.insert(END, \u0026#39;Hello tkinter!\u0026#39;) text.edit_undo() text.edit_redo() root.mainloop() ","date":"2020-03-24T19:37:00+08:00","permalink":"https://goodcoder666.github.io/en/p/tkinter-text-undo-redo/","title":"Solution for tkinter Text edit_undo()/edit_redo() Not Working"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Problem Statement\rGiven three integers $a$, $b$, and $c$, output Yes if $\\sqrt a + \\sqrt b \u003c \\sqrt c$ holds, otherwise output No.\nExamples\rSample Input #1\r1 2 3 9 Sample Output #1\r1 No $\\sqrt 2 + \\sqrt 3 \u003c \\sqrt 9$ does not hold.\nSample Input #2\r1 2 3 10 Sample Output #2\r1 Yes $\\sqrt 2 + \\sqrt 3 \u003c \\sqrt 10$ holds.\nAnalysis\rIncorrect Approach\rDirectly using the system\u0026rsquo;s sqrt function with floating-point precision errors will result in wrong answers:\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main(int argc, char** argv) { int a, b, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); double d = sqrt(double(a)) + sqrt(double(b)); puts(d * d \u0026lt; c? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } This approach requires special handling to avoid precision issues!\nCorrect Approach\rDerivation steps:\n$\\sqrt a + \\sqrt b \u003c \\sqrt c$\n$(\\sqrt a + \\sqrt b)^2 \u003c (\\sqrt c)^2$\n$a + b + 2\\sqrt{ab} \u003c c$\n$2\\sqrt{ab} \u003c c - a - b$\n$(2\\sqrt{ab})^2 \u003c (c - a - b)^2$\n$4ab \u003c (c - a - b)^2$\nNote: An additional case occurs when $c - a - b \u003c 0$ (i.e., $c \u003c a + b$), which should directly output No. Failure to consider this will result in WA, as $(c - a - b)^2$ ignores negative values!\nSolution Code\r1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;cstdio\u0026gt; using namespace std; int main(int argc, char** argv) { long long a, b, c; scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); long long d = c - a - b; if(d \u0026lt; 0) puts(\u0026#34;No\u0026#34;); // Special case when c - a - b \u0026lt; 0 directly output No else puts((d * d \u0026gt; 4LL * a * b)? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); return 0; } ","date":"2020-03-16T14:17:00+08:00","permalink":"https://goodcoder666.github.io/en/p/panasonic2020-c/","title":"Panasonic Programming Contest 2020 C (Sqrt Inequality) Solution"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed I. *[parameter name]\rCalling\rValid Calls\rRegular Call\r*parameter name is usually written as *args, e.g.:\n1 2 def func(*args): print(args) Try calling func:\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; func(1) (1,) \u0026gt;\u0026gt;\u0026gt; func() () \u0026gt;\u0026gt;\u0026gt; func(1, 2, 3) (1, 2, 3) \u0026gt;\u0026gt;\u0026gt; func(dict(), set(), str(), int()) ({}, set(), \u0026#39;\u0026#39;, 0) Thus, we observe that such functions can accept any number of arguments (including 0). * packs the arguments into a tuple, such as (1,), (), (1, 2, 3), ({}, set(), '', 0).\nSpecial Call\rIf there\u0026rsquo;s already a tuple object to pass as args:\nFirst define a tuple object:\n1 2 3 \u0026gt;\u0026gt;\u0026gt; tuple_object = (1, 2, 3) \u0026gt;\u0026gt;\u0026gt; print(tuple_object) (1, 2, 3) Wrong Approach\rCommon mistake:\n1 2 \u0026gt;\u0026gt;\u0026gt; func(tuple_object) ((1, 2, 3),) ((1, 2, 3),)? Shouldn\u0026rsquo;t it be (1, 2, 3)?\nThe system treats it as a single argument in args, resulting in a \u0026ldquo;tuple within tuple\u0026rdquo; scenario. OH NO!\nCorrect Approach\rAdd * before tuple_object:\n1 2 \u0026gt;\u0026gt;\u0026gt; func(*tuple_object) (1, 2, 3) This is called \u0026ldquo;unpacking\u0026rdquo;.\nInvalid Calls\rTrying func(a=1, b=2):\n1 \u0026gt;\u0026gt;\u0026gt; func(a=1, b=2) Triggers TypeError:\n1 2 3 4 Traceback (most recent call last): File \u0026#34;\u0026lt;*args test file\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; func(a=1, b=2) TypeError: func() got an unexpected keyword argument \u0026#39;a\u0026#39; What\u0026rsquo;s a keyword argument?\nkeyword argument refers to parameter passing in name=value format. Simply put, keyword argument means passing parameters as name=value pairs. Thus, only positional arguments (value-only format) should be used here.\nDefault Parameters\rParameters with *[parameter name] cannot have default values:\nAs shown, setting default parameters causes SyntaxError. To simulate default values:\n1 2 3 4 5 6 # Manually set default values for *args DEFAULT_VALUE = (1, 2, 3) # Customizable default def func(*args): if args == (): # If empty (no arguments passed): args = DEFAULT_VALUE print(args) Now it has default behavior:\n1 2 \u0026gt;\u0026gt;\u0026gt; func() # No arguments (1, 2, 3) Summary\r*[parameter name] indicates using positional arguments, accepts any number of arguments, packs them into a tuple. Special call: *[tuple object] Cannot set default parameters directly; requires manual default handling. II. **[parameter name]\rCalling\rValid Calls\rRegular Call\r**parameter name is usually written as **kwargs, e.g.:\n1 2 def func(**kwargs): # kwargs = keyword arguments print(kwargs) Calling func requires name=value format (hence kwargs):\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; func(a=1, b=2, c=3, d=4) {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3, \u0026#39;d\u0026#39;: 4} \u0026gt;\u0026gt;\u0026gt; func(_tuple_obj=tuple(), _set_obj=set(), _dict_obj=dict()) {\u0026#39;_tuple_obj\u0026#39;: (), \u0026#39;_set_obj\u0026#39;: set(), \u0026#39;_dict_obj\u0026#39;: {}} \u0026gt;\u0026gt;\u0026gt; func() {} Such functions accept any number of keyword arguments (including 0), packing them into a dict, such as {'a': 1, 'b': 2, 'c': 3, 'd': 4}, {'_tuple_obj': (), '_set_obj': set(), '_dict_obj': {}}, {}.\nSpecial Call\rIf there\u0026rsquo;s a dict object to pass as kwargs:\nDefine the object:\n1 2 3 \u0026gt;\u0026gt;\u0026gt; dict_object = {\u0026#39;a\u0026#39;: 666, \u0026#39;b\u0026#39;: 888} \u0026gt;\u0026gt;\u0026gt; print(dict_object) {\u0026#39;a\u0026#39;: 666, \u0026#39;b\u0026#39;: 888} Then:\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; func(dict_object) # Fails due to positional argument: Traceback (most recent call last): File \u0026#34;\u0026lt;**kwargs test program\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; func(dict_object) TypeError: func() takes 0 positional arguments but 1 was given \u0026gt;\u0026gt;\u0026gt; func(**dict_object) # Correct approach {\u0026#39;a\u0026#39;: 666, \u0026#39;b\u0026#39;: 888} Invalid Calls\rPassing positional arguments:\n1 \u0026gt;\u0026gt;\u0026gt; func(1, 2) Triggers TypeError:\n1 2 3 4 Traceback (most recent call last): File \u0026#34;\u0026lt;**kwargs test program\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; func(1, 2) TypeError: func() takes 0 positional arguments but 2 were given Only keyword arguments are allowed here.\nDefault Parameters\rSimilar to *args, use manual default handling:\n1 2 3 4 5 6 # Manually set default values for **kwargs DEFAULT_VALUE = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} # Customizable default def func(**kwargs): if kwargs == {}: # If empty (no arguments passed): kwargs = DEFAULT_VALUE print(kwargs) Now it has default behavior:\n1 2 \u0026gt;\u0026gt;\u0026gt; func() # No arguments {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} Summary\r**[parameter name] indicates using keyword arguments, accepts any number of name=value pairs, packs them into a dict. Special call: **[dict object] Cannot set default parameters directly; requires manual default handling. ","date":"2020-03-03T19:19:00+08:00","permalink":"https://goodcoder666.github.io/en/p/python-functions-argpack/","title":"Usage of *[parameter name] and **[parameter name] in Python Functions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed A. Cow and Haybales\rProblem Statement\rThe USA Construction Operation (USACO) recently ordered Farmer John to arrange a row of n haybale piles on the farm. The $i$-th pile contains $a_i$ haybales.\nHowever, Farmer John has just left for vacation, leaving Bessie all on her own. Every day, Bessie the naughty cow can choose to move one haybale in any pile to an adjacent pile. Formally, in one day she can choose any two indices $i$ and $j$ ($1\\le i,j\\le n$) such that $|i‚àíj|=1$ and $a_i \u003e 0$ and apply $a_i=a_i‚àí1$, $a_j = a_j + 1$. She may also decide to not do anything on some days because she is lazy.\nBessie wants to maximize the number of haybales in pile $1$ (i.e. to maximize $a_1$), and she only has $d$ days to do so before Farmer John returns. Help her find the maximum number of haybales that may be in pile $1$ if she acts optimally!\nInput\rThe input consists of multiple test cases. The first line contains an integer $t$ ($1\\le t\\le 100$) ‚Äî the number of test cases. Next $2t$ lines contain a description of test cases ‚Äî two lines per test case.\nThe first line of each test case contains integers $n$ and $d$ ($1\\le n,d\\le 100$) ‚Äî the number of haybale piles and the number of days, respectively.\nThe second line of each test case contains $n$ integers $a_1,a_2,\\dots,a_n$ $(0\\le a_i\\le 100)$ ‚Äî the number of haybales in each pile.\nOutput\rFor each test case, output one integer: the maximum number of haybales that may be in pile $1$ after $d$ days if Bessie acts optimally.\nSample\rInput\r1 2 3 4 5 6 7 3 4 5 1 0 3 2 2 2 100 1 1 8 0 Output\r1 2 3 3 101 0 Notes\rIn the first test case of the sample, this is one possible way Bessie can end up with $3$ haybales in pile $1$:\nOn day one, move a haybale from pile $3$ to pile $2$ On day two, move a haybale from pile $3$ to pile $2$ On day three, move a haybale from pile $3$ to pile $1$ On day four, move a haybale from pile $2$ to pile $1$ On day five, do nothing In the second test case of the sample, Bessie can do nothing on the first day and move a haybale from pile $2$ to pile $1$ on the second day.\nApproach\rGreedy Algorithm: Transfer haybales from the second pile to the first, then the third pile to the first, and so on.\nThe sample explanation might be slightly misleading (:(\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;cstdio\u0026gt; #define maxn 105 using namespace std; inline int min(int a, int b) { return a \u0026lt; b? a: b; } int main(int argc, char** argv) { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while(T--) { int n, d, first; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;d, \u0026amp;first); for(int i=1; i\u0026lt;n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if(d \u0026gt;= i) { int num = min(d / i, x); // The max number of haybales bessie can take to pile 1 d -= num * i; first += num; } } printf(\u0026#34;%d\\n\u0026#34;, first); } return 0; } B. Cow and Friend\rProblem Statement\rBessie has way too many friends because she is everyone\u0026rsquo;s favorite cow! Her new friend Rabbit is trying to hop over so they can play!\nMore specifically, he wants to get from $(0,0)$ to $(x,0)$ by making multiple hops. He is only willing to hop from one point to another point on the 2D plane if the Euclidean distance between the endpoints of a hop is one of its n favorite numbers: $a_1,a_2,‚Ä¶,a_n$. What is the minimum number of hops Rabbit needs to get from $(0,0)$ to $(x,0)$? Rabbit may land on points with non-integer coordinates. It can be proved that Rabbit can always reach his destination.\nRecall that the Euclidean distance between points $(x_i,y_i)$ and $(x_j,y_j)$ is $\\sqrt{(x_i‚àíx_j)^2+(y_i‚àíy_j)^2}$.\nFor example, if Rabbit has favorite numbers 1 and 3 he could hop from $(0,0)$ to $(4,0)$ in two hops as shown below. Note that there also exists other valid ways to hop to $(4,0)$ in $2$ hops (e.g. $(0,0)\\to(2, \\sqrt 5)\\to(4,0)$).\nHere is a graphic for the first example. Both hops have distance $3$, one of Rabbit\u0026rsquo;s favorite numbers.\nIn other words, each time Rabbit chooses some number $a_i$ and hops with distance equal to $a_i$ in any direction he wants. The same number can be used multiple times.\nInput\rThe input consists of multiple test cases. The first line contains an integer $t$ ($1\\le t\\le 1000$) ‚Äî the number of test cases. Next $2t$ lines contain test cases ‚Äî two lines per test case.\nThe first line of each test case contains two integers $n$ and $x$ ($1\\le n\\le 10^5$, $1\\le x\\le 10^9$) ‚Äî the number of favorite numbers and the distance Rabbit wants to travel, respectively.\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1\\le a_i \\le 10^9$) ‚Äî Rabbit\u0026rsquo;s favorite numbers. It is guaranteed that the favorite numbers are distinct.\nIt is guaranteed that the sum of $n$ over all the test cases will not exceed $10^5$.\nOutput\rFor each test case, print a single integer ‚Äî the minimum number of hops needed.\nSample\rInput\r1 2 3 4 5 6 7 8 9 4 2 4 1 3 3 12 3 4 5 1 5 5 2 10 15 4 Output\r1 2 3 4 2 3 1 2 Notes\rThe first test case of the sample is shown in the picture above. Rabbit can hop to $(2, \\sqrt 5)$, then to $(4,0)$ for a total of two hops. Each hop has a distance of $3$, which is one of his favorite numbers.\nIn the second test case of the sample, one way for Rabbit to hop $3$ times is: $(0,0) ‚Üí (4,0) ‚Üí (8,0) ‚Üí (12,0)$.\nIn the third test case of the sample, Rabbit can hop from $(0,0)$ to $(5,0)$.\nIn the fourth test case of the sample, Rabbit can hop: $(0,0) ‚Üí (5,10\\sqrt2) ‚Üí (10,0)$.\nApproach\rPure mathematics!!!\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 using namespace std; int fav[maxn], n, d; int calc(int x) { int tm = d / x, leftdist = d % x; if(leftdist == 0) return tm; if(tm == 0) { for(int i=0; i\u0026lt;n; i++) if(fav[i] == leftdist) return 1; return 2; } return tm + 1; } int main(int argc, char** argv) { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while(T--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;d); int maxf = -1; for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d\u0026#34;, fav + i); if(fav[i] \u0026gt; maxf) maxf = fav[i]; } printf(\u0026#34;%d\\n\u0026#34;, calc(maxf)); } return 0; } C. Cow and Message\rProblem Statement\rBessie the cow has just intercepted a text that Farmer John sent to Burger Queen! However, Bessie is sure that there is a secret message hidden inside.\nThe text is a string $S$ of lowercase Latin letters. She considers a string $t$ as hidden in string $S$ if $t$ exists as a subsequence of $S$ whose indices form an arithmetic progression. For example, the string aab is hidden in string aaabb because it occurs at indices $1$, $3$, and $5$, which form an arithmetic progression with a common difference of $2$. Bessie thinks that any hidden string that occurs the most times is the secret message. Two occurrences of a subsequence of $S$ are distinct if the sets of indices are different. Help her find the number of occurrences of the secret message!\nFor example, in the string aaabb, a is hidden $3$ times, b is hidden $2$ times, ab is hidden $6$ times, aa is hidden $3$ times, bb is hidden $1$ time, aab is hidden $2$ times, aaa is hidden $1$ time, abb is hidden $1$ time, aaab is hidden $1$ time, aabb is hidden $1$ time, and aaabb is hidden $1$ time. The number of occurrences of the secret message is $6$.\nInput\rThe first line contains a string $S$ of lowercase Latin letters ($1\\le |S|\\le 10^5$) ‚Äî the text that Bessie intercepted.\nOutput\rOutput a single integer ‚Äî the number of occurrences of the secret message.\nSample\rInput #1\r1 aaabb Output #1\r1 6 Input #2\r1 usaco Output #2\r1 1 Input #3\r1 lol Output #3\r1 2 Notes\rIn the first example, these are all the hidden strings and their indice sets:\na occurs at $(1), (2), (3)$ b occurs at $(4), (5)$ ab occurs at $(1,4), (1,5), (2,4), (2,5), (3,4), (3,5)$ aa occurs at $(1,2), (1,3), (2,3)$ bb occurs at $(4,5)$ aab occurs at $(1,3,5), (2,3,4)$ aaa occurs at $(1,2,3)$ abb occurs at $(3,4,5)$ aaab occurs at $(1,2,3,4)$ aabb occurs at $(2,3,4,5)$ aaabb occurs at $(1,2,3,4,5)$\nNote that all the sets of indices are arithmetic progressions. In the second example, no hidden string occurs more than once.\nIn the third example, the hidden string is the letter l.\nApproach\rDynamic Programming\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;cstdio\u0026gt; #define maxn 100005 #define let 26 using namespace std; typedef long long LL; char s[maxn], c; LL cnt1[let][maxn], cnt2[let][let]; int main(int argc, char** argv) { cnt1[(s[0] = getchar()) - \u0026#39;a\u0026#39;][0] ++; int slen = 1; while((c = getchar()) != \u0026#39;\\n\u0026#39;) { s[slen] = c; for(int i=0; i\u0026lt;let; i++) cnt1[i][slen] = cnt1[i][slen - 1]; cnt1[c - \u0026#39;a\u0026#39;][slen++] ++; } int last = slen - 1; for(int i=0; i\u0026lt;let; i++) if(cnt1[i][last]) { cnt2[i][i] = cnt1[i][last] * (cnt1[i][last] - 1) \u0026gt;\u0026gt; 1; for(int j=0; j\u0026lt;slen; j++) if(s[j] != i + \u0026#39;a\u0026#39;) cnt2[i][s[j] - \u0026#39;a\u0026#39;] += cnt1[i][last] - cnt1[i][j]; } LL maxcnt = -1; for(int i=0; i\u0026lt;let; i++) { if(cnt1[i][last] \u0026amp;\u0026amp; cnt1[i][last] \u0026gt; maxcnt) maxcnt = cnt1[i][last]; for(int j=0; j\u0026lt;let; j++) if(cnt2[i][j] \u0026amp;\u0026amp; cnt2[i][j] \u0026gt; maxcnt) maxcnt = cnt2[i][j]; } printf(\u0026#34;%lld\\n\u0026#34;, maxcnt); return 0; } ","date":"2020-02-22T23:20:00+08:00","permalink":"https://goodcoder666.github.io/en/p/cf1307/","title":"CodeForces Round #621 ABC (1307A+1307B+1307C) Solutions"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Generate random real numbers in $[0,1)$, i.e., $0\\le\\text{Math.random()} \u003c 1$ 1 2 3 4 5 Math.random() // Example return values: // #1: 0.60958701902852 // #2: 0.16182155144292465 // #3: 0.30126821448898133 Randomly generate integers in $[0, n]$ 1 2 3 4 5 6 7 8 9 10 11 function randint1(n) { // Relatively balanced probability distribution return Math.round(Math.random() * n); } function randint2(n) { // n will never occur return Math.floor(Math.random() * n); } function randint3(n) { // Extremely low probability of 0, same as Math.random() producing 0 return Math.ceil(Math.random() * n); } Generate random decimal numbers with one decimal place in $[0, n]$ 1 2 3 4 // May have floating-point precision errors, e.g., 0.30000000000000004, 0.7999999999999999 function randf(n) { return Math.round(Math.random() * n * 10) / 10; } ","date":"2020-02-09T20:01:00+08:00","permalink":"https://goodcoder666.github.io/en/p/js-random/","title":"Generating Random Numbers in JS"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Complete Error\r1 2 3 4 5 jsEnginScriptError: Component is not found in path \u0026#34;components/comp/comp.js\u0026#34; (using by pages/index/index); onAppRoute Error: Component is not found in path \u0026#34;components/comp/comp.js\u0026#34; (using by pages/index/index) in e(...) ... Error Code (json)\r1 2 3 4 5 6 7 8 9 { \u0026#34;backgroundTextStyle\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;navigationBarBackgroundColor\u0026#34;: \u0026#34;#fff\u0026#34;, \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;WeApp\u0026#34;, \u0026#34;navigationBarTextStyle\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;usingComponents\u0026#34;: { \u0026#34;MyComp\u0026#34;: \u0026#34;../../components/comp/comp.js\u0026#34; } } Solution\rRemove .js extension and modify to ../../components/comp/comp:\n1 2 3 4 5 6 7 8 { \u0026#34;backgroundTextStyle\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;navigationBarBackgroundColor\u0026#34;: \u0026#34;#fff\u0026#34;, \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;WeApp\u0026#34;, \u0026#34;navigationBarTextStyle\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;usingComponents\u0026#34;: { \u0026#34;MyComp\u0026#34;: \u0026#34;../../components/comp/comp\u0026#34; } ","date":"2020-02-05T12:26:00+08:00","permalink":"https://goodcoder666.github.io/en/p/wmp-component-not-found/","title":"WeChat Mini Program Error: Component is not found in path \"components/comp/comp.js\""},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Collection.orderBy / Query.orderBy\nSpecify query sorting conditions\nMethod signature:\n1 function orderBy(fieldName: string, order: string): Collection | Query The method takes a required string parameter fieldName to define the field to sort, and a string parameter order to define the sort direction. order can only be asc or desc.\nTo sort nested fields, use \u0026ldquo;dot notation\u0026rdquo; to connect nested fields. For example, style.color represents the nested field color within the style field.\nSupports sorting by multiple fields through multiple orderBy calls. The sort order of multiple fields will follow the sequence of orderBy calls.\nExample code:\nSort by single field: Retrieve todos sorted by progress in ascending order 1 2 3 4 5 const db = wx.cloud.database() db.collection(\u0026#39;todos\u0026#39;).orderBy(\u0026#39;progress\u0026#39;, \u0026#39;asc\u0026#39;) .get() .then(console.log) .catch(console.error) Sort by multiple fields:\nRetrieve todos first sorted by progress descending (higher progress first), then by description ascending (earlier alphabetical order first): 1 2 3 4 5 6 7 const db = wx.cloud.database() db.collection(\u0026#39;todos\u0026#39;) .orderBy(\u0026#39;progress\u0026#39;, \u0026#39;desc\u0026#39;) .orderBy(\u0026#39;description\u0026#39;, \u0026#39;asc\u0026#39;) .get() .then(console.log) .catch(console.error) Source: WeChat Official Documentation ¬∑ Mini Program -\u0026gt; Cloud Development -\u0026gt; Database -\u0026gt; Collection.orderBy / Query.orderBy\n","date":"2020-02-04T15:53:00+08:00","permalink":"https://goodcoder666.github.io/en/p/wmp-cloud-orderby/","title":"WeChat Mini Program Cloud Database Collection/Query .orderBy Usage"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Simply having onPullDownRefresh isn\u0026rsquo;t enough - you must configure:\rFor a single page requiring onPullDownRefresh, set \u0026quot;enablePullDownRefresh\u0026quot;: true in the corresponding page\u0026rsquo;s json file. Example: 1 2 3 4 5 6 7 { \u0026#34;backgroundTextStyle\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;navigationBarBackgroundColor\u0026#34;: \u0026#34;#fff\u0026#34;, \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;Demo Page\u0026#34;, \u0026#34;navigationBarTextStyle\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;enablePullDownRefresh\u0026#34;: true } If all pages require onPullDownRefresh, either set \u0026quot;enablePullDownRefresh\u0026quot;: true for each page individually, or configure it in app.json: 1 2 3 4 5 6 { ... \u0026#34;window\u0026#34;: { \u0026#34;enablePullDownRefresh\u0026#34;: true } } ","date":"2020-02-04T13:10:00+08:00","permalink":"https://goodcoder666.github.io/en/p/wmp-enable-onpulldownrefresh/","title":"Why the onPullDownRefresh Setting in WeChat Mini Program Doesn't Work"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Error:\r1 -501007 invalid parameters | errMsg: Invalid Key Name: _openid Cause:\rCannot manually set _openid field, it\u0026rsquo;s automatically populated by the cloud server based on user\u0026rsquo;s OpenID\nSolution:\rRemove openID field from data object\nIncorrect Code\r1 2 3 4 5 6 7 8 wx.cloud.database().collection(\u0026#39;people\u0026#39;).add({ data: { \u0026#39;_openid\u0026#39;: openID, \u0026#39;name\u0026#39;: nickName, \u0026#39;avatarUrl\u0026#39;: avatarUrl, \u0026#39;score\u0026#39;: score } }) Corrected Code\r1 2 3 4 5 6 7 wx.cloud.database().collection(\u0026#39;people\u0026#39;).add({ data: { \u0026#39;name\u0026#39;: nickName, \u0026#39;avatarUrl\u0026#39;: avatarUrl, \u0026#39;score\u0026#39;: score } }) ","date":"2020-02-03T21:07:00+08:00","permalink":"https://goodcoder666.github.io/en/p/wmp-cloud-invalidkey-openid/","title":"WeChat Mini Program - Cloud Development - Database Error: -501007 invalid parameters | errMsg: Invalid Key Name: _openid"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed If cloud development is not enabled, see this article\nBase library version must be 2.3.3* or higher*, recommended to use latest version\nCreate new cloud function:\nRight-click cloudfunctions, select New Node.js Cloud Function\nEnter login\nCurrent appearance of cloud development console:\nThis function saves openID to local storage and calls error on failure:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function saveOpenID(error) { if (!wx.getStorageSync(\u0026#39;openID\u0026#39;)) { wx.cloud.callFunction({ name: \u0026#39;login\u0026#39;, data: {}, success: res =\u0026gt; { console.log(\u0026#39;Got user openid: \u0026#39;, res.result.openid) wx.setStorageSync(\u0026#39;openID\u0026#39;, res.result.openid) }, fail: err =\u0026gt; { console.error(err) error() } }) } } ","date":"2020-02-03T17:57:00+08:00","permalink":"https://goodcoder666.github.io/en/p/wmp-cloud-getopenid/","title":"Getting Mini Program User openId via Cloud Function"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed 1 2 3 4 5 6 wx.showToast({ title: \u0026#39;Success\u0026#39;, icon: \u0026#39;fail\u0026#39;, duration: 2000, success: func }) 1 2 3 4 5 6 7 8 wx.showToast({ title: \u0026#39;Success\u0026#39;, icon: \u0026#39;fail\u0026#39;, duration: 2000, success: res =\u0026gt; { func() } }) Why do both code snippets execute func \u0026ldquo;immediately\u0026rdquo;?\rBecause the success callback is called as soon as the toast is successfully displayed. To execute func after duration milliseconds, use:\n1 2 3 4 5 6 wx.showToast({ title: \u0026#39;Success\u0026#39;, icon: \u0026#39;fail\u0026#39;, duration: 2000, }) setTimeout(func, 2000) ","date":"2020-02-02T15:43:00+08:00","permalink":"https://goodcoder666.github.io/en/p/wx-showtoast-problem/","title":"An Issue in wx.showToast"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Error\r1 2 3 4 5 Uncaught (in promise) thirdScriptError errCode: -401003 api parameter type error | errMsg: parameter.data should be object instead of undefined; Error: errCode: -401003 api parameter type error | errMsg: parameter.data should be object instead of undefined; at new u (...) ... Error Cause\rIncorrect Code\r1 2 3 4 5 6 7 8 9 10 11 12 wx.cloud.init({ env: \u0026#39;my-cloud-id\u0026#39;, traceUser: true }) const db = wx.cloud.database() const people = db.collection(\u0026#39;people\u0026#39;) people.add({ // \u0026lt;- Error occurs here \u0026#39;name\u0026#39;: \u0026#39;OnePerson\u0026#39;, \u0026#39;score\u0026#39;: 15 }) Correct Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 wx.cloud.init({ env: \u0026#39;my-cloud-id\u0026#39;, traceUser: true }) const db = wx.cloud.database() const people = db.collection(\u0026#39;people\u0026#39;) people.add({ data: { // Must include data! \u0026#39;name\u0026#39;: \u0026#39;OnePerson\u0026#39;, \u0026#39;score\u0026#39;: 15 } }) ","date":"2020-02-02T11:17:00+08:00","permalink":"https://goodcoder666.github.io/en/p/wmp-cloud-errcode-401003/","title":"Error When Using WeChat Mini Program Cloud Development: Error: errCode: -401003 api parameter type error | errMsg: parameter.data should ..."},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed 1 2 Date.now() // Get milliseconds from 1970-01-01 to current Date.UTC(2000, 1, 1) // Get milliseconds from 1970-01-01 to 2000-01-01 ","date":"2020-01-31T17:06:00+08:00","permalink":"https://goodcoder666.github.io/en/p/js-utc/","title":"js Get Milliseconds from 1970-01-01 to Current Time"},{"content":" Translation Notice\nThis article was machine-translated using DeepSeek-R1.\nOriginal Version: Authored in Chinese by myself Accuracy Advisory: Potential discrepancies may exist between translations Precedence: The Chinese text shall prevail in case of ambiguity Feedback: Technical suggestions regarding translation quality are welcomed Why Build a Custom Keyboard?\rI\u0026rsquo;m currently developing a WeChat Mini Program that requires users to input numbers.\nIssues with System Keyboards\rUsing system keyboards presents several problems:\nSmall key sizes make input inconvenient; No way to prevent invalid characters (e.g., \u0026ldquo;\u0026amp;\u0026rdquo;); Decimal point is hard to locate on some devices; Users must click input fields first; Inability to customize button styles. Ideal Custom Keyboard Layout\r123\n456\n789\n.0Submit\nBackspaceClear\nHow to Build It?\rGroup each row of buttons in a view:\nWXML\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!--pages/a/a.wxml--\u0026gt; \u0026lt;!--Input Keyboard--\u0026gt; \u0026lt;!--Five rows, each in a view--\u0026gt; \u0026lt;view class=\u0026#39;keyboard-row\u0026#39;\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;one\u0026#39; data-key=\u0026#39;1\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;1\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;two\u0026#39; data-key=\u0026#39;2\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;2\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;three\u0026#39; data-key=\u0026#39;3\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;3\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#39;keyboard-row\u0026#39;\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;four\u0026#39; data-key=\u0026#39;4\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;4\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;five\u0026#39; data-key=\u0026#39;5\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;5\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;six\u0026#39; data-key=\u0026#39;6\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;6\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#39;keyboard-row\u0026#39;\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;seven\u0026#39; data-key=\u0026#39;7\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;7\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;eight\u0026#39; data-key=\u0026#39;8\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;8\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;nine\u0026#39; data-key=\u0026#39;9\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;9\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#39;keyboard-row\u0026#39;\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;dot\u0026#39; data-key=\u0026#39;.\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;.\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;zero\u0026#39; data-key=\u0026#39;0\u0026#39; bindtap=\u0026#39;tapKey\u0026#39;\u0026gt;0\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;submit\u0026#39; bindtap=\u0026#39;tapSubmit\u0026#39;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;!--clear\u0026amp;delete--\u0026gt; \u0026lt;view class=\u0026#39;keyboard-row\u0026#39;\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;del\u0026#39; bindtap=\u0026#39;tapDel\u0026#39;\u0026gt;Backspace\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#39;default\u0026#39; plain=\u0026#39;true\u0026#39; class=\u0026#39;clear\u0026#39; bindtap=\u0026#39;tapClear\u0026#39;\u0026gt;Clear\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; WXSS\n1 2 3 4 5 6 7 8 9 10 /*pages/a/a.wxss*/ .keyboard-row { width: 100%; height: 35%; border-radius: 98rpx; display: flex; flex-direction: row; align-items: center; justify-content: center; } JS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // pages/a/a.js Page({ data: { num: 0, hasDot: false // Prevent multiple decimal points }, tapKey: function(evt) { var x = evt.currentTarget.dataset.key if(x == \u0026#39;.\u0026#39;) { if(this.data.hasDot) return this.setData({ hasDot: true }) } this.setData({ num: this.data.num == \u0026#39;0\u0026#39;? x: this.data.num + x }) }, tapSubmit: function() { // User has submitted console.log(\u0026#39;res =\u0026#39;, this.data.num) }, tapDel: function() { if(this.data.num == \u0026#39;0\u0026#39;) return if(this.data.num[this.data.num.length - 1] == \u0026#39;.\u0026#39;) this.setData({ hasDot: false }) this.setData({ num: this.data.num.length == 1? \u0026#39;0\u0026#39;: this.data.num.substring(0, this.data.num.length - 1) }) }, tapClear: function() { this.setData({ num: \u0026#39;0\u0026#39;, hasDot: false }) } }) Keyboard Preview\r","date":"2020-01-31T10:30:00+08:00","permalink":"https://goodcoder666.github.io/en/p/wmp-diy-nkeyboard/","title":"Building a Custom Numeric Keyboard in WeChat Mini Program"}]